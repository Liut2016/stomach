{"remainingRequest":"/home/liutao/Project/0/oncology/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/home/liutao/Project/0/oncology/node_modules/@angular/material/esm5/radio.es5.js","dependencies":[{"path":"/home/liutao/Project/0/oncology/node_modules/@angular/material/esm5/radio.es5.js","mtime":1526941038000},{"path":"/home/liutao/Project/0/oncology/node_modules/cache-loader/dist/cjs.js","mtime":1539266424898},{"path":"/home/liutao/Project/0/oncology/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1526531406000}],"contextDependencies":[],"result":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** PURE_IMPORTS_START tslib,_angular_cdk_a11y,_angular_cdk_coercion,_angular_cdk_collections,_angular_core,_angular_forms,_angular_material_core,_angular_platform_browser_animations,_angular_common PURE_IMPORTS_END */\nimport { __extends } from 'tslib';\nimport { FocusMonitor } from '@angular/cdk/a11y';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { UniqueSelectionDispatcher } from '@angular/cdk/collections';\nimport { ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChildren, Directive, ElementRef, EventEmitter, forwardRef, Input, Optional, Output, ViewChild, ViewEncapsulation, Inject, NgModule } from '@angular/core';\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { MatRipple, mixinColor, mixinDisabled, mixinDisableRipple, mixinTabIndex, MatCommonModule, MatRippleModule } from '@angular/material/core';\nimport { ANIMATION_MODULE_TYPE } from '@angular/platform-browser/animations';\nimport { CommonModule } from '@angular/common';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n// Increasing integer for generating unique ids for radio components.\nvar /** @type {?} */ nextUniqueId = 0;\n/**\n * Provider Expression that allows mat-radio-group to register as a ControlValueAccessor. This\n * allows it to support [(ngModel)] and ngControl.\n * \\@docs-private\n */\nvar /** @type {?} */ MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR = {\n    provide: NG_VALUE_ACCESSOR,\n    useExisting: /*@__PURE__*/ forwardRef(function () { return MatRadioGroup; }),\n    multi: true\n};\n/**\n * Change event object emitted by MatRadio and MatRadioGroup.\n */\nvar /**\n * Change event object emitted by MatRadio and MatRadioGroup.\n */ MatRadioChange = /*@__PURE__*/ (function () {\n    function MatRadioChange(source, value) {\n        this.source = source;\n        this.value = value;\n    }\n    return MatRadioChange;\n}());\n/**\n * \\@docs-private\n */\nvar /**\n * \\@docs-private\n */ MatRadioGroupBase = /*@__PURE__*/ (function () {\n    function MatRadioGroupBase() {\n    }\n    return MatRadioGroupBase;\n}());\nvar /** @type {?} */ _MatRadioGroupMixinBase = /*@__PURE__*/ mixinDisabled(MatRadioGroupBase);\n/**\n * A group of radio buttons. May contain one or more `<mat-radio-button>` elements.\n */\nvar MatRadioGroup = /*@__PURE__*/ (function (_super) {\n    __extends(MatRadioGroup, _super);\n    function MatRadioGroup(_changeDetector) {\n        var _this = _super.call(this) || this;\n        _this._changeDetector = _changeDetector;\n        /**\n         * Selected value for group. Should equal the value of the selected radio button if there *is*\n         * a corresponding radio button with a matching value. If there is *not* such a corresponding\n         * radio button, this value persists to be applied in case a new radio button is added with a\n         * matching value.\n         */\n        _this._value = null;\n        /**\n         * The HTML name attribute applied to radio buttons in this group.\n         */\n        _this._name = \"mat-radio-group-\" + nextUniqueId++;\n        /**\n         * The currently selected radio button. Should match value.\n         */\n        _this._selected = null;\n        /**\n         * Whether the `value` has been set to its initial value.\n         */\n        _this._isInitialized = false;\n        /**\n         * Whether the labels should appear after or before the radio-buttons. Defaults to 'after'\n         */\n        _this._labelPosition = 'after';\n        /**\n         * Whether the radio group is disabled.\n         */\n        _this._disabled = false;\n        /**\n         * Whether the radio group is required.\n         */\n        _this._required = false;\n        /**\n         * The method to be called in order to update ngModel\n         */\n        _this._controlValueAccessorChangeFn = function () { };\n        /**\n         * onTouch function registered via registerOnTouch (ControlValueAccessor).\n         * \\@docs-private\n         */\n        _this.onTouched = function () { };\n        /**\n         * Event emitted when the group value changes.\n         * Change events are only emitted when the value changes due to user interaction with\n         * a radio button (the same behavior as `<input type-\"radio\">`).\n         */\n        _this.change = new EventEmitter();\n        return _this;\n    }\n    Object.defineProperty(MatRadioGroup.prototype, \"name\", {\n        get: /**\n         * Name of the radio button group. All radio buttons inside this group will use this name.\n         * @return {?}\n         */ function () { return this._name; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._name = value;\n            this._updateRadioButtonNames();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatRadioGroup.prototype, \"labelPosition\", {\n        get: /**\n         * Whether the labels should appear after or before the radio-buttons. Defaults to 'after'\n         * @return {?}\n         */ function () {\n            return this._labelPosition;\n        },\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */ function (v) {\n            this._labelPosition = v === 'before' ? 'before' : 'after';\n            this._markRadiosForCheck();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatRadioGroup.prototype, \"value\", {\n        get: /**\n         * Value of the radio button.\n         * @return {?}\n         */ function () { return this._value; },\n        set: /**\n         * @param {?} newValue\n         * @return {?}\n         */ function (newValue) {\n            if (this._value !== newValue) {\n                // Set this before proceeding to ensure no circular loop occurs with selection.\n                this._value = newValue;\n                this._updateSelectedRadioFromValue();\n                this._checkSelectedRadioButton();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    MatRadioGroup.prototype._checkSelectedRadioButton = /**\n     * @return {?}\n     */\n        function () {\n            if (this._selected && !this._selected.checked) {\n                this._selected.checked = true;\n            }\n        };\n    Object.defineProperty(MatRadioGroup.prototype, \"selected\", {\n        get: /**\n         * Whether the radio button is selected.\n         * @return {?}\n         */ function () { return this._selected; },\n        set: /**\n         * @param {?} selected\n         * @return {?}\n         */ function (selected) {\n            this._selected = selected;\n            this.value = selected ? selected.value : null;\n            this._checkSelectedRadioButton();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatRadioGroup.prototype, \"disabled\", {\n        get: /**\n         * Whether the radio group is disabled\n         * @return {?}\n         */ function () { return this._disabled; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._disabled = coerceBooleanProperty(value);\n            this._markRadiosForCheck();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatRadioGroup.prototype, \"required\", {\n        get: /**\n         * Whether the radio group is required\n         * @return {?}\n         */ function () { return this._required; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._required = coerceBooleanProperty(value);\n            this._markRadiosForCheck();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Initialize properties once content children are available.\n     * This allows us to propagate relevant attributes to associated buttons.\n     */\n    /**\n     * Initialize properties once content children are available.\n     * This allows us to propagate relevant attributes to associated buttons.\n     * @return {?}\n     */\n    MatRadioGroup.prototype.ngAfterContentInit = /**\n     * Initialize properties once content children are available.\n     * This allows us to propagate relevant attributes to associated buttons.\n     * @return {?}\n     */\n        function () {\n            // Mark this component as initialized in AfterContentInit because the initial value can\n            // possibly be set by NgModel on MatRadioGroup, and it is possible that the OnInit of the\n            // NgModel occurs *after* the OnInit of the MatRadioGroup.\n            this._isInitialized = true;\n        };\n    /**\n     * Mark this group as being \"touched\" (for ngModel). Meant to be called by the contained\n     * radio buttons upon their blur.\n     */\n    /**\n     * Mark this group as being \"touched\" (for ngModel). Meant to be called by the contained\n     * radio buttons upon their blur.\n     * @return {?}\n     */\n    MatRadioGroup.prototype._touch = /**\n     * Mark this group as being \"touched\" (for ngModel). Meant to be called by the contained\n     * radio buttons upon their blur.\n     * @return {?}\n     */\n        function () {\n            if (this.onTouched) {\n                this.onTouched();\n            }\n        };\n    /**\n     * @return {?}\n     */\n    MatRadioGroup.prototype._updateRadioButtonNames = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            if (this._radios) {\n                this._radios.forEach(function (radio) {\n                    radio.name = _this.name;\n                });\n            }\n        };\n    /**\n     * Updates the `selected` radio button from the internal _value state.\n     * @return {?}\n     */\n    MatRadioGroup.prototype._updateSelectedRadioFromValue = /**\n     * Updates the `selected` radio button from the internal _value state.\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            // If the value already matches the selected radio, do nothing.\n            var /** @type {?} */ isAlreadySelected = this._selected !== null && this._selected.value === this._value;\n            if (this._radios && !isAlreadySelected) {\n                this._selected = null;\n                this._radios.forEach(function (radio) {\n                    radio.checked = _this.value === radio.value;\n                    if (radio.checked) {\n                        _this._selected = radio;\n                    }\n                });\n            }\n        };\n    /** Dispatch change event with current selection and group value. */\n    /**\n     * Dispatch change event with current selection and group value.\n     * @return {?}\n     */\n    MatRadioGroup.prototype._emitChangeEvent = /**\n     * Dispatch change event with current selection and group value.\n     * @return {?}\n     */\n        function () {\n            if (this._isInitialized) {\n                this.change.emit(new MatRadioChange(/** @type {?} */ ((this._selected)), this._value));\n            }\n        };\n    /**\n     * @return {?}\n     */\n    MatRadioGroup.prototype._markRadiosForCheck = /**\n     * @return {?}\n     */\n        function () {\n            if (this._radios) {\n                this._radios.forEach(function (radio) { return radio._markForCheck(); });\n            }\n        };\n    /**\n     * Sets the model value. Implemented as part of ControlValueAccessor.\n     * @param value\n     */\n    /**\n     * Sets the model value. Implemented as part of ControlValueAccessor.\n     * @param {?} value\n     * @return {?}\n     */\n    MatRadioGroup.prototype.writeValue = /**\n     * Sets the model value. Implemented as part of ControlValueAccessor.\n     * @param {?} value\n     * @return {?}\n     */\n        function (value) {\n            this.value = value;\n            this._changeDetector.markForCheck();\n        };\n    /**\n     * Registers a callback to be triggered when the model value changes.\n     * Implemented as part of ControlValueAccessor.\n     * @param fn Callback to be registered.\n     */\n    /**\n     * Registers a callback to be triggered when the model value changes.\n     * Implemented as part of ControlValueAccessor.\n     * @param {?} fn Callback to be registered.\n     * @return {?}\n     */\n    MatRadioGroup.prototype.registerOnChange = /**\n     * Registers a callback to be triggered when the model value changes.\n     * Implemented as part of ControlValueAccessor.\n     * @param {?} fn Callback to be registered.\n     * @return {?}\n     */\n        function (fn) {\n            this._controlValueAccessorChangeFn = fn;\n        };\n    /**\n     * Registers a callback to be triggered when the control is touched.\n     * Implemented as part of ControlValueAccessor.\n     * @param fn Callback to be registered.\n     */\n    /**\n     * Registers a callback to be triggered when the control is touched.\n     * Implemented as part of ControlValueAccessor.\n     * @param {?} fn Callback to be registered.\n     * @return {?}\n     */\n    MatRadioGroup.prototype.registerOnTouched = /**\n     * Registers a callback to be triggered when the control is touched.\n     * Implemented as part of ControlValueAccessor.\n     * @param {?} fn Callback to be registered.\n     * @return {?}\n     */\n        function (fn) {\n            this.onTouched = fn;\n        };\n    /**\n     * Sets the disabled state of the control. Implemented as a part of ControlValueAccessor.\n     * @param isDisabled Whether the control should be disabled.\n     */\n    /**\n     * Sets the disabled state of the control. Implemented as a part of ControlValueAccessor.\n     * @param {?} isDisabled Whether the control should be disabled.\n     * @return {?}\n     */\n    MatRadioGroup.prototype.setDisabledState = /**\n     * Sets the disabled state of the control. Implemented as a part of ControlValueAccessor.\n     * @param {?} isDisabled Whether the control should be disabled.\n     * @return {?}\n     */\n        function (isDisabled) {\n            this.disabled = isDisabled;\n            this._changeDetector.markForCheck();\n        };\n    return MatRadioGroup;\n}(_MatRadioGroupMixinBase));\n/**\n * \\@docs-private\n */\nvar /**\n * \\@docs-private\n */ MatRadioButtonBase = /*@__PURE__*/ (function () {\n    function MatRadioButtonBase(_elementRef) {\n        this._elementRef = _elementRef;\n    }\n    return MatRadioButtonBase;\n}());\n// As per Material design specifications the selection control radio should use the accent color\n// palette by default. https://material.io/guidelines/components/selection-controls.html\nvar /** @type {?} */ _MatRadioButtonMixinBase = /*@__PURE__*/ mixinColor(/*@__PURE__*/ mixinDisableRipple(/*@__PURE__*/ mixinTabIndex(MatRadioButtonBase)), 'accent');\n/**\n * A Material design radio-button. Typically placed inside of `<mat-radio-group>` elements.\n */\nvar MatRadioButton = /*@__PURE__*/ (function (_super) {\n    __extends(MatRadioButton, _super);\n    function MatRadioButton(radioGroup, elementRef, _changeDetector, _focusMonitor, _radioDispatcher, _animationMode) {\n        var _this = _super.call(this, elementRef) || this;\n        _this._changeDetector = _changeDetector;\n        _this._focusMonitor = _focusMonitor;\n        _this._radioDispatcher = _radioDispatcher;\n        _this._animationMode = _animationMode;\n        _this._uniqueId = \"mat-radio-\" + ++nextUniqueId;\n        /**\n         * The unique ID for the radio button.\n         */\n        _this.id = _this._uniqueId;\n        /**\n         * Event emitted when the checked state of this radio button changes.\n         * Change events are only emitted when the value changes due to user interaction with\n         * the radio button (the same behavior as `<input type-\"radio\">`).\n         */\n        _this.change = new EventEmitter();\n        /**\n         * Whether this radio is checked.\n         */\n        _this._checked = false;\n        /**\n         * Value assigned to this radio.\n         */\n        _this._value = null;\n        /**\n         * Unregister function for _radioDispatcher\n         */\n        _this._removeUniqueSelectionListener = function () { };\n        // Assertions. Ideally these should be stripped out by the compiler.\n        // TODO(jelbourn): Assert that there's no name binding AND a parent radio group.\n        // Assertions. Ideally these should be stripped out by the compiler.\n        // TODO(jelbourn): Assert that there's no name binding AND a parent radio group.\n        _this.radioGroup = radioGroup;\n        _this._removeUniqueSelectionListener =\n            _radioDispatcher.listen(function (id, name) {\n                if (id !== _this.id && name === _this.name) {\n                    _this.checked = false;\n                }\n            });\n        return _this;\n    }\n    Object.defineProperty(MatRadioButton.prototype, \"checked\", {\n        get: /**\n         * Whether this radio button is checked.\n         * @return {?}\n         */ function () { return this._checked; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            var /** @type {?} */ newCheckedState = coerceBooleanProperty(value);\n            if (this._checked !== newCheckedState) {\n                this._checked = newCheckedState;\n                if (newCheckedState && this.radioGroup && this.radioGroup.value !== this.value) {\n                    this.radioGroup.selected = this;\n                }\n                else if (!newCheckedState && this.radioGroup && this.radioGroup.value === this.value) {\n                    // When unchecking the selected radio button, update the selected radio\n                    // property on the group.\n                    this.radioGroup.selected = null;\n                }\n                if (newCheckedState) {\n                    // Notify all radio buttons with the same name to un-check.\n                    this._radioDispatcher.notify(this.id, this.name);\n                }\n                this._changeDetector.markForCheck();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatRadioButton.prototype, \"value\", {\n        get: /**\n         * The value of this radio button.\n         * @return {?}\n         */ function () { return this._value; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            if (this._value !== value) {\n                this._value = value;\n                if (this.radioGroup !== null) {\n                    if (!this.checked) {\n                        // Update checked when the value changed to match the radio group's value\n                        this.checked = this.radioGroup.value === value;\n                    }\n                    if (this.checked) {\n                        this.radioGroup.selected = this;\n                    }\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatRadioButton.prototype, \"labelPosition\", {\n        get: /**\n         * Whether the label should appear after or before the radio button. Defaults to 'after'\n         * @return {?}\n         */ function () {\n            return this._labelPosition || (this.radioGroup && this.radioGroup.labelPosition) || 'after';\n        },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._labelPosition = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatRadioButton.prototype, \"disabled\", {\n        get: /**\n         * Whether the radio button is disabled.\n         * @return {?}\n         */ function () {\n            return this._disabled || (this.radioGroup !== null && this.radioGroup.disabled);\n        },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            var /** @type {?} */ newDisabledState = coerceBooleanProperty(value);\n            if (this._disabled !== newDisabledState) {\n                this._disabled = newDisabledState;\n                this._changeDetector.markForCheck();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatRadioButton.prototype, \"required\", {\n        get: /**\n         * Whether the radio button is required.\n         * @return {?}\n         */ function () {\n            return this._required || (this.radioGroup && this.radioGroup.required);\n        },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._required = coerceBooleanProperty(value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatRadioButton.prototype, \"inputId\", {\n        /** ID of the native input element inside `<mat-radio-button>` */\n        get: /**\n         * ID of the native input element inside `<mat-radio-button>`\n         * @return {?}\n         */ function () { return (this.id || this._uniqueId) + \"-input\"; },\n        enumerable: true,\n        configurable: true\n    });\n    /** Focuses the radio button. */\n    /**\n     * Focuses the radio button.\n     * @return {?}\n     */\n    MatRadioButton.prototype.focus = /**\n     * Focuses the radio button.\n     * @return {?}\n     */\n        function () {\n            this._focusMonitor.focusVia(this._inputElement.nativeElement, 'keyboard');\n        };\n    /**\n     * Marks the radio button as needing checking for change detection.\n     * This method is exposed because the parent radio group will directly\n     * update bound properties of the radio button.\n     */\n    /**\n     * Marks the radio button as needing checking for change detection.\n     * This method is exposed because the parent radio group will directly\n     * update bound properties of the radio button.\n     * @return {?}\n     */\n    MatRadioButton.prototype._markForCheck = /**\n     * Marks the radio button as needing checking for change detection.\n     * This method is exposed because the parent radio group will directly\n     * update bound properties of the radio button.\n     * @return {?}\n     */\n        function () {\n            // When group value changes, the button will not be notified. Use `markForCheck` to explicit\n            // update radio button's status\n            this._changeDetector.markForCheck();\n        };\n    /**\n     * @return {?}\n     */\n    MatRadioButton.prototype.ngOnInit = /**\n     * @return {?}\n     */\n        function () {\n            if (this.radioGroup) {\n                // If the radio is inside a radio group, determine if it should be checked\n                this.checked = this.radioGroup.value === this._value;\n                // Copy name from parent radio group\n                this.name = this.radioGroup.name;\n            }\n        };\n    /**\n     * @return {?}\n     */\n    MatRadioButton.prototype.ngAfterViewInit = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            this._focusMonitor\n                .monitor(this._inputElement.nativeElement)\n                .subscribe(function (focusOrigin) { return _this._onInputFocusChange(focusOrigin); });\n        };\n    /**\n     * @return {?}\n     */\n    MatRadioButton.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            this._focusMonitor.stopMonitoring(this._inputElement.nativeElement);\n            this._removeUniqueSelectionListener();\n        };\n    /**\n     * Dispatch change event with current value.\n     * @return {?}\n     */\n    MatRadioButton.prototype._emitChangeEvent = /**\n     * Dispatch change event with current value.\n     * @return {?}\n     */\n        function () {\n            this.change.emit(new MatRadioChange(this, this._value));\n        };\n    /**\n     * @return {?}\n     */\n    MatRadioButton.prototype._isRippleDisabled = /**\n     * @return {?}\n     */\n        function () {\n            return this.disableRipple || this.disabled;\n        };\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    MatRadioButton.prototype._onInputClick = /**\n     * @param {?} event\n     * @return {?}\n     */\n        function (event) {\n            // We have to stop propagation for click events on the visual hidden input element.\n            // By default, when a user clicks on a label element, a generated click event will be\n            // dispatched on the associated input element. Since we are using a label element as our\n            // root container, the click event on the `radio-button` will be executed twice.\n            // The real click event will bubble up, and the generated click event also tries to bubble up.\n            // This will lead to multiple click events.\n            // Preventing bubbling for the second event will solve that issue.\n            event.stopPropagation();\n        };\n    /**\n     * Triggered when the radio button received a click or the input recognized any change.\n     * Clicking on a label element, will trigger a change event on the associated input.\n     */\n    /**\n     * Triggered when the radio button received a click or the input recognized any change.\n     * Clicking on a label element, will trigger a change event on the associated input.\n     * @param {?} event\n     * @return {?}\n     */\n    MatRadioButton.prototype._onInputChange = /**\n     * Triggered when the radio button received a click or the input recognized any change.\n     * Clicking on a label element, will trigger a change event on the associated input.\n     * @param {?} event\n     * @return {?}\n     */\n        function (event) {\n            // We always have to stop propagation on the change event.\n            // Otherwise the change event, from the input element, will bubble up and\n            // emit its event object to the `change` output.\n            event.stopPropagation();\n            var /** @type {?} */ groupValueChanged = this.radioGroup && this.value !== this.radioGroup.value;\n            this.checked = true;\n            this._emitChangeEvent();\n            if (this.radioGroup) {\n                this.radioGroup._controlValueAccessorChangeFn(this.value);\n                this.radioGroup._touch();\n                if (groupValueChanged) {\n                    this.radioGroup._emitChangeEvent();\n                }\n            }\n        };\n    /**\n     * Function is called whenever the focus changes for the input element.\n     * @param {?} focusOrigin\n     * @return {?}\n     */\n    MatRadioButton.prototype._onInputFocusChange = /**\n     * Function is called whenever the focus changes for the input element.\n     * @param {?} focusOrigin\n     * @return {?}\n     */\n        function (focusOrigin) {\n            // TODO(paul): support `program`. See https://github.com/angular/material2/issues/9889\n            if (!this._focusRipple && focusOrigin === 'keyboard') {\n                this._focusRipple = this._ripple.launch(0, 0, { persistent: true });\n            }\n            else if (!focusOrigin) {\n                if (this.radioGroup) {\n                    this.radioGroup._touch();\n                }\n                if (this._focusRipple) {\n                    this._focusRipple.fadeOut();\n                    this._focusRipple = null;\n                }\n            }\n        };\n    return MatRadioButton;\n}(_MatRadioButtonMixinBase));\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar MatRadioModule = /*@__PURE__*/ (function () {\n    function MatRadioModule() {\n    }\n    return MatRadioModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nexport { MatRadioModule, MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR, MatRadioChange, MatRadioGroupBase, _MatRadioGroupMixinBase, MatRadioGroup, MatRadioButtonBase, _MatRadioButtonMixinBase, MatRadioButton };\n//# sourceMappingURL=radio.es5.js.map\n",null]}