{"remainingRequest":"/home/liutao/Project/0/oncology/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/home/liutao/Project/0/oncology/node_modules/@angular/material/esm5/datepicker.es5.js","dependencies":[{"path":"/home/liutao/Project/0/oncology/node_modules/@angular/material/esm5/datepicker.es5.js","mtime":1526941038000},{"path":"/home/liutao/Project/0/oncology/node_modules/cache-loader/dist/cjs.js","mtime":1539266424898},{"path":"/home/liutao/Project/0/oncology/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1526531406000}],"contextDependencies":[],"result":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** PURE_IMPORTS_START _angular_core,rxjs,rxjs_operators,_angular_cdk_keycodes,_angular_material_core,_angular_cdk_bidi,_angular_cdk_portal,_angular_animations,tslib,_angular_cdk_coercion,_angular_cdk_overlay,_angular_common,_angular_material_dialog,_angular_forms,_angular_material_form_field,_angular_material_input,_angular_cdk_a11y,_angular_material_button PURE_IMPORTS_END */\nimport { Injectable, NgModule, ChangeDetectionStrategy, ChangeDetectorRef, Component, EventEmitter, forwardRef, Inject, Input, Optional, Output, ViewChild, ViewEncapsulation, ElementRef, NgZone, InjectionToken, ViewContainerRef, Directive, ContentChild, defineInjectable } from '@angular/core';\nimport { Subject, merge, Subscription, of } from 'rxjs';\nimport { take, filter } from 'rxjs/operators';\nimport { DOWN_ARROW, END, ENTER, HOME, LEFT_ARROW, PAGE_DOWN, PAGE_UP, RIGHT_ARROW, UP_ARROW, ESCAPE } from '@angular/cdk/keycodes';\nimport { DateAdapter, MAT_DATE_FORMATS, mixinColor } from '@angular/material/core';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { ComponentPortal, PortalModule } from '@angular/cdk/portal';\nimport { animate, state, style, transition, trigger, group, query, animateChild } from '@angular/animations';\nimport { __extends } from 'tslib';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { Overlay, OverlayConfig, OverlayModule } from '@angular/cdk/overlay';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport { MatDialog, MatDialogModule } from '@angular/material/dialog';\nimport { NG_VALIDATORS, NG_VALUE_ACCESSOR, Validators } from '@angular/forms';\nimport { MatFormField } from '@angular/material/form-field';\nimport { MAT_INPUT_VALUE_ACCESSOR } from '@angular/material/input';\nimport { A11yModule } from '@angular/cdk/a11y';\nimport { MatButtonModule } from '@angular/material/button';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * \\@docs-private\n * @param {?} provider\n * @return {?}\n */\nfunction createMissingDateImplError(provider) {\n    return Error(\"MatDatepicker: No provider found for \" + provider + \". You must import one of the following \" +\n        \"modules at your application root: MatNativeDateModule, MatMomentDateModule, or provide a \" +\n        \"custom implementation.\");\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Datepicker data that requires internationalization.\n */\nvar MatDatepickerIntl = /*@__PURE__*/ (function () {\n    function MatDatepickerIntl() {\n        /**\n         * Stream that emits whenever the labels here are changed. Use this to notify\n         * components if the labels have changed after initialization.\n         */\n        this.changes = new Subject();\n        /**\n         * A label for the calendar popup (used by screen readers).\n         */\n        this.calendarLabel = 'Calendar';\n        /**\n         * A label for the button used to open the calendar popup (used by screen readers).\n         */\n        this.openCalendarLabel = 'Open calendar';\n        /**\n         * A label for the previous month button (used by screen readers).\n         */\n        this.prevMonthLabel = 'Previous month';\n        /**\n         * A label for the next month button (used by screen readers).\n         */\n        this.nextMonthLabel = 'Next month';\n        /**\n         * A label for the previous year button (used by screen readers).\n         */\n        this.prevYearLabel = 'Previous year';\n        /**\n         * A label for the next year button (used by screen readers).\n         */\n        this.nextYearLabel = 'Next year';\n        /**\n         * A label for the previous multi-year button (used by screen readers).\n         */\n        this.prevMultiYearLabel = 'Previous 20 years';\n        /**\n         * A label for the next multi-year button (used by screen readers).\n         */\n        this.nextMultiYearLabel = 'Next 20 years';\n        /**\n         * A label for the 'switch to month view' button (used by screen readers).\n         */\n        this.switchToMonthViewLabel = 'Choose date';\n        /**\n         * A label for the 'switch to year view' button (used by screen readers).\n         */\n        this.switchToMultiYearViewLabel = 'Choose month and year';\n    }\n    /** @nocollapse */ MatDatepickerIntl.ngInjectableDef = defineInjectable({ factory: function MatDatepickerIntl_Factory() { return new MatDatepickerIntl(); }, token: MatDatepickerIntl, providedIn: \"root\" });\n    return MatDatepickerIntl;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * An internal class that represents the data corresponding to a single calendar cell.\n * \\@docs-private\n */\nvar /**\n * An internal class that represents the data corresponding to a single calendar cell.\n * \\@docs-private\n */ MatCalendarCell = /*@__PURE__*/ (function () {\n    function MatCalendarCell(value, displayValue, ariaLabel, enabled) {\n        this.value = value;\n        this.displayValue = displayValue;\n        this.ariaLabel = ariaLabel;\n        this.enabled = enabled;\n    }\n    return MatCalendarCell;\n}());\n/**\n * An internal component used to display calendar data in a table.\n * \\@docs-private\n */\nvar MatCalendarBody = /*@__PURE__*/ (function () {\n    function MatCalendarBody(_elementRef, _ngZone) {\n        this._elementRef = _elementRef;\n        this._ngZone = _ngZone;\n        /**\n         * The number of columns in the table.\n         */\n        this.numCols = 7;\n        /**\n         * Whether to allow selection of disabled cells.\n         */\n        this.allowDisabledSelection = false;\n        /**\n         * The cell number of the active cell in the table.\n         */\n        this.activeCell = 0;\n        /**\n         * The aspect ratio (width / height) to use for the cells in the table. This aspect ratio will be\n         * maintained even as the table resizes.\n         */\n        this.cellAspectRatio = 1;\n        /**\n         * Emits when a new value is selected.\n         */\n        this.selectedValueChange = new EventEmitter();\n    }\n    /**\n     * @param {?} cell\n     * @return {?}\n     */\n    MatCalendarBody.prototype._cellClicked = /**\n     * @param {?} cell\n     * @return {?}\n     */\n        function (cell) {\n            if (!this.allowDisabledSelection && !cell.enabled) {\n                return;\n            }\n            this.selectedValueChange.emit(cell.value);\n        };\n    Object.defineProperty(MatCalendarBody.prototype, \"_firstRowOffset\", {\n        /** The number of blank cells to put at the beginning for the first row. */\n        get: /**\n         * The number of blank cells to put at the beginning for the first row.\n         * @return {?}\n         */ function () {\n            return this.rows && this.rows.length && this.rows[0].length ?\n                this.numCols - this.rows[0].length : 0;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @param {?} rowIndex\n     * @param {?} colIndex\n     * @return {?}\n     */\n    MatCalendarBody.prototype._isActiveCell = /**\n     * @param {?} rowIndex\n     * @param {?} colIndex\n     * @return {?}\n     */\n        function (rowIndex, colIndex) {\n            var /** @type {?} */ cellNumber = rowIndex * this.numCols + colIndex;\n            // Account for the fact that the first row may not have as many cells.\n            if (rowIndex) {\n                cellNumber -= this._firstRowOffset;\n            }\n            return cellNumber == this.activeCell;\n        };\n    /** Focuses the active cell after the microtask queue is empty. */\n    /**\n     * Focuses the active cell after the microtask queue is empty.\n     * @return {?}\n     */\n    MatCalendarBody.prototype._focusActiveCell = /**\n     * Focuses the active cell after the microtask queue is empty.\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            this._ngZone.runOutsideAngular(function () {\n                _this._ngZone.onStable.asObservable().pipe(take(1)).subscribe(function () {\n                    _this._elementRef.nativeElement.querySelector('.mat-calendar-body-active').focus();\n                });\n            });\n        };\n    return MatCalendarBody;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar /** @type {?} */ DAYS_PER_WEEK = 7;\n/**\n * An internal component used to display a single month in the datepicker.\n * \\@docs-private\n * @template D\n */\nvar MatMonthView = /*@__PURE__*/ (function () {\n    function MatMonthView(_changeDetectorRef, _dateFormats, _dateAdapter, _dir) {\n        this._changeDetectorRef = _changeDetectorRef;\n        this._dateFormats = _dateFormats;\n        this._dateAdapter = _dateAdapter;\n        this._dir = _dir;\n        /**\n         * Emits when a new date is selected.\n         */\n        this.selectedChange = new EventEmitter();\n        /**\n         * Emits when any date is selected.\n         */\n        this._userSelection = new EventEmitter();\n        /**\n         * Emits when any date is activated.\n         */\n        this.activeDateChange = new EventEmitter();\n        if (!this._dateAdapter) {\n            throw createMissingDateImplError('DateAdapter');\n        }\n        if (!this._dateFormats) {\n            throw createMissingDateImplError('MAT_DATE_FORMATS');\n        }\n        var /** @type {?} */ firstDayOfWeek = this._dateAdapter.getFirstDayOfWeek();\n        var /** @type {?} */ narrowWeekdays = this._dateAdapter.getDayOfWeekNames('narrow');\n        var /** @type {?} */ longWeekdays = this._dateAdapter.getDayOfWeekNames('long');\n        // Rotate the labels for days of the week based on the configured first day of the week.\n        var /** @type {?} */ weekdays = longWeekdays.map(function (long, i) {\n            return { long: long, narrow: narrowWeekdays[i] };\n        });\n        this._weekdays = weekdays.slice(firstDayOfWeek).concat(weekdays.slice(0, firstDayOfWeek));\n        this._activeDate = this._dateAdapter.today();\n    }\n    Object.defineProperty(MatMonthView.prototype, \"activeDate\", {\n        get: /**\n         * The date to display in this month view (everything other than the month and year is ignored).\n         * @return {?}\n         */ function () { return this._activeDate; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            var /** @type {?} */ oldActiveDate = this._activeDate;\n            var /** @type {?} */ validDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value)) || this._dateAdapter.today();\n            this._activeDate = this._dateAdapter.clampDate(validDate, this.minDate, this.maxDate);\n            if (!this._hasSameMonthAndYear(oldActiveDate, this._activeDate)) {\n                this._init();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatMonthView.prototype, \"selected\", {\n        get: /**\n         * The currently selected date.\n         * @return {?}\n         */ function () { return this._selected; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._selected = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\n            this._selectedDate = this._getDateInCurrentMonth(this._selected);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatMonthView.prototype, \"minDate\", {\n        get: /**\n         * The minimum selectable date.\n         * @return {?}\n         */ function () { return this._minDate; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._minDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatMonthView.prototype, \"maxDate\", {\n        get: /**\n         * The maximum selectable date.\n         * @return {?}\n         */ function () { return this._maxDate; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._maxDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    MatMonthView.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n        function () {\n            this._init();\n        };\n    /** Handles when a new date is selected. */\n    /**\n     * Handles when a new date is selected.\n     * @param {?} date\n     * @return {?}\n     */\n    MatMonthView.prototype._dateSelected = /**\n     * Handles when a new date is selected.\n     * @param {?} date\n     * @return {?}\n     */\n        function (date) {\n            if (this._selectedDate != date) {\n                var /** @type {?} */ selectedYear = this._dateAdapter.getYear(this.activeDate);\n                var /** @type {?} */ selectedMonth = this._dateAdapter.getMonth(this.activeDate);\n                var /** @type {?} */ selectedDate = this._dateAdapter.createDate(selectedYear, selectedMonth, date);\n                this.selectedChange.emit(selectedDate);\n            }\n            this._userSelection.emit();\n        };\n    /** Handles keydown events on the calendar body when calendar is in month view. */\n    /**\n     * Handles keydown events on the calendar body when calendar is in month view.\n     * @param {?} event\n     * @return {?}\n     */\n    MatMonthView.prototype._handleCalendarBodyKeydown = /**\n     * Handles keydown events on the calendar body when calendar is in month view.\n     * @param {?} event\n     * @return {?}\n     */\n        function (event) {\n            // TODO(mmalerba): We currently allow keyboard navigation to disabled dates, but just prevent\n            // disabled ones from being selected. This may not be ideal, we should look into whether\n            // navigation should skip over disabled dates, and if so, how to implement that efficiently.\n            var /** @type {?} */ oldActiveDate = this._activeDate;\n            var /** @type {?} */ isRtl = this._isRtl();\n            switch (event.keyCode) {\n                case LEFT_ARROW:\n                    this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, isRtl ? 1 : -1);\n                    break;\n                case RIGHT_ARROW:\n                    this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, isRtl ? -1 : 1);\n                    break;\n                case UP_ARROW:\n                    this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, -7);\n                    break;\n                case DOWN_ARROW:\n                    this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, 7);\n                    break;\n                case HOME:\n                    this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, 1 - this._dateAdapter.getDate(this._activeDate));\n                    break;\n                case END:\n                    this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, (this._dateAdapter.getNumDaysInMonth(this._activeDate) -\n                        this._dateAdapter.getDate(this._activeDate)));\n                    break;\n                case PAGE_UP:\n                    this.activeDate = event.altKey ?\n                        this._dateAdapter.addCalendarYears(this._activeDate, -1) :\n                        this._dateAdapter.addCalendarMonths(this._activeDate, -1);\n                    break;\n                case PAGE_DOWN:\n                    this.activeDate = event.altKey ?\n                        this._dateAdapter.addCalendarYears(this._activeDate, 1) :\n                        this._dateAdapter.addCalendarMonths(this._activeDate, 1);\n                    break;\n                case ENTER:\n                    if (!this.dateFilter || this.dateFilter(this._activeDate)) {\n                        this._dateSelected(this._dateAdapter.getDate(this._activeDate));\n                        this._userSelection.emit();\n                        // Prevent unexpected default actions such as form submission.\n                        event.preventDefault();\n                    }\n                    return;\n                default:\n                    // Don't prevent default or focus active cell on keys that we don't explicitly handle.\n                    return;\n            }\n            if (this._dateAdapter.compareDate(oldActiveDate, this.activeDate)) {\n                this.activeDateChange.emit(this.activeDate);\n            }\n            this._focusActiveCell();\n            // Prevent unexpected default actions such as form submission.\n            event.preventDefault();\n        };\n    /** Initializes this month view. */\n    /**\n     * Initializes this month view.\n     * @return {?}\n     */\n    MatMonthView.prototype._init = /**\n     * Initializes this month view.\n     * @return {?}\n     */\n        function () {\n            this._selectedDate = this._getDateInCurrentMonth(this.selected);\n            this._todayDate = this._getDateInCurrentMonth(this._dateAdapter.today());\n            this._monthLabel =\n                this._dateAdapter.getMonthNames('short')[this._dateAdapter.getMonth(this.activeDate)]\n                    .toLocaleUpperCase();\n            var /** @type {?} */ firstOfMonth = this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), this._dateAdapter.getMonth(this.activeDate), 1);\n            this._firstWeekOffset =\n                (DAYS_PER_WEEK + this._dateAdapter.getDayOfWeek(firstOfMonth) -\n                    this._dateAdapter.getFirstDayOfWeek()) % DAYS_PER_WEEK;\n            this._createWeekCells();\n            this._changeDetectorRef.markForCheck();\n        };\n    /** Focuses the active cell after the microtask queue is empty. */\n    /**\n     * Focuses the active cell after the microtask queue is empty.\n     * @return {?}\n     */\n    MatMonthView.prototype._focusActiveCell = /**\n     * Focuses the active cell after the microtask queue is empty.\n     * @return {?}\n     */\n        function () {\n            this._matCalendarBody._focusActiveCell();\n        };\n    /**\n     * Creates MatCalendarCells for the dates in this month.\n     * @return {?}\n     */\n    MatMonthView.prototype._createWeekCells = /**\n     * Creates MatCalendarCells for the dates in this month.\n     * @return {?}\n     */\n        function () {\n            var /** @type {?} */ daysInMonth = this._dateAdapter.getNumDaysInMonth(this.activeDate);\n            var /** @type {?} */ dateNames = this._dateAdapter.getDateNames();\n            this._weeks = [[]];\n            for (var /** @type {?} */ i = 0, /** @type {?} */ cell = this._firstWeekOffset; i < daysInMonth; i++, cell++) {\n                if (cell == DAYS_PER_WEEK) {\n                    this._weeks.push([]);\n                    cell = 0;\n                }\n                var /** @type {?} */ date = this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), this._dateAdapter.getMonth(this.activeDate), i + 1);\n                var /** @type {?} */ enabled = this._shouldEnableDate(date);\n                var /** @type {?} */ ariaLabel = this._dateAdapter.format(date, this._dateFormats.display.dateA11yLabel);\n                this._weeks[this._weeks.length - 1]\n                    .push(new MatCalendarCell(i + 1, dateNames[i], ariaLabel, enabled));\n            }\n        };\n    /**\n     * Date filter for the month\n     * @param {?} date\n     * @return {?}\n     */\n    MatMonthView.prototype._shouldEnableDate = /**\n     * Date filter for the month\n     * @param {?} date\n     * @return {?}\n     */\n        function (date) {\n            return !!date &&\n                (!this.dateFilter || this.dateFilter(date)) &&\n                (!this.minDate || this._dateAdapter.compareDate(date, this.minDate) >= 0) &&\n                (!this.maxDate || this._dateAdapter.compareDate(date, this.maxDate) <= 0);\n        };\n    /**\n     * Gets the date in this month that the given Date falls on.\n     * Returns null if the given Date is in another month.\n     * @param {?} date\n     * @return {?}\n     */\n    MatMonthView.prototype._getDateInCurrentMonth = /**\n     * Gets the date in this month that the given Date falls on.\n     * Returns null if the given Date is in another month.\n     * @param {?} date\n     * @return {?}\n     */\n        function (date) {\n            return date && this._hasSameMonthAndYear(date, this.activeDate) ?\n                this._dateAdapter.getDate(date) : null;\n        };\n    /**\n     * Checks whether the 2 dates are non-null and fall within the same month of the same year.\n     * @param {?} d1\n     * @param {?} d2\n     * @return {?}\n     */\n    MatMonthView.prototype._hasSameMonthAndYear = /**\n     * Checks whether the 2 dates are non-null and fall within the same month of the same year.\n     * @param {?} d1\n     * @param {?} d2\n     * @return {?}\n     */\n        function (d1, d2) {\n            return !!(d1 && d2 && this._dateAdapter.getMonth(d1) == this._dateAdapter.getMonth(d2) &&\n                this._dateAdapter.getYear(d1) == this._dateAdapter.getYear(d2));\n        };\n    /**\n     * @param {?} obj The object to check.\n     * @return {?} The given object if it is both a date instance and valid, otherwise null.\n     */\n    MatMonthView.prototype._getValidDateOrNull = /**\n     * @param {?} obj The object to check.\n     * @return {?} The given object if it is both a date instance and valid, otherwise null.\n     */\n        function (obj) {\n            return (this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj)) ? obj : null;\n        };\n    /**\n     * Determines whether the user has the RTL layout direction.\n     * @return {?}\n     */\n    MatMonthView.prototype._isRtl = /**\n     * Determines whether the user has the RTL layout direction.\n     * @return {?}\n     */\n        function () {\n            return this._dir && this._dir.value === 'rtl';\n        };\n    return MatMonthView;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar /** @type {?} */ yearsPerPage = 24;\nvar /** @type {?} */ yearsPerRow = 4;\n/**\n * An internal component used to display a year selector in the datepicker.\n * \\@docs-private\n * @template D\n */\nvar MatMultiYearView = /*@__PURE__*/ (function () {\n    function MatMultiYearView(_changeDetectorRef, _dateAdapter, _dir) {\n        this._changeDetectorRef = _changeDetectorRef;\n        this._dateAdapter = _dateAdapter;\n        this._dir = _dir;\n        /**\n         * Emits when a new year is selected.\n         */\n        this.selectedChange = new EventEmitter();\n        /**\n         * Emits the selected year. This doesn't imply a change on the selected date\n         */\n        this.yearSelected = new EventEmitter();\n        if (!this._dateAdapter) {\n            throw createMissingDateImplError('DateAdapter');\n        }\n        this._activeDate = this._dateAdapter.today();\n    }\n    Object.defineProperty(MatMultiYearView.prototype, \"activeDate\", {\n        get: /**\n         * The date to display in this multi-year view (everything other than the year is ignored).\n         * @return {?}\n         */ function () { return this._activeDate; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            var /** @type {?} */ oldActiveDate = this._activeDate;\n            var /** @type {?} */ validDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value)) || this._dateAdapter.today();\n            this._activeDate = this._dateAdapter.clampDate(validDate, this.minDate, this.maxDate);\n            if (Math.floor(this._dateAdapter.getYear(oldActiveDate) / yearsPerPage) !=\n                Math.floor(this._dateAdapter.getYear(this._activeDate) / yearsPerPage)) {\n                this._init();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatMultiYearView.prototype, \"selected\", {\n        get: /**\n         * The currently selected date.\n         * @return {?}\n         */ function () { return this._selected; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._selected = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\n            this._selectedYear = this._selected && this._dateAdapter.getYear(this._selected);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatMultiYearView.prototype, \"minDate\", {\n        get: /**\n         * The minimum selectable date.\n         * @return {?}\n         */ function () { return this._minDate; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._minDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatMultiYearView.prototype, \"maxDate\", {\n        get: /**\n         * The maximum selectable date.\n         * @return {?}\n         */ function () { return this._maxDate; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._maxDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    MatMultiYearView.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n        function () {\n            this._init();\n        };\n    /** Initializes this multi-year view. */\n    /**\n     * Initializes this multi-year view.\n     * @return {?}\n     */\n    MatMultiYearView.prototype._init = /**\n     * Initializes this multi-year view.\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            this._todayYear = this._dateAdapter.getYear(this._dateAdapter.today());\n            var /** @type {?} */ activeYear = this._dateAdapter.getYear(this._activeDate);\n            var /** @type {?} */ activeOffset = activeYear % yearsPerPage;\n            this._years = [];\n            for (var /** @type {?} */ i = 0, /** @type {?} */ row = []; i < yearsPerPage; i++) {\n                row.push(activeYear - activeOffset + i);\n                if (row.length == yearsPerRow) {\n                    this._years.push(row.map(function (year) { return _this._createCellForYear(year); }));\n                    row = [];\n                }\n            }\n            this._changeDetectorRef.markForCheck();\n        };\n    /** Handles when a new year is selected. */\n    /**\n     * Handles when a new year is selected.\n     * @param {?} year\n     * @return {?}\n     */\n    MatMultiYearView.prototype._yearSelected = /**\n     * Handles when a new year is selected.\n     * @param {?} year\n     * @return {?}\n     */\n        function (year) {\n            this.yearSelected.emit(this._dateAdapter.createDate(year, 0, 1));\n            var /** @type {?} */ month = this._dateAdapter.getMonth(this.activeDate);\n            var /** @type {?} */ daysInMonth = this._dateAdapter.getNumDaysInMonth(this._dateAdapter.createDate(year, month, 1));\n            this.selectedChange.emit(this._dateAdapter.createDate(year, month, Math.min(this._dateAdapter.getDate(this.activeDate), daysInMonth)));\n        };\n    /** Handles keydown events on the calendar body when calendar is in multi-year view. */\n    /**\n     * Handles keydown events on the calendar body when calendar is in multi-year view.\n     * @param {?} event\n     * @return {?}\n     */\n    MatMultiYearView.prototype._handleCalendarBodyKeydown = /**\n     * Handles keydown events on the calendar body when calendar is in multi-year view.\n     * @param {?} event\n     * @return {?}\n     */\n        function (event) {\n            // TODO(mmalerba): We currently allow keyboard navigation to disabled dates, but just prevent\n            // disabled ones from being selected. This may not be ideal, we should look into whether\n            // navigation should skip over disabled dates, and if so, how to implement that efficiently.\n            var /** @type {?} */ isRtl = this._isRtl();\n            switch (event.keyCode) {\n                case LEFT_ARROW:\n                    this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, isRtl ? 1 : -1);\n                    break;\n                case RIGHT_ARROW:\n                    this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, isRtl ? -1 : 1);\n                    break;\n                case UP_ARROW:\n                    this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, -yearsPerRow);\n                    break;\n                case DOWN_ARROW:\n                    this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, yearsPerRow);\n                    break;\n                case HOME:\n                    this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, -this._dateAdapter.getYear(this._activeDate) % yearsPerPage);\n                    break;\n                case END:\n                    this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, yearsPerPage - this._dateAdapter.getYear(this._activeDate) % yearsPerPage - 1);\n                    break;\n                case PAGE_UP:\n                    this.activeDate =\n                        this._dateAdapter.addCalendarYears(this._activeDate, event.altKey ? -yearsPerPage * 10 : -yearsPerPage);\n                    break;\n                case PAGE_DOWN:\n                    this.activeDate =\n                        this._dateAdapter.addCalendarYears(this._activeDate, event.altKey ? yearsPerPage * 10 : yearsPerPage);\n                    break;\n                case ENTER:\n                    this._yearSelected(this._dateAdapter.getYear(this._activeDate));\n                    break;\n                default:\n                    // Don't prevent default or focus active cell on keys that we don't explicitly handle.\n                    return;\n            }\n            this._focusActiveCell();\n            // Prevent unexpected default actions such as form submission.\n            event.preventDefault();\n        };\n    /**\n     * @return {?}\n     */\n    MatMultiYearView.prototype._getActiveCell = /**\n     * @return {?}\n     */\n        function () {\n            return this._dateAdapter.getYear(this.activeDate) % yearsPerPage;\n        };\n    /** Focuses the active cell after the microtask queue is empty. */\n    /**\n     * Focuses the active cell after the microtask queue is empty.\n     * @return {?}\n     */\n    MatMultiYearView.prototype._focusActiveCell = /**\n     * Focuses the active cell after the microtask queue is empty.\n     * @return {?}\n     */\n        function () {\n            this._matCalendarBody._focusActiveCell();\n        };\n    /**\n     * Creates an MatCalendarCell for the given year.\n     * @param {?} year\n     * @return {?}\n     */\n    MatMultiYearView.prototype._createCellForYear = /**\n     * Creates an MatCalendarCell for the given year.\n     * @param {?} year\n     * @return {?}\n     */\n        function (year) {\n            var /** @type {?} */ yearName = this._dateAdapter.getYearName(this._dateAdapter.createDate(year, 0, 1));\n            return new MatCalendarCell(year, yearName, yearName, this._shouldEnableYear(year));\n        };\n    /**\n     * Whether the given year is enabled.\n     * @param {?} year\n     * @return {?}\n     */\n    MatMultiYearView.prototype._shouldEnableYear = /**\n     * Whether the given year is enabled.\n     * @param {?} year\n     * @return {?}\n     */\n        function (year) {\n            // disable if the year is greater than maxDate lower than minDate\n            if (year === undefined || year === null ||\n                (this.maxDate && year > this._dateAdapter.getYear(this.maxDate)) ||\n                (this.minDate && year < this._dateAdapter.getYear(this.minDate))) {\n                return false;\n            }\n            // enable if it reaches here and there's no filter defined\n            if (!this.dateFilter) {\n                return true;\n            }\n            var /** @type {?} */ firstOfYear = this._dateAdapter.createDate(year, 0, 1);\n            // If any date in the year is enabled count the year as enabled.\n            for (var /** @type {?} */ date = firstOfYear; this._dateAdapter.getYear(date) == year; date = this._dateAdapter.addCalendarDays(date, 1)) {\n                if (this.dateFilter(date)) {\n                    return true;\n                }\n            }\n            return false;\n        };\n    /**\n     * @param {?} obj The object to check.\n     * @return {?} The given object if it is both a date instance and valid, otherwise null.\n     */\n    MatMultiYearView.prototype._getValidDateOrNull = /**\n     * @param {?} obj The object to check.\n     * @return {?} The given object if it is both a date instance and valid, otherwise null.\n     */\n        function (obj) {\n            return (this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj)) ? obj : null;\n        };\n    /**\n     * Determines whether the user has the RTL layout direction.\n     * @return {?}\n     */\n    MatMultiYearView.prototype._isRtl = /**\n     * Determines whether the user has the RTL layout direction.\n     * @return {?}\n     */\n        function () {\n            return this._dir && this._dir.value === 'rtl';\n        };\n    return MatMultiYearView;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * An internal component used to display a single year in the datepicker.\n * \\@docs-private\n * @template D\n */\nvar MatYearView = /*@__PURE__*/ (function () {\n    function MatYearView(_changeDetectorRef, _dateFormats, _dateAdapter, _dir) {\n        this._changeDetectorRef = _changeDetectorRef;\n        this._dateFormats = _dateFormats;\n        this._dateAdapter = _dateAdapter;\n        this._dir = _dir;\n        /**\n         * Emits when a new month is selected.\n         */\n        this.selectedChange = new EventEmitter();\n        /**\n         * Emits the selected month. This doesn't imply a change on the selected date\n         */\n        this.monthSelected = new EventEmitter();\n        if (!this._dateAdapter) {\n            throw createMissingDateImplError('DateAdapter');\n        }\n        if (!this._dateFormats) {\n            throw createMissingDateImplError('MAT_DATE_FORMATS');\n        }\n        this._activeDate = this._dateAdapter.today();\n    }\n    Object.defineProperty(MatYearView.prototype, \"activeDate\", {\n        get: /**\n         * The date to display in this year view (everything other than the year is ignored).\n         * @return {?}\n         */ function () { return this._activeDate; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            var /** @type {?} */ oldActiveDate = this._activeDate;\n            var /** @type {?} */ validDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value)) || this._dateAdapter.today();\n            this._activeDate = this._dateAdapter.clampDate(validDate, this.minDate, this.maxDate);\n            if (this._dateAdapter.getYear(oldActiveDate) !== this._dateAdapter.getYear(this._activeDate)) {\n                this._init();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatYearView.prototype, \"selected\", {\n        get: /**\n         * The currently selected date.\n         * @return {?}\n         */ function () { return this._selected; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._selected = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\n            this._selectedMonth = this._getMonthInCurrentYear(this._selected);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatYearView.prototype, \"minDate\", {\n        get: /**\n         * The minimum selectable date.\n         * @return {?}\n         */ function () { return this._minDate; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._minDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatYearView.prototype, \"maxDate\", {\n        get: /**\n         * The maximum selectable date.\n         * @return {?}\n         */ function () { return this._maxDate; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._maxDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    MatYearView.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n        function () {\n            this._init();\n        };\n    /** Handles when a new month is selected. */\n    /**\n     * Handles when a new month is selected.\n     * @param {?} month\n     * @return {?}\n     */\n    MatYearView.prototype._monthSelected = /**\n     * Handles when a new month is selected.\n     * @param {?} month\n     * @return {?}\n     */\n        function (month) {\n            var /** @type {?} */ normalizedDate = this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), month, 1);\n            this.monthSelected.emit(normalizedDate);\n            var /** @type {?} */ daysInMonth = this._dateAdapter.getNumDaysInMonth(normalizedDate);\n            this.selectedChange.emit(this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), month, Math.min(this._dateAdapter.getDate(this.activeDate), daysInMonth)));\n        };\n    /** Handles keydown events on the calendar body when calendar is in year view. */\n    /**\n     * Handles keydown events on the calendar body when calendar is in year view.\n     * @param {?} event\n     * @return {?}\n     */\n    MatYearView.prototype._handleCalendarBodyKeydown = /**\n     * Handles keydown events on the calendar body when calendar is in year view.\n     * @param {?} event\n     * @return {?}\n     */\n        function (event) {\n            // TODO(mmalerba): We currently allow keyboard navigation to disabled dates, but just prevent\n            // disabled ones from being selected. This may not be ideal, we should look into whether\n            // navigation should skip over disabled dates, and if so, how to implement that efficiently.\n            var /** @type {?} */ isRtl = this._isRtl();\n            switch (event.keyCode) {\n                case LEFT_ARROW:\n                    this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, isRtl ? 1 : -1);\n                    break;\n                case RIGHT_ARROW:\n                    this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, isRtl ? -1 : 1);\n                    break;\n                case UP_ARROW:\n                    this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, -4);\n                    break;\n                case DOWN_ARROW:\n                    this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, 4);\n                    break;\n                case HOME:\n                    this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, -this._dateAdapter.getMonth(this._activeDate));\n                    break;\n                case END:\n                    this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, 11 - this._dateAdapter.getMonth(this._activeDate));\n                    break;\n                case PAGE_UP:\n                    this.activeDate =\n                        this._dateAdapter.addCalendarYears(this._activeDate, event.altKey ? -10 : -1);\n                    break;\n                case PAGE_DOWN:\n                    this.activeDate =\n                        this._dateAdapter.addCalendarYears(this._activeDate, event.altKey ? 10 : 1);\n                    break;\n                case ENTER:\n                    this._monthSelected(this._dateAdapter.getMonth(this._activeDate));\n                    break;\n                default:\n                    // Don't prevent default or focus active cell on keys that we don't explicitly handle.\n                    return;\n            }\n            this._focusActiveCell();\n            // Prevent unexpected default actions such as form submission.\n            event.preventDefault();\n        };\n    /** Initializes this year view. */\n    /**\n     * Initializes this year view.\n     * @return {?}\n     */\n    MatYearView.prototype._init = /**\n     * Initializes this year view.\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            this._selectedMonth = this._getMonthInCurrentYear(this.selected);\n            this._todayMonth = this._getMonthInCurrentYear(this._dateAdapter.today());\n            this._yearLabel = this._dateAdapter.getYearName(this.activeDate);\n            var /** @type {?} */ monthNames = this._dateAdapter.getMonthNames('short');\n            // First row of months only contains 5 elements so we can fit the year label on the same row.\n            this._months = [[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]].map(function (row) {\n                return row.map(function (month) { return _this._createCellForMonth(month, monthNames[month]); });\n            });\n            this._changeDetectorRef.markForCheck();\n        };\n    /** Focuses the active cell after the microtask queue is empty. */\n    /**\n     * Focuses the active cell after the microtask queue is empty.\n     * @return {?}\n     */\n    MatYearView.prototype._focusActiveCell = /**\n     * Focuses the active cell after the microtask queue is empty.\n     * @return {?}\n     */\n        function () {\n            this._matCalendarBody._focusActiveCell();\n        };\n    /**\n     * Gets the month in this year that the given Date falls on.\n     * Returns null if the given Date is in another year.\n     * @param {?} date\n     * @return {?}\n     */\n    MatYearView.prototype._getMonthInCurrentYear = /**\n     * Gets the month in this year that the given Date falls on.\n     * Returns null if the given Date is in another year.\n     * @param {?} date\n     * @return {?}\n     */\n        function (date) {\n            return date && this._dateAdapter.getYear(date) == this._dateAdapter.getYear(this.activeDate) ?\n                this._dateAdapter.getMonth(date) : null;\n        };\n    /**\n     * Creates an MatCalendarCell for the given month.\n     * @param {?} month\n     * @param {?} monthName\n     * @return {?}\n     */\n    MatYearView.prototype._createCellForMonth = /**\n     * Creates an MatCalendarCell for the given month.\n     * @param {?} month\n     * @param {?} monthName\n     * @return {?}\n     */\n        function (month, monthName) {\n            var /** @type {?} */ ariaLabel = this._dateAdapter.format(this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), month, 1), this._dateFormats.display.monthYearA11yLabel);\n            return new MatCalendarCell(month, monthName.toLocaleUpperCase(), ariaLabel, this._shouldEnableMonth(month));\n        };\n    /**\n     * Whether the given month is enabled.\n     * @param {?} month\n     * @return {?}\n     */\n    MatYearView.prototype._shouldEnableMonth = /**\n     * Whether the given month is enabled.\n     * @param {?} month\n     * @return {?}\n     */\n        function (month) {\n            var /** @type {?} */ activeYear = this._dateAdapter.getYear(this.activeDate);\n            if (month === undefined || month === null ||\n                this._isYearAndMonthAfterMaxDate(activeYear, month) ||\n                this._isYearAndMonthBeforeMinDate(activeYear, month)) {\n                return false;\n            }\n            if (!this.dateFilter) {\n                return true;\n            }\n            var /** @type {?} */ firstOfMonth = this._dateAdapter.createDate(activeYear, month, 1);\n            // If any date in the month is enabled count the month as enabled.\n            for (var /** @type {?} */ date = firstOfMonth; this._dateAdapter.getMonth(date) == month; date = this._dateAdapter.addCalendarDays(date, 1)) {\n                if (this.dateFilter(date)) {\n                    return true;\n                }\n            }\n            return false;\n        };\n    /**\n     * Tests whether the combination month/year is after this.maxDate, considering\n     * just the month and year of this.maxDate\n     * @param {?} year\n     * @param {?} month\n     * @return {?}\n     */\n    MatYearView.prototype._isYearAndMonthAfterMaxDate = /**\n     * Tests whether the combination month/year is after this.maxDate, considering\n     * just the month and year of this.maxDate\n     * @param {?} year\n     * @param {?} month\n     * @return {?}\n     */\n        function (year, month) {\n            if (this.maxDate) {\n                var /** @type {?} */ maxYear = this._dateAdapter.getYear(this.maxDate);\n                var /** @type {?} */ maxMonth = this._dateAdapter.getMonth(this.maxDate);\n                return year > maxYear || (year === maxYear && month > maxMonth);\n            }\n            return false;\n        };\n    /**\n     * Tests whether the combination month/year is before this.minDate, considering\n     * just the month and year of this.minDate\n     * @param {?} year\n     * @param {?} month\n     * @return {?}\n     */\n    MatYearView.prototype._isYearAndMonthBeforeMinDate = /**\n     * Tests whether the combination month/year is before this.minDate, considering\n     * just the month and year of this.minDate\n     * @param {?} year\n     * @param {?} month\n     * @return {?}\n     */\n        function (year, month) {\n            if (this.minDate) {\n                var /** @type {?} */ minYear = this._dateAdapter.getYear(this.minDate);\n                var /** @type {?} */ minMonth = this._dateAdapter.getMonth(this.minDate);\n                return year < minYear || (year === minYear && month < minMonth);\n            }\n            return false;\n        };\n    /**\n     * @param {?} obj The object to check.\n     * @return {?} The given object if it is both a date instance and valid, otherwise null.\n     */\n    MatYearView.prototype._getValidDateOrNull = /**\n     * @param {?} obj The object to check.\n     * @return {?} The given object if it is both a date instance and valid, otherwise null.\n     */\n        function (obj) {\n            return (this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj)) ? obj : null;\n        };\n    /**\n     * Determines whether the user has the RTL layout direction.\n     * @return {?}\n     */\n    MatYearView.prototype._isRtl = /**\n     * Determines whether the user has the RTL layout direction.\n     * @return {?}\n     */\n        function () {\n            return this._dir && this._dir.value === 'rtl';\n        };\n    return MatYearView;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Default header for MatCalendar\n * @template D\n */\nvar MatCalendarHeader = /*@__PURE__*/ (function () {\n    function MatCalendarHeader(_intl, calendar, _dateAdapter, _dateFormats, changeDetectorRef) {\n        this._intl = _intl;\n        this.calendar = calendar;\n        this._dateAdapter = _dateAdapter;\n        this._dateFormats = _dateFormats;\n        this.calendar.stateChanges.subscribe(function () { return changeDetectorRef.markForCheck(); });\n    }\n    Object.defineProperty(MatCalendarHeader.prototype, \"periodButtonText\", {\n        /** The label for the current calendar view. */\n        get: /**\n         * The label for the current calendar view.\n         * @return {?}\n         */ function () {\n            if (this.calendar.currentView == 'month') {\n                return this._dateAdapter\n                    .format(this.calendar.activeDate, this._dateFormats.display.monthYearLabel)\n                    .toLocaleUpperCase();\n            }\n            if (this.calendar.currentView == 'year') {\n                return this._dateAdapter.getYearName(this.calendar.activeDate);\n            }\n            var /** @type {?} */ activeYear = this._dateAdapter.getYear(this.calendar.activeDate);\n            var /** @type {?} */ firstYearInView = this._dateAdapter.getYearName(this._dateAdapter.createDate(activeYear - activeYear % 24, 0, 1));\n            var /** @type {?} */ lastYearInView = this._dateAdapter.getYearName(this._dateAdapter.createDate(activeYear + yearsPerPage - 1 - activeYear % 24, 0, 1));\n            return firstYearInView + \" \\u2013 \" + lastYearInView;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatCalendarHeader.prototype, \"periodButtonLabel\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return this.calendar.currentView == 'month' ?\n                this._intl.switchToMultiYearViewLabel : this._intl.switchToMonthViewLabel;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatCalendarHeader.prototype, \"prevButtonLabel\", {\n        /** The label for the the previous button. */\n        get: /**\n         * The label for the the previous button.\n         * @return {?}\n         */ function () {\n            return {\n                'month': this._intl.prevMonthLabel,\n                'year': this._intl.prevYearLabel,\n                'multi-year': this._intl.prevMultiYearLabel\n            }[this.calendar.currentView];\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatCalendarHeader.prototype, \"nextButtonLabel\", {\n        /** The label for the the next button. */\n        get: /**\n         * The label for the the next button.\n         * @return {?}\n         */ function () {\n            return {\n                'month': this._intl.nextMonthLabel,\n                'year': this._intl.nextYearLabel,\n                'multi-year': this._intl.nextMultiYearLabel\n            }[this.calendar.currentView];\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Handles user clicks on the period label. */\n    /**\n     * Handles user clicks on the period label.\n     * @return {?}\n     */\n    MatCalendarHeader.prototype.currentPeriodClicked = /**\n     * Handles user clicks on the period label.\n     * @return {?}\n     */\n        function () {\n            this.calendar.currentView = this.calendar.currentView == 'month' ? 'multi-year' : 'month';\n        };\n    /** Handles user clicks on the previous button. */\n    /**\n     * Handles user clicks on the previous button.\n     * @return {?}\n     */\n    MatCalendarHeader.prototype.previousClicked = /**\n     * Handles user clicks on the previous button.\n     * @return {?}\n     */\n        function () {\n            this.calendar.activeDate = this.calendar.currentView == 'month' ?\n                this._dateAdapter.addCalendarMonths(this.calendar.activeDate, -1) :\n                this._dateAdapter.addCalendarYears(this.calendar.activeDate, this.calendar.currentView == 'year' ? -1 : -yearsPerPage);\n        };\n    /** Handles user clicks on the next button. */\n    /**\n     * Handles user clicks on the next button.\n     * @return {?}\n     */\n    MatCalendarHeader.prototype.nextClicked = /**\n     * Handles user clicks on the next button.\n     * @return {?}\n     */\n        function () {\n            this.calendar.activeDate = this.calendar.currentView == 'month' ?\n                this._dateAdapter.addCalendarMonths(this.calendar.activeDate, 1) :\n                this._dateAdapter.addCalendarYears(this.calendar.activeDate, this.calendar.currentView == 'year' ? 1 : yearsPerPage);\n        };\n    /** Whether the previous period button is enabled. */\n    /**\n     * Whether the previous period button is enabled.\n     * @return {?}\n     */\n    MatCalendarHeader.prototype.previousEnabled = /**\n     * Whether the previous period button is enabled.\n     * @return {?}\n     */\n        function () {\n            if (!this.calendar.minDate) {\n                return true;\n            }\n            return !this.calendar.minDate ||\n                !this._isSameView(this.calendar.activeDate, this.calendar.minDate);\n        };\n    /** Whether the next period button is enabled. */\n    /**\n     * Whether the next period button is enabled.\n     * @return {?}\n     */\n    MatCalendarHeader.prototype.nextEnabled = /**\n     * Whether the next period button is enabled.\n     * @return {?}\n     */\n        function () {\n            return !this.calendar.maxDate ||\n                !this._isSameView(this.calendar.activeDate, this.calendar.maxDate);\n        };\n    /**\n     * Whether the two dates represent the same view in the current view mode (month or year).\n     * @param {?} date1\n     * @param {?} date2\n     * @return {?}\n     */\n    MatCalendarHeader.prototype._isSameView = /**\n     * Whether the two dates represent the same view in the current view mode (month or year).\n     * @param {?} date1\n     * @param {?} date2\n     * @return {?}\n     */\n        function (date1, date2) {\n            if (this.calendar.currentView == 'month') {\n                return this._dateAdapter.getYear(date1) == this._dateAdapter.getYear(date2) &&\n                    this._dateAdapter.getMonth(date1) == this._dateAdapter.getMonth(date2);\n            }\n            if (this.calendar.currentView == 'year') {\n                return this._dateAdapter.getYear(date1) == this._dateAdapter.getYear(date2);\n            }\n            // Otherwise we are in 'multi-year' view.\n            return Math.floor(this._dateAdapter.getYear(date1) / yearsPerPage) ==\n                Math.floor(this._dateAdapter.getYear(date2) / yearsPerPage);\n        };\n    return MatCalendarHeader;\n}());\n/**\n * A calendar that is used as part of the datepicker.\n * \\@docs-private\n * @template D\n */\nvar MatCalendar = /*@__PURE__*/ (function () {\n    function MatCalendar(_intl, _dateAdapter, _dateFormats, changeDetectorRef) {\n        var _this = this;\n        this._dateAdapter = _dateAdapter;\n        this._dateFormats = _dateFormats;\n        /**\n         * Used for scheduling that focus should be moved to the active cell on the next tick.\n         * We need to schedule it, rather than do it immediately, because we have to wait\n         * for Angular to re-evaluate the view children.\n         */\n        this._moveFocusOnNextTick = false;\n        /**\n         * Whether the calendar should be started in month or year view.\n         */\n        this.startView = 'month';\n        /**\n         * Emits when the currently selected date changes.\n         */\n        this.selectedChange = new EventEmitter();\n        /**\n         * Emits the year chosen in multiyear view.\n         * This doesn't imply a change on the selected date.\n         */\n        this.yearSelected = new EventEmitter();\n        /**\n         * Emits the month chosen in year view.\n         * This doesn't imply a change on the selected date.\n         */\n        this.monthSelected = new EventEmitter();\n        /**\n         * Emits when any date is selected.\n         */\n        this._userSelection = new EventEmitter();\n        /**\n         * Emits whenever there is a state change that the header may need to respond to.\n         */\n        this.stateChanges = new Subject();\n        if (!this._dateAdapter) {\n            throw createMissingDateImplError('DateAdapter');\n        }\n        if (!this._dateFormats) {\n            throw createMissingDateImplError('MAT_DATE_FORMATS');\n        }\n        this._intlChanges = _intl.changes.subscribe(function () {\n            changeDetectorRef.markForCheck();\n            _this.stateChanges.next();\n        });\n    }\n    Object.defineProperty(MatCalendar.prototype, \"startAt\", {\n        get: /**\n         * A date representing the period (month or year) to start the calendar in.\n         * @return {?}\n         */ function () { return this._startAt; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._startAt = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatCalendar.prototype, \"selected\", {\n        get: /**\n         * The currently selected date.\n         * @return {?}\n         */ function () { return this._selected; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._selected = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatCalendar.prototype, \"minDate\", {\n        get: /**\n         * The minimum selectable date.\n         * @return {?}\n         */ function () { return this._minDate; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._minDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatCalendar.prototype, \"maxDate\", {\n        get: /**\n         * The maximum selectable date.\n         * @return {?}\n         */ function () { return this._maxDate; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._maxDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatCalendar.prototype, \"activeDate\", {\n        /**\n         * The current active date. This determines which time period is shown and which date is\n         * highlighted when using keyboard navigation.\n         */\n        get: /**\n         * The current active date. This determines which time period is shown and which date is\n         * highlighted when using keyboard navigation.\n         * @return {?}\n         */ function () { return this._clampedActiveDate; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._clampedActiveDate = this._dateAdapter.clampDate(value, this.minDate, this.maxDate);\n            this.stateChanges.next();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatCalendar.prototype, \"currentView\", {\n        /** Whether the calendar is in month view. */\n        get: /**\n         * Whether the calendar is in month view.\n         * @return {?}\n         */ function () { return this._currentView; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._currentView = value;\n            this._moveFocusOnNextTick = true;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    MatCalendar.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n        function () {\n            this._calendarHeaderPortal = new ComponentPortal(this.headerComponent || MatCalendarHeader);\n            this.activeDate = this.startAt || this._dateAdapter.today();\n            // Assign to the private property since we don't want to move focus on init.\n            this._currentView = this.startView;\n        };\n    /**\n     * @return {?}\n     */\n    MatCalendar.prototype.ngAfterViewChecked = /**\n     * @return {?}\n     */\n        function () {\n            if (this._moveFocusOnNextTick) {\n                this._moveFocusOnNextTick = false;\n                this.focusActiveCell();\n            }\n        };\n    /**\n     * @return {?}\n     */\n    MatCalendar.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            this._intlChanges.unsubscribe();\n            this.stateChanges.complete();\n        };\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    MatCalendar.prototype.ngOnChanges = /**\n     * @param {?} changes\n     * @return {?}\n     */\n        function (changes) {\n            var /** @type {?} */ change = changes[\"minDate\"] || changes[\"maxDate\"] || changes[\"dateFilter\"];\n            if (change && !change.firstChange) {\n                var /** @type {?} */ view = this._getCurrentViewComponent();\n                if (view) {\n                    view._init();\n                }\n            }\n            this.stateChanges.next();\n        };\n    /**\n     * @return {?}\n     */\n    MatCalendar.prototype.focusActiveCell = /**\n     * @return {?}\n     */\n        function () {\n            this._getCurrentViewComponent()._focusActiveCell();\n        };\n    /** Handles date selection in the month view. */\n    /**\n     * Handles date selection in the month view.\n     * @param {?} date\n     * @return {?}\n     */\n    MatCalendar.prototype._dateSelected = /**\n     * Handles date selection in the month view.\n     * @param {?} date\n     * @return {?}\n     */\n        function (date) {\n            if (!this._dateAdapter.sameDate(date, this.selected)) {\n                this.selectedChange.emit(date);\n            }\n        };\n    /** Handles year selection in the multiyear view. */\n    /**\n     * Handles year selection in the multiyear view.\n     * @param {?} normalizedYear\n     * @return {?}\n     */\n    MatCalendar.prototype._yearSelectedInMultiYearView = /**\n     * Handles year selection in the multiyear view.\n     * @param {?} normalizedYear\n     * @return {?}\n     */\n        function (normalizedYear) {\n            this.yearSelected.emit(normalizedYear);\n        };\n    /** Handles month selection in the year view. */\n    /**\n     * Handles month selection in the year view.\n     * @param {?} normalizedMonth\n     * @return {?}\n     */\n    MatCalendar.prototype._monthSelectedInYearView = /**\n     * Handles month selection in the year view.\n     * @param {?} normalizedMonth\n     * @return {?}\n     */\n        function (normalizedMonth) {\n            this.monthSelected.emit(normalizedMonth);\n        };\n    /**\n     * @return {?}\n     */\n    MatCalendar.prototype._userSelected = /**\n     * @return {?}\n     */\n        function () {\n            this._userSelection.emit();\n        };\n    /** Handles year/month selection in the multi-year/year views. */\n    /**\n     * Handles year/month selection in the multi-year/year views.\n     * @param {?} date\n     * @param {?} view\n     * @return {?}\n     */\n    MatCalendar.prototype._goToDateInView = /**\n     * Handles year/month selection in the multi-year/year views.\n     * @param {?} date\n     * @param {?} view\n     * @return {?}\n     */\n        function (date, view) {\n            this.activeDate = date;\n            this.currentView = view;\n        };\n    /**\n     * @param {?} obj The object to check.\n     * @return {?} The given object if it is both a date instance and valid, otherwise null.\n     */\n    MatCalendar.prototype._getValidDateOrNull = /**\n     * @param {?} obj The object to check.\n     * @return {?} The given object if it is both a date instance and valid, otherwise null.\n     */\n        function (obj) {\n            return (this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj)) ? obj : null;\n        };\n    /**\n     * Returns the component instance that corresponds to the current calendar view.\n     * @return {?}\n     */\n    MatCalendar.prototype._getCurrentViewComponent = /**\n     * Returns the component instance that corresponds to the current calendar view.\n     * @return {?}\n     */\n        function () {\n            return this.monthView || this.yearView || this.multiYearView;\n        };\n    return MatCalendar;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Animations used by the Material datepicker.\n */\nvar /** @type {?} */ matDatepickerAnimations = {\n    /** Transforms the height of the datepicker's calendar. */\n    transformPanel: /*@__PURE__*/ trigger('transformPanel', [\n        /*@__PURE__*/ state('void', /*@__PURE__*/ style({ opacity: 0, transform: 'scale(1, 0)' })),\n        /*@__PURE__*/ state('enter', /*@__PURE__*/ style({ opacity: 1, transform: 'scale(1, 1)' })),\n        /*@__PURE__*/ transition('void => enter', /*@__PURE__*/ group([\n            /*@__PURE__*/ query('@fadeInCalendar', /*@__PURE__*/ animateChild()),\n            /*@__PURE__*/ animate('400ms cubic-bezier(0.25, 0.8, 0.25, 1)')\n        ])),\n        /*@__PURE__*/ transition('* => void', /*@__PURE__*/ animate('100ms linear', /*@__PURE__*/ style({ opacity: 0 })))\n    ]),\n    /** Fades in the content of the calendar. */\n    fadeInCalendar: /*@__PURE__*/ trigger('fadeInCalendar', [\n        /*@__PURE__*/ state('void', /*@__PURE__*/ style({ opacity: 0 })),\n        /*@__PURE__*/ state('enter', /*@__PURE__*/ style({ opacity: 1 })),\n        /*@__PURE__*/ transition('void => *', /*@__PURE__*/ animate('400ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)'))\n    ])\n};\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Used to generate a unique ID for each datepicker instance.\n */\nvar /** @type {?} */ datepickerUid = 0;\n/**\n * Injection token that determines the scroll handling while the calendar is open.\n */\nvar /** @type {?} */ MAT_DATEPICKER_SCROLL_STRATEGY = /*@__PURE__*/ new InjectionToken('mat-datepicker-scroll-strategy');\n/**\n * \\@docs-private\n * @param {?} overlay\n * @return {?}\n */\nfunction MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY(overlay) {\n    return function () { return overlay.scrollStrategies.reposition(); };\n}\n/**\n * \\@docs-private\n */\nvar /** @type {?} */ MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY_PROVIDER = {\n    provide: MAT_DATEPICKER_SCROLL_STRATEGY,\n    deps: [Overlay],\n    useFactory: MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY,\n};\n/**\n * \\@docs-private\n */\nvar /**\n * \\@docs-private\n */ MatDatepickerContentBase = /*@__PURE__*/ (function () {\n    function MatDatepickerContentBase(_elementRef) {\n        this._elementRef = _elementRef;\n    }\n    return MatDatepickerContentBase;\n}());\nvar /** @type {?} */ _MatDatepickerContentMixinBase = /*@__PURE__*/ mixinColor(MatDatepickerContentBase);\n/**\n * Component used as the content for the datepicker dialog and popup. We use this instead of using\n * MatCalendar directly as the content so we can control the initial focus. This also gives us a\n * place to put additional features of the popup that are not part of the calendar itself in the\n * future. (e.g. confirmation buttons).\n * \\@docs-private\n * @template D\n */\nvar MatDatepickerContent = /*@__PURE__*/ (function (_super) {\n    __extends(MatDatepickerContent, _super);\n    function MatDatepickerContent(elementRef) {\n        return _super.call(this, elementRef) || this;\n    }\n    /**\n     * @return {?}\n     */\n    MatDatepickerContent.prototype.ngAfterViewInit = /**\n     * @return {?}\n     */\n        function () {\n            this._calendar.focusActiveCell();\n        };\n    return MatDatepickerContent;\n}(_MatDatepickerContentMixinBase));\n/**\n * Component responsible for managing the datepicker popup/dialog.\n * @template D\n */\nvar MatDatepicker = /*@__PURE__*/ (function () {\n    function MatDatepicker(_dialog, _overlay, _ngZone, _viewContainerRef, _scrollStrategy, _dateAdapter, _dir, _document) {\n        this._dialog = _dialog;\n        this._overlay = _overlay;\n        this._ngZone = _ngZone;\n        this._viewContainerRef = _viewContainerRef;\n        this._scrollStrategy = _scrollStrategy;\n        this._dateAdapter = _dateAdapter;\n        this._dir = _dir;\n        this._document = _document;\n        /**\n         * The view that the calendar should start in.\n         */\n        this.startView = 'month';\n        this._touchUi = false;\n        /**\n         * Emits selected year in multiyear view.\n         * This doesn't imply a change on the selected date.\n         */\n        this.yearSelected = new EventEmitter();\n        /**\n         * Emits selected month in year view.\n         * This doesn't imply a change on the selected date.\n         */\n        this.monthSelected = new EventEmitter();\n        /**\n         * Emits when the datepicker has been opened.\n         */\n        this.openedStream = new EventEmitter();\n        /**\n         * Emits when the datepicker has been closed.\n         */\n        this.closedStream = new EventEmitter();\n        this._opened = false;\n        /**\n         * The id for the datepicker calendar.\n         */\n        this.id = \"mat-datepicker-\" + datepickerUid++;\n        this._validSelected = null;\n        /**\n         * The element that was focused before the datepicker was opened.\n         */\n        this._focusedElementBeforeOpen = null;\n        /**\n         * Subscription to value changes in the associated input element.\n         */\n        this._inputSubscription = Subscription.EMPTY;\n        /**\n         * Emits when the datepicker is disabled.\n         */\n        this._disabledChange = new Subject();\n        /**\n         * Emits new selected date when selected date changes.\n         */\n        this._selectedChanged = new Subject();\n        if (!this._dateAdapter) {\n            throw createMissingDateImplError('DateAdapter');\n        }\n    }\n    Object.defineProperty(MatDatepicker.prototype, \"startAt\", {\n        get: /**\n         * The date to open the calendar to initially.\n         * @return {?}\n         */ function () {\n            // If an explicit startAt is set we start there, otherwise we start at whatever the currently\n            // selected value is.\n            return this._startAt || (this._datepickerInput ? this._datepickerInput.value : null);\n        },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._startAt = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatDatepicker.prototype, \"color\", {\n        get: /**\n         * Color palette to use on the datepicker's calendar.\n         * @return {?}\n         */ function () {\n            return this._color ||\n                (this._datepickerInput ? this._datepickerInput._getThemePalette() : undefined);\n        },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._color = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatDatepicker.prototype, \"touchUi\", {\n        get: /**\n         * Whether the calendar UI is in touch mode. In touch mode the calendar opens in a dialog rather\n         * than a popup and elements have more padding to allow for bigger touch targets.\n         * @return {?}\n         */ function () { return this._touchUi; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._touchUi = coerceBooleanProperty(value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatDatepicker.prototype, \"disabled\", {\n        get: /**\n         * Whether the datepicker pop-up should be disabled.\n         * @return {?}\n         */ function () {\n            return this._disabled === undefined && this._datepickerInput ?\n                this._datepickerInput.disabled : !!this._disabled;\n        },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            var /** @type {?} */ newValue = coerceBooleanProperty(value);\n            if (newValue !== this._disabled) {\n                this._disabled = newValue;\n                this._disabledChange.next(newValue);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatDatepicker.prototype, \"opened\", {\n        get: /**\n         * Whether the calendar is open.\n         * @return {?}\n         */ function () { return this._opened; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) { value ? this.open() : this.close(); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatDatepicker.prototype, \"_selected\", {\n        /** The currently selected date. */\n        get: /**\n         * The currently selected date.\n         * @return {?}\n         */ function () { return this._validSelected; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) { this._validSelected = value; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatDatepicker.prototype, \"_minDate\", {\n        /** The minimum selectable date. */\n        get: /**\n         * The minimum selectable date.\n         * @return {?}\n         */ function () {\n            return this._datepickerInput && this._datepickerInput.min;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatDatepicker.prototype, \"_maxDate\", {\n        /** The maximum selectable date. */\n        get: /**\n         * The maximum selectable date.\n         * @return {?}\n         */ function () {\n            return this._datepickerInput && this._datepickerInput.max;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatDatepicker.prototype, \"_dateFilter\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return this._datepickerInput && this._datepickerInput._dateFilter;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    MatDatepicker.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            this.close();\n            this._inputSubscription.unsubscribe();\n            this._disabledChange.complete();\n            if (this._popupRef) {\n                this._popupRef.dispose();\n                this._popupComponentRef = null;\n            }\n        };\n    /** Selects the given date */\n    /**\n     * Selects the given date\n     * @param {?} date\n     * @return {?}\n     */\n    MatDatepicker.prototype._select = /**\n     * Selects the given date\n     * @param {?} date\n     * @return {?}\n     */\n        function (date) {\n            var /** @type {?} */ oldValue = this._selected;\n            this._selected = date;\n            if (!this._dateAdapter.sameDate(oldValue, this._selected)) {\n                this._selectedChanged.next(date);\n            }\n        };\n    /** Emits the selected year in multiyear view */\n    /**\n     * Emits the selected year in multiyear view\n     * @param {?} normalizedYear\n     * @return {?}\n     */\n    MatDatepicker.prototype._selectYear = /**\n     * Emits the selected year in multiyear view\n     * @param {?} normalizedYear\n     * @return {?}\n     */\n        function (normalizedYear) {\n            this.yearSelected.emit(normalizedYear);\n        };\n    /** Emits selected month in year view */\n    /**\n     * Emits selected month in year view\n     * @param {?} normalizedMonth\n     * @return {?}\n     */\n    MatDatepicker.prototype._selectMonth = /**\n     * Emits selected month in year view\n     * @param {?} normalizedMonth\n     * @return {?}\n     */\n        function (normalizedMonth) {\n            this.monthSelected.emit(normalizedMonth);\n        };\n    /**\n     * Register an input with this datepicker.\n     * @param input The datepicker input to register with this datepicker.\n     */\n    /**\n     * Register an input with this datepicker.\n     * @param {?} input The datepicker input to register with this datepicker.\n     * @return {?}\n     */\n    MatDatepicker.prototype._registerInput = /**\n     * Register an input with this datepicker.\n     * @param {?} input The datepicker input to register with this datepicker.\n     * @return {?}\n     */\n        function (input) {\n            var _this = this;\n            if (this._datepickerInput) {\n                throw Error('A MatDatepicker can only be associated with a single input.');\n            }\n            this._datepickerInput = input;\n            this._inputSubscription =\n                this._datepickerInput._valueChange.subscribe(function (value) { return _this._selected = value; });\n        };\n    /** Open the calendar. */\n    /**\n     * Open the calendar.\n     * @return {?}\n     */\n    MatDatepicker.prototype.open = /**\n     * Open the calendar.\n     * @return {?}\n     */\n        function () {\n            if (this._opened || this.disabled) {\n                return;\n            }\n            if (!this._datepickerInput) {\n                throw Error('Attempted to open an MatDatepicker with no associated input.');\n            }\n            if (this._document) {\n                this._focusedElementBeforeOpen = this._document.activeElement;\n            }\n            this.touchUi ? this._openAsDialog() : this._openAsPopup();\n            this._opened = true;\n            this.openedStream.emit();\n        };\n    /** Close the calendar. */\n    /**\n     * Close the calendar.\n     * @return {?}\n     */\n    MatDatepicker.prototype.close = /**\n     * Close the calendar.\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            if (!this._opened) {\n                return;\n            }\n            if (this._popupRef && this._popupRef.hasAttached()) {\n                this._popupRef.detach();\n            }\n            if (this._dialogRef) {\n                this._dialogRef.close();\n                this._dialogRef = null;\n            }\n            if (this._calendarPortal && this._calendarPortal.isAttached) {\n                this._calendarPortal.detach();\n            }\n            var /** @type {?} */ completeClose = function () {\n                // The `_opened` could've been reset already if\n                // we got two events in quick succession.\n                if (_this._opened) {\n                    _this._opened = false;\n                    _this.closedStream.emit();\n                    _this._focusedElementBeforeOpen = null;\n                }\n            };\n            if (this._focusedElementBeforeOpen &&\n                typeof this._focusedElementBeforeOpen.focus === 'function') {\n                // Because IE moves focus asynchronously, we can't count on it being restored before we've\n                // marked the datepicker as closed. If the event fires out of sequence and the element that\n                // we're refocusing opens the datepicker on focus, the user could be stuck with not being\n                // able to close the calendar at all. We work around it by making the logic, that marks\n                // the datepicker as closed, async as well.\n                this._focusedElementBeforeOpen.focus();\n                setTimeout(completeClose);\n            }\n            else {\n                completeClose();\n            }\n        };\n    /**\n     * Open the calendar as a dialog.\n     * @return {?}\n     */\n    MatDatepicker.prototype._openAsDialog = /**\n     * Open the calendar as a dialog.\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            this._dialogRef = this._dialog.open(MatDatepickerContent, {\n                direction: this._getDirection(),\n                viewContainerRef: this._viewContainerRef,\n                panelClass: 'mat-datepicker-dialog',\n            });\n            this._dialogRef.afterClosed().subscribe(function () { return _this.close(); });\n            this._dialogRef.componentInstance.datepicker = this;\n            this._setColor();\n        };\n    /**\n     * Open the calendar as a popup.\n     * @return {?}\n     */\n    MatDatepicker.prototype._openAsPopup = /**\n     * Open the calendar as a popup.\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            if (!this._calendarPortal) {\n                this._calendarPortal = new ComponentPortal(MatDatepickerContent, this._viewContainerRef);\n            }\n            if (!this._popupRef) {\n                this._createPopup();\n            }\n            if (!this._popupRef.hasAttached()) {\n                this._popupRef.setDirection(this._getDirection());\n                this._popupComponentRef = this._popupRef.attach(this._calendarPortal);\n                this._popupComponentRef.instance.datepicker = this;\n                this._setColor();\n                // Update the position once the calendar has rendered.\n                this._ngZone.onStable.asObservable().pipe(take(1)).subscribe(function () {\n                    _this._popupRef.updatePosition();\n                });\n            }\n        };\n    /**\n     * Create the popup.\n     * @return {?}\n     */\n    MatDatepicker.prototype._createPopup = /**\n     * Create the popup.\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            var /** @type {?} */ overlayConfig = new OverlayConfig({\n                positionStrategy: this._createPopupPositionStrategy(),\n                hasBackdrop: true,\n                backdropClass: 'mat-overlay-transparent-backdrop',\n                direction: this._getDirection(),\n                scrollStrategy: this._scrollStrategy(),\n                panelClass: 'mat-datepicker-popup',\n            });\n            this._popupRef = this._overlay.create(overlayConfig);\n            merge(this._popupRef.backdropClick(), this._popupRef.detachments(), this._popupRef.keydownEvents().pipe(filter(function (event) {\n                // Closing on alt + up is only valid when there's an input associated with the datepicker.\n                return event.keyCode === ESCAPE ||\n                    (_this._datepickerInput && event.altKey && event.keyCode === UP_ARROW);\n            }))).subscribe(function () { return _this.close(); });\n        };\n    /**\n     * Create the popup PositionStrategy.\n     * @return {?}\n     */\n    MatDatepicker.prototype._createPopupPositionStrategy = /**\n     * Create the popup PositionStrategy.\n     * @return {?}\n     */\n        function () {\n            return this._overlay.position()\n                .flexibleConnectedTo(this._datepickerInput.getPopupConnectionElementRef())\n                .withTransformOriginOn('.mat-datepicker-content')\n                .withFlexibleDimensions(false)\n                .withViewportMargin(8)\n                .withPush(false)\n                .withPositions([\n                {\n                    originX: 'start',\n                    originY: 'bottom',\n                    overlayX: 'start',\n                    overlayY: 'top'\n                },\n                {\n                    originX: 'start',\n                    originY: 'top',\n                    overlayX: 'start',\n                    overlayY: 'bottom'\n                },\n                {\n                    originX: 'end',\n                    originY: 'bottom',\n                    overlayX: 'end',\n                    overlayY: 'top'\n                },\n                {\n                    originX: 'end',\n                    originY: 'top',\n                    overlayX: 'end',\n                    overlayY: 'bottom'\n                }\n            ]);\n        };\n    /**\n     * @param {?} obj The object to check.\n     * @return {?} The given object if it is both a date instance and valid, otherwise null.\n     */\n    MatDatepicker.prototype._getValidDateOrNull = /**\n     * @param {?} obj The object to check.\n     * @return {?} The given object if it is both a date instance and valid, otherwise null.\n     */\n        function (obj) {\n            return (this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj)) ? obj : null;\n        };\n    /**\n     * Passes the current theme color along to the calendar overlay.\n     * @return {?}\n     */\n    MatDatepicker.prototype._setColor = /**\n     * Passes the current theme color along to the calendar overlay.\n     * @return {?}\n     */\n        function () {\n            var /** @type {?} */ color = this.color;\n            if (this._popupComponentRef) {\n                this._popupComponentRef.instance.color = color;\n            }\n            if (this._dialogRef) {\n                this._dialogRef.componentInstance.color = color;\n            }\n        };\n    /**\n     * Returns the layout direction of the datepicker.\n     * @return {?}\n     */\n    MatDatepicker.prototype._getDirection = /**\n     * Returns the layout direction of the datepicker.\n     * @return {?}\n     */\n        function () {\n            return this._dir ? this._dir.value : 'ltr';\n        };\n    return MatDatepicker;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar /** @type {?} */ MAT_DATEPICKER_VALUE_ACCESSOR = {\n    provide: NG_VALUE_ACCESSOR,\n    useExisting: /*@__PURE__*/ forwardRef(function () { return MatDatepickerInput; }),\n    multi: true\n};\nvar /** @type {?} */ MAT_DATEPICKER_VALIDATORS = {\n    provide: NG_VALIDATORS,\n    useExisting: /*@__PURE__*/ forwardRef(function () { return MatDatepickerInput; }),\n    multi: true\n};\n/**\n * An event used for datepicker input and change events. We don't always have access to a native\n * input or change event because the event may have been triggered by the user clicking on the\n * calendar popup. For consistency, we always use MatDatepickerInputEvent instead.\n * @template D\n */\nvar /**\n * An event used for datepicker input and change events. We don't always have access to a native\n * input or change event because the event may have been triggered by the user clicking on the\n * calendar popup. For consistency, we always use MatDatepickerInputEvent instead.\n * @template D\n */ MatDatepickerInputEvent = /*@__PURE__*/ (function () {\n    function MatDatepickerInputEvent(target, targetElement) {\n        this.target = target;\n        this.targetElement = targetElement;\n        this.value = this.target.value;\n    }\n    return MatDatepickerInputEvent;\n}());\n/**\n * Directive used to connect an input to a MatDatepicker.\n * @template D\n */\nvar MatDatepickerInput = /*@__PURE__*/ (function () {\n    function MatDatepickerInput(_elementRef, _dateAdapter, _dateFormats, _formField) {\n        var _this = this;\n        this._elementRef = _elementRef;\n        this._dateAdapter = _dateAdapter;\n        this._dateFormats = _dateFormats;\n        this._formField = _formField;\n        /**\n         * Emits when a `change` event is fired on this `<input>`.\n         */\n        this.dateChange = new EventEmitter();\n        /**\n         * Emits when an `input` event is fired on this `<input>`.\n         */\n        this.dateInput = new EventEmitter();\n        /**\n         * Emits when the value changes (either due to user input or programmatic change).\n         */\n        this._valueChange = new EventEmitter();\n        /**\n         * Emits when the disabled state has changed\n         */\n        this._disabledChange = new EventEmitter();\n        this._onTouched = function () { };\n        this._cvaOnChange = function () { };\n        this._validatorOnChange = function () { };\n        this._datepickerSubscription = Subscription.EMPTY;\n        this._localeSubscription = Subscription.EMPTY;\n        /**\n         * The form control validator for whether the input parses.\n         */\n        this._parseValidator = function () {\n            return _this._lastValueValid ?\n                null : { 'matDatepickerParse': { 'text': _this._elementRef.nativeElement.value } };\n        };\n        /**\n         * The form control validator for the min date.\n         */\n        this._minValidator = function (control) {\n            var /** @type {?} */ controlValue = _this._getValidDateOrNull(_this._dateAdapter.deserialize(control.value));\n            return (!_this.min || !controlValue ||\n                _this._dateAdapter.compareDate(_this.min, controlValue) <= 0) ?\n                null : { 'matDatepickerMin': { 'min': _this.min, 'actual': controlValue } };\n        };\n        /**\n         * The form control validator for the max date.\n         */\n        this._maxValidator = function (control) {\n            var /** @type {?} */ controlValue = _this._getValidDateOrNull(_this._dateAdapter.deserialize(control.value));\n            return (!_this.max || !controlValue ||\n                _this._dateAdapter.compareDate(_this.max, controlValue) >= 0) ?\n                null : { 'matDatepickerMax': { 'max': _this.max, 'actual': controlValue } };\n        };\n        /**\n         * The form control validator for the date filter.\n         */\n        this._filterValidator = function (control) {\n            var /** @type {?} */ controlValue = _this._getValidDateOrNull(_this._dateAdapter.deserialize(control.value));\n            return !_this._dateFilter || !controlValue || _this._dateFilter(controlValue) ?\n                null : { 'matDatepickerFilter': true };\n        };\n        /**\n         * The combined form control validator for this input.\n         */\n        this._validator = Validators.compose([this._parseValidator, this._minValidator, this._maxValidator, this._filterValidator]);\n        /**\n         * Whether the last value set on the input was valid.\n         */\n        this._lastValueValid = false;\n        if (!this._dateAdapter) {\n            throw createMissingDateImplError('DateAdapter');\n        }\n        if (!this._dateFormats) {\n            throw createMissingDateImplError('MAT_DATE_FORMATS');\n        }\n        // Update the displayed date when the locale changes.\n        this._localeSubscription = _dateAdapter.localeChanges.subscribe(function () {\n            _this.value = _this.value;\n        });\n    }\n    Object.defineProperty(MatDatepickerInput.prototype, \"matDatepicker\", {\n        set: /**\n         * The datepicker that this input is associated with.\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this.registerDatepicker(value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    MatDatepickerInput.prototype.registerDatepicker = /**\n     * @param {?} value\n     * @return {?}\n     */\n        function (value) {\n            if (value) {\n                this._datepicker = value;\n                this._datepicker._registerInput(this);\n            }\n        };\n    Object.defineProperty(MatDatepickerInput.prototype, \"matDatepickerFilter\", {\n        set: /**\n         * Function that can be used to filter out dates within the datepicker.\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._dateFilter = value;\n            this._validatorOnChange();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatDatepickerInput.prototype, \"value\", {\n        get: /**\n         * The value of the input.\n         * @return {?}\n         */ function () { return this._value; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            value = this._dateAdapter.deserialize(value);\n            this._lastValueValid = !value || this._dateAdapter.isValid(value);\n            value = this._getValidDateOrNull(value);\n            var /** @type {?} */ oldDate = this.value;\n            this._value = value;\n            this._formatValue(value);\n            if (!this._dateAdapter.sameDate(oldDate, value)) {\n                this._valueChange.emit(value);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatDatepickerInput.prototype, \"min\", {\n        get: /**\n         * The minimum valid date.\n         * @return {?}\n         */ function () { return this._min; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._min = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\n            this._validatorOnChange();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatDatepickerInput.prototype, \"max\", {\n        get: /**\n         * The maximum valid date.\n         * @return {?}\n         */ function () { return this._max; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._max = this._getValidDateOrNull(this._dateAdapter.deserialize(value));\n            this._validatorOnChange();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatDatepickerInput.prototype, \"disabled\", {\n        get: /**\n         * Whether the datepicker-input is disabled.\n         * @return {?}\n         */ function () { return !!this._disabled; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            var /** @type {?} */ newValue = coerceBooleanProperty(value);\n            var /** @type {?} */ element = this._elementRef.nativeElement;\n            if (this._disabled !== newValue) {\n                this._disabled = newValue;\n                this._disabledChange.emit(newValue);\n            }\n            // We need to null check the `blur` method, because it's undefined during SSR.\n            if (newValue && element.blur) {\n                // Normally, native input elements automatically blur if they turn disabled. This behavior\n                // is problematic, because it would mean that it triggers another change detection cycle,\n                // which then causes a changed after checked error if the input element was focused before.\n                element.blur();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    MatDatepickerInput.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            if (this._datepicker) {\n                this._datepickerSubscription = this._datepicker._selectedChanged.subscribe(function (selected) {\n                    _this.value = selected;\n                    _this._cvaOnChange(selected);\n                    _this._onTouched();\n                    _this.dateInput.emit(new MatDatepickerInputEvent(_this, _this._elementRef.nativeElement));\n                    _this.dateChange.emit(new MatDatepickerInputEvent(_this, _this._elementRef.nativeElement));\n                });\n            }\n        };\n    /**\n     * @return {?}\n     */\n    MatDatepickerInput.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            this._datepickerSubscription.unsubscribe();\n            this._localeSubscription.unsubscribe();\n            this._valueChange.complete();\n            this._disabledChange.complete();\n        };\n    /** @docs-private */\n    /**\n     * \\@docs-private\n     * @param {?} fn\n     * @return {?}\n     */\n    MatDatepickerInput.prototype.registerOnValidatorChange = /**\n     * \\@docs-private\n     * @param {?} fn\n     * @return {?}\n     */\n        function (fn) {\n            this._validatorOnChange = fn;\n        };\n    /** @docs-private */\n    /**\n     * \\@docs-private\n     * @param {?} c\n     * @return {?}\n     */\n    MatDatepickerInput.prototype.validate = /**\n     * \\@docs-private\n     * @param {?} c\n     * @return {?}\n     */\n        function (c) {\n            return this._validator ? this._validator(c) : null;\n        };\n    /**\n     * @deprecated\n     * @deletion-target 7.0.0 Use `getConnectedOverlayOrigin` instead\n     */\n    /**\n     * @deprecated\n     * \\@deletion-target 7.0.0 Use `getConnectedOverlayOrigin` instead\n     * @return {?}\n     */\n    MatDatepickerInput.prototype.getPopupConnectionElementRef = /**\n     * @deprecated\n     * \\@deletion-target 7.0.0 Use `getConnectedOverlayOrigin` instead\n     * @return {?}\n     */\n        function () {\n            return this.getConnectedOverlayOrigin();\n        };\n    /**\n     * Gets the element that the datepicker popup should be connected to.\n     * @return The element to connect the popup to.\n     */\n    /**\n     * Gets the element that the datepicker popup should be connected to.\n     * @return {?} The element to connect the popup to.\n     */\n    MatDatepickerInput.prototype.getConnectedOverlayOrigin = /**\n     * Gets the element that the datepicker popup should be connected to.\n     * @return {?} The element to connect the popup to.\n     */\n        function () {\n            return this._formField ? this._formField.getConnectedOverlayOrigin() : this._elementRef;\n        };\n    // Implemented as part of ControlValueAccessor.\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    MatDatepickerInput.prototype.writeValue = /**\n     * @param {?} value\n     * @return {?}\n     */\n        function (value) {\n            this.value = value;\n        };\n    // Implemented as part of ControlValueAccessor.\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    MatDatepickerInput.prototype.registerOnChange = /**\n     * @param {?} fn\n     * @return {?}\n     */\n        function (fn) {\n            this._cvaOnChange = fn;\n        };\n    // Implemented as part of ControlValueAccessor.\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    MatDatepickerInput.prototype.registerOnTouched = /**\n     * @param {?} fn\n     * @return {?}\n     */\n        function (fn) {\n            this._onTouched = fn;\n        };\n    // Implemented as part of ControlValueAccessor.\n    /**\n     * @param {?} isDisabled\n     * @return {?}\n     */\n    MatDatepickerInput.prototype.setDisabledState = /**\n     * @param {?} isDisabled\n     * @return {?}\n     */\n        function (isDisabled) {\n            this.disabled = isDisabled;\n        };\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    MatDatepickerInput.prototype._onKeydown = /**\n     * @param {?} event\n     * @return {?}\n     */\n        function (event) {\n            if (event.altKey && event.keyCode === DOWN_ARROW) {\n                this._datepicker.open();\n                event.preventDefault();\n            }\n        };\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    MatDatepickerInput.prototype._onInput = /**\n     * @param {?} value\n     * @return {?}\n     */\n        function (value) {\n            var /** @type {?} */ date = this._dateAdapter.parse(value, this._dateFormats.parse.dateInput);\n            this._lastValueValid = !date || this._dateAdapter.isValid(date);\n            date = this._getValidDateOrNull(date);\n            if (!this._dateAdapter.sameDate(date, this._value)) {\n                this._value = date;\n                this._cvaOnChange(date);\n                this._valueChange.emit(date);\n                this.dateInput.emit(new MatDatepickerInputEvent(this, this._elementRef.nativeElement));\n            }\n        };\n    /**\n     * @return {?}\n     */\n    MatDatepickerInput.prototype._onChange = /**\n     * @return {?}\n     */\n        function () {\n            this.dateChange.emit(new MatDatepickerInputEvent(this, this._elementRef.nativeElement));\n        };\n    /** Returns the palette used by the input's form field, if any. */\n    /**\n     * Returns the palette used by the input's form field, if any.\n     * @return {?}\n     */\n    MatDatepickerInput.prototype._getThemePalette = /**\n     * Returns the palette used by the input's form field, if any.\n     * @return {?}\n     */\n        function () {\n            return this._formField ? this._formField.color : undefined;\n        };\n    /** Handles blur events on the input. */\n    /**\n     * Handles blur events on the input.\n     * @return {?}\n     */\n    MatDatepickerInput.prototype._onBlur = /**\n     * Handles blur events on the input.\n     * @return {?}\n     */\n        function () {\n            // Reformat the input only if we have a valid value.\n            if (this.value) {\n                this._formatValue(this.value);\n            }\n            this._onTouched();\n        };\n    /**\n     * Formats a value and sets it on the input element.\n     * @param {?} value\n     * @return {?}\n     */\n    MatDatepickerInput.prototype._formatValue = /**\n     * Formats a value and sets it on the input element.\n     * @param {?} value\n     * @return {?}\n     */\n        function (value) {\n            this._elementRef.nativeElement.value =\n                value ? this._dateAdapter.format(value, this._dateFormats.display.dateInput) : '';\n        };\n    /**\n     * @param {?} obj The object to check.\n     * @return {?} The given object if it is both a date instance and valid, otherwise null.\n     */\n    MatDatepickerInput.prototype._getValidDateOrNull = /**\n     * @param {?} obj The object to check.\n     * @return {?} The given object if it is both a date instance and valid, otherwise null.\n     */\n        function (obj) {\n            return (this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj)) ? obj : null;\n        };\n    return MatDatepickerInput;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Can be used to override the icon of a `matDatepickerToggle`.\n */\nvar MatDatepickerToggleIcon = /*@__PURE__*/ (function () {\n    function MatDatepickerToggleIcon() {\n    }\n    return MatDatepickerToggleIcon;\n}());\n/**\n * @template D\n */\nvar MatDatepickerToggle = /*@__PURE__*/ (function () {\n    function MatDatepickerToggle(_intl, _changeDetectorRef) {\n        this._intl = _intl;\n        this._changeDetectorRef = _changeDetectorRef;\n        this._stateChanges = Subscription.EMPTY;\n    }\n    Object.defineProperty(MatDatepickerToggle.prototype, \"disabled\", {\n        get: /**\n         * Whether the toggle button is disabled.\n         * @return {?}\n         */ function () {\n            return this._disabled === undefined ? this.datepicker.disabled : !!this._disabled;\n        },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._disabled = coerceBooleanProperty(value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    MatDatepickerToggle.prototype.ngOnChanges = /**\n     * @param {?} changes\n     * @return {?}\n     */\n        function (changes) {\n            if (changes[\"datepicker\"]) {\n                this._watchStateChanges();\n            }\n        };\n    /**\n     * @return {?}\n     */\n    MatDatepickerToggle.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            this._stateChanges.unsubscribe();\n        };\n    /**\n     * @return {?}\n     */\n    MatDatepickerToggle.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n        function () {\n            this._watchStateChanges();\n        };\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    MatDatepickerToggle.prototype._open = /**\n     * @param {?} event\n     * @return {?}\n     */\n        function (event) {\n            if (this.datepicker && !this.disabled) {\n                this.datepicker.open();\n                event.stopPropagation();\n            }\n        };\n    /**\n     * @return {?}\n     */\n    MatDatepickerToggle.prototype._watchStateChanges = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            var /** @type {?} */ datepickerDisabled = this.datepicker ? this.datepicker._disabledChange : of();\n            var /** @type {?} */ inputDisabled = this.datepicker && this.datepicker._datepickerInput ?\n                this.datepicker._datepickerInput._disabledChange : of();\n            var /** @type {?} */ datepickerToggled = this.datepicker ?\n                merge(this.datepicker.openedStream, this.datepicker.closedStream) :\n                of();\n            this._stateChanges.unsubscribe();\n            this._stateChanges = merge(this._intl.changes, datepickerDisabled, inputDisabled, datepickerToggled).subscribe(function () { return _this._changeDetectorRef.markForCheck(); });\n        };\n    return MatDatepickerToggle;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar MatDatepickerModule = /*@__PURE__*/ (function () {\n    function MatDatepickerModule() {\n    }\n    return MatDatepickerModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nexport { MatDatepickerModule, MatCalendarHeader, MatCalendar, MatCalendarCell, MatCalendarBody, MAT_DATEPICKER_SCROLL_STRATEGY, MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY, MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY_PROVIDER, MatDatepickerContentBase, _MatDatepickerContentMixinBase, MatDatepickerContent, MatDatepicker, matDatepickerAnimations, MAT_DATEPICKER_VALUE_ACCESSOR, MAT_DATEPICKER_VALIDATORS, MatDatepickerInputEvent, MatDatepickerInput, MatDatepickerIntl, MatDatepickerToggleIcon, MatDatepickerToggle, MatMonthView, MatYearView, MatMultiYearView as a34 };\n//# sourceMappingURL=datepicker.es5.js.map\n",null]}