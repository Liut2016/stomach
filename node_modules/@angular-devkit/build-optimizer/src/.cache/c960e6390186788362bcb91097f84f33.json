{"remainingRequest":"/home/liutao/Project/0/oncology/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/home/liutao/Project/0/oncology/node_modules/@angular/material/esm5/sidenav.es5.js","dependencies":[{"path":"/home/liutao/Project/0/oncology/node_modules/@angular/material/esm5/sidenav.es5.js","mtime":1526941038000},{"path":"/home/liutao/Project/0/oncology/node_modules/cache-loader/dist/cjs.js","mtime":1539266424898},{"path":"/home/liutao/Project/0/oncology/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1526531406000}],"contextDependencies":[],"result":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** PURE_IMPORTS_START _angular_animations,_angular_cdk_a11y,_angular_cdk_bidi,_angular_cdk_coercion,_angular_cdk_keycodes,_angular_cdk_platform,_angular_cdk_scrolling,_angular_common,_angular_core,rxjs,rxjs_operators,_angular_platform_browser_animations,tslib,_angular_material_core PURE_IMPORTS_END */\nimport { animate, state, style, transition, trigger } from '@angular/animations';\nimport { FocusMonitor, FocusTrapFactory } from '@angular/cdk/a11y';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { coerceBooleanProperty, coerceNumberProperty } from '@angular/cdk/coercion';\nimport { ESCAPE } from '@angular/cdk/keycodes';\nimport { Platform, PlatformModule } from '@angular/cdk/platform';\nimport { CdkScrollable, ScrollDispatchModule } from '@angular/cdk/scrolling';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport { ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChild, ContentChildren, ElementRef, EventEmitter, forwardRef, Inject, InjectionToken, Input, NgZone, Optional, Output, ViewChild, ViewEncapsulation, NgModule } from '@angular/core';\nimport { fromEvent, merge, Subject } from 'rxjs';\nimport { debounceTime, filter, map, startWith, take, takeUntil } from 'rxjs/operators';\nimport { ANIMATION_MODULE_TYPE } from '@angular/platform-browser/animations';\nimport { __extends } from 'tslib';\nimport { MatCommonModule } from '@angular/material/core';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Animations used by the Material drawers.\n */\nvar /** @type {?} */ matDrawerAnimations = {\n    /** Animation that slides a drawer in and out. */\n    transformDrawer: /*@__PURE__*/ trigger('transform', [\n        /*@__PURE__*/ state('open, open-instant', /*@__PURE__*/ style({\n            'transform': 'translate3d(0, 0, 0)',\n            'visibility': 'visible',\n        })),\n        /*@__PURE__*/ state('void', /*@__PURE__*/ style({\n            // Avoids the shadow showing up when closed in SSR.\n            'box-shadow': 'none',\n            'visibility': 'hidden',\n        })),\n        /*@__PURE__*/ transition('void => open-instant', /*@__PURE__*/ animate('0ms')),\n        /*@__PURE__*/ transition('void <=> open, open-instant => void', /*@__PURE__*/ animate('400ms cubic-bezier(0.25, 0.8, 0.25, 1)'))\n    ])\n};\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Throws an exception when two MatDrawer are matching the same position.\n * @param {?} position\n * @return {?}\n */\nfunction throwMatDuplicatedDrawerError(position) {\n    throw Error(\"A drawer was already declared for 'position=\\\"\" + position + \"\\\"'\");\n}\n/**\n * Configures whether drawers should use auto sizing by default.\n */\nvar /** @type {?} */ MAT_DRAWER_DEFAULT_AUTOSIZE = /*@__PURE__*/ new InjectionToken('MAT_DRAWER_DEFAULT_AUTOSIZE', {\n    providedIn: 'root',\n    factory: MAT_DRAWER_DEFAULT_AUTOSIZE_FACTORY,\n});\n/**\n * \\@docs-private\n * @return {?}\n */\nfunction MAT_DRAWER_DEFAULT_AUTOSIZE_FACTORY() {\n    return false;\n}\nvar MatDrawerContent = /*@__PURE__*/ (function () {\n    function MatDrawerContent(_changeDetectorRef, _container) {\n        this._changeDetectorRef = _changeDetectorRef;\n        this._container = _container;\n    }\n    /**\n     * @return {?}\n     */\n    MatDrawerContent.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            this._container._contentMarginChanges.subscribe(function () {\n                _this._changeDetectorRef.markForCheck();\n            });\n        };\n    return MatDrawerContent;\n}());\n/**\n * This component corresponds to a drawer that can be opened on the drawer container.\n */\nvar MatDrawer = /*@__PURE__*/ (function () {\n    function MatDrawer(_elementRef, _focusTrapFactory, _focusMonitor, _platform, _ngZone, _doc) {\n        var _this = this;\n        this._elementRef = _elementRef;\n        this._focusTrapFactory = _focusTrapFactory;\n        this._focusMonitor = _focusMonitor;\n        this._platform = _platform;\n        this._ngZone = _ngZone;\n        this._doc = _doc;\n        this._elementFocusedBeforeDrawerWasOpened = null;\n        /**\n         * Whether the drawer is initialized. Used for disabling the initial animation.\n         */\n        this._enableAnimations = false;\n        this._position = 'start';\n        this._mode = 'over';\n        this._disableClose = false;\n        this._autoFocus = true;\n        /**\n         * Emits whenever the drawer has started animating.\n         */\n        this._animationStarted = new EventEmitter();\n        /**\n         * Current state of the sidenav animation.\n         */\n        this._animationState = 'void';\n        /**\n         * Event emitted when the drawer open state is changed.\n         */\n        this.openedChange =\n            // Note this has to be async in order to avoid some issues with two-bindings (see #8872).\n            new EventEmitter(/* isAsync */ /* isAsync */ true);\n        /**\n         * Event emitted when the drawer's position changes.\n         */\n        this.onPositionChanged = new EventEmitter();\n        /**\n         * An observable that emits when the drawer mode changes. This is used by the drawer container to\n         * to know when to when the mode changes so it can adapt the margins on the content.\n         */\n        this._modeChanged = new Subject();\n        this._opened = false;\n        this.openedChange.subscribe(function (opened) {\n            if (opened) {\n                if (_this._doc) {\n                    _this._elementFocusedBeforeDrawerWasOpened = /** @type {?} */ (_this._doc.activeElement);\n                }\n                if (_this._isFocusTrapEnabled && _this._focusTrap) {\n                    _this._trapFocus();\n                }\n            }\n            else {\n                _this._restoreFocus();\n            }\n        });\n        /**\n             * Listen to `keydown` events outside the zone so that change detection is not run every\n             * time a key is pressed. Instead we re-enter the zone only if the `ESC` key is pressed\n             * and we don't have close disabled.\n             */\n        this._ngZone.runOutsideAngular(function () {\n            fromEvent(_this._elementRef.nativeElement, 'keydown').pipe(filter(function (event) { return event.keyCode === ESCAPE && !_this.disableClose; })).subscribe(function (event) {\n                return _this._ngZone.run(function () {\n                    _this.close();\n                    event.stopPropagation();\n                });\n            });\n        });\n    }\n    Object.defineProperty(MatDrawer.prototype, \"position\", {\n        get: /**\n         * The side that the drawer is attached to.\n         * @return {?}\n         */ function () { return this._position; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            // Make sure we have a valid value.\n            value = value === 'end' ? 'end' : 'start';\n            if (value != this._position) {\n                this._position = value;\n                this.onPositionChanged.emit();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatDrawer.prototype, \"mode\", {\n        get: /**\n         * Mode of the drawer; one of 'over', 'push' or 'side'.\n         * @return {?}\n         */ function () { return this._mode; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._mode = value;\n            this._modeChanged.next();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatDrawer.prototype, \"disableClose\", {\n        get: /**\n         * Whether the drawer can be closed with the escape key or by clicking on the backdrop.\n         * @return {?}\n         */ function () { return this._disableClose; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) { this._disableClose = coerceBooleanProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatDrawer.prototype, \"autoFocus\", {\n        get: /**\n         * Whether the drawer should focus the first focusable element automatically when opened.\n         * @return {?}\n         */ function () { return this._autoFocus; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) { this._autoFocus = coerceBooleanProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatDrawer.prototype, \"_openedStream\", {\n        get: /**\n         * Event emitted when the drawer has been opened.\n         * @return {?}\n         */ function () {\n            return this.openedChange.pipe(filter(function (o) { return o; }), map(function () { }));\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatDrawer.prototype, \"openedStart\", {\n        get: /**\n         * Event emitted when the drawer has started opening.\n         * @return {?}\n         */ function () {\n            return this._animationStarted.pipe(filter(function (e) { return e.fromState !== e.toState && e.toState.indexOf('open') === 0; }), map(function () { }));\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatDrawer.prototype, \"_closedStream\", {\n        get: /**\n         * Event emitted when the drawer has been closed.\n         * @return {?}\n         */ function () {\n            return this.openedChange.pipe(filter(function (o) { return !o; }), map(function () { }));\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatDrawer.prototype, \"closedStart\", {\n        get: /**\n         * Event emitted when the drawer has started closing.\n         * @return {?}\n         */ function () {\n            return this._animationStarted.pipe(filter(function (e) { return e.fromState !== e.toState && e.toState === 'void'; }), map(function () { }));\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatDrawer.prototype, \"_isFocusTrapEnabled\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            // The focus trap is only enabled when the drawer is open in any mode other than side.\n            return this.opened && this.mode !== 'side';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Traps focus inside the drawer.\n     * @return {?}\n     */\n    MatDrawer.prototype._trapFocus = /**\n     * Traps focus inside the drawer.\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            if (!this.autoFocus) {\n                return;\n            }\n            this._focusTrap.focusInitialElementWhenReady().then(function (hasMovedFocus) {\n                // If there were no focusable elements, focus the sidenav itself so the keyboard navigation\n                // still works. We need to check that `focus` is a function due to Universal.\n                if (!hasMovedFocus && typeof _this._elementRef.nativeElement.focus === 'function') {\n                    _this._elementRef.nativeElement.focus();\n                }\n            });\n        };\n    /**\n     * If focus is currently inside the drawer, restores it to where it was before the drawer\n     * opened.\n     * @return {?}\n     */\n    MatDrawer.prototype._restoreFocus = /**\n     * If focus is currently inside the drawer, restores it to where it was before the drawer\n     * opened.\n     * @return {?}\n     */\n        function () {\n            if (!this.autoFocus) {\n                return;\n            }\n            var /** @type {?} */ activeEl = this._doc && this._doc.activeElement;\n            if (activeEl && this._elementRef.nativeElement.contains(activeEl)) {\n                if (this._elementFocusedBeforeDrawerWasOpened instanceof HTMLElement) {\n                    this._focusMonitor.focusVia(this._elementFocusedBeforeDrawerWasOpened, this._openedVia);\n                }\n                else {\n                    this._elementRef.nativeElement.blur();\n                }\n            }\n            this._elementFocusedBeforeDrawerWasOpened = null;\n            this._openedVia = null;\n        };\n    /**\n     * @return {?}\n     */\n    MatDrawer.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n        function () {\n            this._focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement);\n            this._focusTrap.enabled = this._isFocusTrapEnabled;\n        };\n    /**\n     * @return {?}\n     */\n    MatDrawer.prototype.ngAfterContentChecked = /**\n     * @return {?}\n     */\n        function () {\n            // Enable the animations after the lifecycle hooks have run, in order to avoid animating\n            // drawers that are open by default. When we're on the server, we shouldn't enable the\n            // animations, because we don't want the drawer to animate the first time the user sees\n            // the page.\n            if (this._platform.isBrowser) {\n                this._enableAnimations = true;\n            }\n        };\n    /**\n     * @return {?}\n     */\n    MatDrawer.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            if (this._focusTrap) {\n                this._focusTrap.destroy();\n            }\n        };\n    Object.defineProperty(MatDrawer.prototype, \"opened\", {\n        get: /**\n         * Whether the drawer is opened. We overload this because we trigger an event when it\n         * starts or end.\n         * @return {?}\n         */ function () { return this._opened; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) { this.toggle(coerceBooleanProperty(value)); },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Open the drawer.\n     * @param openedVia Whether the drawer was opened by a key press, mouse click or programmatically.\n     * Used for focus management after the sidenav is closed.\n     */\n    /**\n     * Open the drawer.\n     * @param {?=} openedVia Whether the drawer was opened by a key press, mouse click or programmatically.\n     * Used for focus management after the sidenav is closed.\n     * @return {?}\n     */\n    MatDrawer.prototype.open = /**\n     * Open the drawer.\n     * @param {?=} openedVia Whether the drawer was opened by a key press, mouse click or programmatically.\n     * Used for focus management after the sidenav is closed.\n     * @return {?}\n     */\n        function (openedVia) {\n            return this.toggle(true, openedVia);\n        };\n    /** Close the drawer. */\n    /**\n     * Close the drawer.\n     * @return {?}\n     */\n    MatDrawer.prototype.close = /**\n     * Close the drawer.\n     * @return {?}\n     */\n        function () {\n            return this.toggle(false);\n        };\n    /**\n     * Toggle this drawer.\n     * @param isOpen Whether the drawer should be open.\n     * @param openedVia Whether the drawer was opened by a key press, mouse click or programmatically.\n     * Used for focus management after the sidenav is closed.\n     */\n    /**\n     * Toggle this drawer.\n     * @param {?=} isOpen Whether the drawer should be open.\n     * @param {?=} openedVia Whether the drawer was opened by a key press, mouse click or programmatically.\n     * Used for focus management after the sidenav is closed.\n     * @return {?}\n     */\n    MatDrawer.prototype.toggle = /**\n     * Toggle this drawer.\n     * @param {?=} isOpen Whether the drawer should be open.\n     * @param {?=} openedVia Whether the drawer was opened by a key press, mouse click or programmatically.\n     * Used for focus management after the sidenav is closed.\n     * @return {?}\n     */\n        function (isOpen, openedVia) {\n            var _this = this;\n            if (isOpen === void 0) {\n                isOpen = !this.opened;\n            }\n            if (openedVia === void 0) {\n                openedVia = 'program';\n            }\n            this._opened = isOpen;\n            if (isOpen) {\n                this._animationState = this._enableAnimations ? 'open' : 'open-instant';\n                this._openedVia = openedVia;\n            }\n            else {\n                this._animationState = 'void';\n                this._restoreFocus();\n            }\n            if (this._focusTrap) {\n                this._focusTrap.enabled = this._isFocusTrapEnabled;\n            }\n            return new Promise(function (resolve) {\n                _this.openedChange.pipe(take(1)).subscribe(function (open) { return resolve(open ? 'open' : 'close'); });\n            });\n        };\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    MatDrawer.prototype._onAnimationStart = /**\n     * @param {?} event\n     * @return {?}\n     */\n        function (event) {\n            this._animationStarted.emit(event);\n        };\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    MatDrawer.prototype._onAnimationEnd = /**\n     * @param {?} event\n     * @return {?}\n     */\n        function (event) {\n            var fromState = event.fromState, toState = event.toState;\n            if ((toState.indexOf('open') === 0 && fromState === 'void') ||\n                (toState === 'void' && fromState.indexOf('open') === 0)) {\n                this.openedChange.emit(this._opened);\n            }\n        };\n    Object.defineProperty(MatDrawer.prototype, \"_width\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            return this._elementRef.nativeElement ? (this._elementRef.nativeElement.offsetWidth || 0) : 0;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return MatDrawer;\n}());\n/**\n * `<mat-drawer-container>` component.\n *\n * This is the parent component to one or two `<mat-drawer>`s that validates the state internally\n * and coordinates the backdrop and content styling.\n */\nvar MatDrawerContainer = /*@__PURE__*/ (function () {\n    function MatDrawerContainer(_dir, _element, _ngZone, _changeDetectorRef, defaultAutosize, _animationMode) {\n        if (defaultAutosize === void 0) {\n            defaultAutosize = false;\n        }\n        var _this = this;\n        this._dir = _dir;\n        this._element = _element;\n        this._ngZone = _ngZone;\n        this._changeDetectorRef = _changeDetectorRef;\n        this._animationMode = _animationMode;\n        /**\n         * Event emitted when the drawer backdrop is clicked.\n         */\n        this.backdropClick = new EventEmitter();\n        /**\n         * Emits when the component is destroyed.\n         */\n        this._destroyed = new Subject();\n        /**\n         * Emits on every ngDoCheck. Used for debouncing reflows.\n         */\n        this._doCheckSubject = new Subject();\n        /**\n         * Margins to be applied to the content. These are used to push / shrink the drawer content when a\n         * drawer is open. We use margin rather than transform even for push mode because transform breaks\n         * fixed position elements inside of the transformed element.\n         */\n        this._contentMargins = { left: null, right: null };\n        this._contentMarginChanges = new Subject();\n        // If a `Dir` directive exists up the tree, listen direction changes\n        // and update the left/right properties to point to the proper start/end.\n        if (_dir) {\n            _dir.change.pipe(takeUntil(this._destroyed)).subscribe(function () {\n                _this._validateDrawers();\n                _this._updateContentMargins();\n            });\n        }\n        this._autosize = defaultAutosize;\n    }\n    Object.defineProperty(MatDrawerContainer.prototype, \"start\", {\n        /** The drawer child with the `start` position. */\n        get: /**\n         * The drawer child with the `start` position.\n         * @return {?}\n         */ function () { return this._start; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatDrawerContainer.prototype, \"end\", {\n        /** The drawer child with the `end` position. */\n        get: /**\n         * The drawer child with the `end` position.\n         * @return {?}\n         */ function () { return this._end; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatDrawerContainer.prototype, \"autosize\", {\n        get: /**\n         * Whether to automatically resize the container whenever\n         * the size of any of its drawers changes.\n         *\n         * **Use at your own risk!** Enabling this option can cause layout thrashing by measuring\n         * the drawers on every change detection cycle. Can be configured globally via the\n         * `MAT_DRAWER_DEFAULT_AUTOSIZE` token.\n         * @return {?}\n         */ function () { return this._autosize; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) { this._autosize = coerceBooleanProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatDrawerContainer.prototype, \"hasBackdrop\", {\n        get: /**\n         * Whether the drawer container should have a backdrop while one of the sidenavs is open.\n         * If explicitly set to `true`, the backdrop will be enabled for drawers in the `side`\n         * mode as well.\n         * @return {?}\n         */ function () {\n            if (this._backdropOverride == null) {\n                return !this._start || this._start.mode !== 'side' || !this._end || this._end.mode !== 'side';\n            }\n            return this._backdropOverride;\n        },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._backdropOverride = value == null ? null : coerceBooleanProperty(value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    MatDrawerContainer.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            this._drawers.changes.pipe(startWith(null)).subscribe(function () {\n                _this._validateDrawers();\n                _this._drawers.forEach(function (drawer) {\n                    _this._watchDrawerToggle(drawer);\n                    _this._watchDrawerPosition(drawer);\n                    _this._watchDrawerMode(drawer);\n                });\n                if (!_this._drawers.length ||\n                    _this._isDrawerOpen(_this._start) ||\n                    _this._isDrawerOpen(_this._end)) {\n                    _this._updateContentMargins();\n                }\n                _this._changeDetectorRef.markForCheck();\n            });\n            this._doCheckSubject.pipe(debounceTime(10), // Arbitrary debounce time, less than a frame at 60fps\n            // Arbitrary debounce time, less than a frame at 60fps\n            takeUntil(this._destroyed)).subscribe(function () { return _this._updateContentMargins(); });\n        };\n    /**\n     * @return {?}\n     */\n    MatDrawerContainer.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            this._doCheckSubject.complete();\n            this._destroyed.next();\n            this._destroyed.complete();\n        };\n    /** Calls `open` of both start and end drawers */\n    /**\n     * Calls `open` of both start and end drawers\n     * @return {?}\n     */\n    MatDrawerContainer.prototype.open = /**\n     * Calls `open` of both start and end drawers\n     * @return {?}\n     */\n        function () {\n            this._drawers.forEach(function (drawer) { return drawer.open(); });\n        };\n    /** Calls `close` of both start and end drawers */\n    /**\n     * Calls `close` of both start and end drawers\n     * @return {?}\n     */\n    MatDrawerContainer.prototype.close = /**\n     * Calls `close` of both start and end drawers\n     * @return {?}\n     */\n        function () {\n            this._drawers.forEach(function (drawer) { return drawer.close(); });\n        };\n    /**\n     * @return {?}\n     */\n    MatDrawerContainer.prototype.ngDoCheck = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            // If users opted into autosizing, do a check every change detection cycle.\n            if (this._autosize && this._isPushed()) {\n                // Run outside the NgZone, otherwise the debouncer will throw us into an infinite loop.\n                this._ngZone.runOutsideAngular(function () { return _this._doCheckSubject.next(); });\n            }\n        };\n    /**\n     * Subscribes to drawer events in order to set a class on the main container element when the\n     * drawer is open and the backdrop is visible. This ensures any overflow on the container element\n     * is properly hidden.\n     * @param {?} drawer\n     * @return {?}\n     */\n    MatDrawerContainer.prototype._watchDrawerToggle = /**\n     * Subscribes to drawer events in order to set a class on the main container element when the\n     * drawer is open and the backdrop is visible. This ensures any overflow on the container element\n     * is properly hidden.\n     * @param {?} drawer\n     * @return {?}\n     */\n        function (drawer) {\n            var _this = this;\n            drawer._animationStarted.pipe(takeUntil(this._drawers.changes), filter(function (event) { return event.fromState !== event.toState; }))\n                .subscribe(function (event) {\n                // Set the transition class on the container so that the animations occur. This should not\n                // be set initially because animations should only be triggered via a change in state.\n                if (event.toState !== 'open-instant' && _this._animationMode !== 'NoopAnimations') {\n                    _this._element.nativeElement.classList.add('mat-drawer-transition');\n                }\n                _this._updateContentMargins();\n                _this._changeDetectorRef.markForCheck();\n            });\n            if (drawer.mode !== 'side') {\n                drawer.openedChange.pipe(takeUntil(this._drawers.changes)).subscribe(function () {\n                    return _this._setContainerClass(drawer.opened);\n                });\n            }\n        };\n    /**\n     * Subscribes to drawer onPositionChanged event in order to\n     * re-validate drawers when the position changes.\n     * @param {?} drawer\n     * @return {?}\n     */\n    MatDrawerContainer.prototype._watchDrawerPosition = /**\n     * Subscribes to drawer onPositionChanged event in order to\n     * re-validate drawers when the position changes.\n     * @param {?} drawer\n     * @return {?}\n     */\n        function (drawer) {\n            var _this = this;\n            if (!drawer) {\n                return;\n            }\n            // NOTE: We need to wait for the microtask queue to be empty before validating,\n            // since both drawers may be swapping positions at the same time.\n            drawer.onPositionChanged.pipe(takeUntil(this._drawers.changes)).subscribe(function () {\n                _this._ngZone.onMicrotaskEmpty.asObservable().pipe(take(1)).subscribe(function () {\n                    _this._validateDrawers();\n                });\n            });\n        };\n    /**\n     * Subscribes to changes in drawer mode so we can run change detection.\n     * @param {?} drawer\n     * @return {?}\n     */\n    MatDrawerContainer.prototype._watchDrawerMode = /**\n     * Subscribes to changes in drawer mode so we can run change detection.\n     * @param {?} drawer\n     * @return {?}\n     */\n        function (drawer) {\n            var _this = this;\n            if (drawer) {\n                drawer._modeChanged.pipe(takeUntil(merge(this._drawers.changes, this._destroyed)))\n                    .subscribe(function () {\n                    _this._updateContentMargins();\n                    _this._changeDetectorRef.markForCheck();\n                });\n            }\n        };\n    /**\n     * Toggles the 'mat-drawer-opened' class on the main 'mat-drawer-container' element.\n     * @param {?} isAdd\n     * @return {?}\n     */\n    MatDrawerContainer.prototype._setContainerClass = /**\n     * Toggles the 'mat-drawer-opened' class on the main 'mat-drawer-container' element.\n     * @param {?} isAdd\n     * @return {?}\n     */\n        function (isAdd) {\n            if (isAdd) {\n                this._element.nativeElement.classList.add('mat-drawer-opened');\n            }\n            else {\n                this._element.nativeElement.classList.remove('mat-drawer-opened');\n            }\n        };\n    /**\n     * Validate the state of the drawer children components.\n     * @return {?}\n     */\n    MatDrawerContainer.prototype._validateDrawers = /**\n     * Validate the state of the drawer children components.\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            this._start = this._end = null;\n            // Ensure that we have at most one start and one end drawer.\n            this._drawers.forEach(function (drawer) {\n                if (drawer.position == 'end') {\n                    if (_this._end != null) {\n                        throwMatDuplicatedDrawerError('end');\n                    }\n                    _this._end = drawer;\n                }\n                else {\n                    if (_this._start != null) {\n                        throwMatDuplicatedDrawerError('start');\n                    }\n                    _this._start = drawer;\n                }\n            });\n            this._right = this._left = null;\n            // Detect if we're LTR or RTL.\n            if (this._dir && this._dir.value === 'rtl') {\n                this._left = this._end;\n                this._right = this._start;\n            }\n            else {\n                this._left = this._start;\n                this._right = this._end;\n            }\n        };\n    /**\n     * Whether the container is being pushed to the side by one of the drawers.\n     * @return {?}\n     */\n    MatDrawerContainer.prototype._isPushed = /**\n     * Whether the container is being pushed to the side by one of the drawers.\n     * @return {?}\n     */\n        function () {\n            return (this._isDrawerOpen(this._start) && this._start.mode != 'over') ||\n                (this._isDrawerOpen(this._end) && this._end.mode != 'over');\n        };\n    /**\n     * @return {?}\n     */\n    MatDrawerContainer.prototype._onBackdropClicked = /**\n     * @return {?}\n     */\n        function () {\n            this.backdropClick.emit();\n            this._closeModalDrawer();\n        };\n    /**\n     * @return {?}\n     */\n    MatDrawerContainer.prototype._closeModalDrawer = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            // Close all open drawers where closing is not disabled and the mode is not `side`.\n            [this._start, this._end]\n                .filter(function (drawer) { return drawer && !drawer.disableClose && _this._canHaveBackdrop(drawer); })\n                .forEach(function (drawer) { return ((drawer)).close(); });\n        };\n    /**\n     * @return {?}\n     */\n    MatDrawerContainer.prototype._isShowingBackdrop = /**\n     * @return {?}\n     */\n        function () {\n            return (this._isDrawerOpen(this._start) && this._canHaveBackdrop(this._start)) ||\n                (this._isDrawerOpen(this._end) && this._canHaveBackdrop(this._end));\n        };\n    /**\n     * @param {?} drawer\n     * @return {?}\n     */\n    MatDrawerContainer.prototype._canHaveBackdrop = /**\n     * @param {?} drawer\n     * @return {?}\n     */\n        function (drawer) {\n            return drawer.mode !== 'side' || !!this._backdropOverride;\n        };\n    /**\n     * @param {?} drawer\n     * @return {?}\n     */\n    MatDrawerContainer.prototype._isDrawerOpen = /**\n     * @param {?} drawer\n     * @return {?}\n     */\n        function (drawer) {\n            return drawer != null && drawer.opened;\n        };\n    /**\n     * Recalculates and updates the inline styles for the content. Note that this should be used\n     * sparingly, because it causes a reflow.\n     * @return {?}\n     */\n    MatDrawerContainer.prototype._updateContentMargins = /**\n     * Recalculates and updates the inline styles for the content. Note that this should be used\n     * sparingly, because it causes a reflow.\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            // 1. For drawers in `over` mode, they don't affect the content.\n            // 2. For drawers in `side` mode they should shrink the content. We do this by adding to the\n            //    left margin (for left drawer) or right margin (for right the drawer).\n            // 3. For drawers in `push` mode the should shift the content without resizing it. We do this by\n            //    adding to the left or right margin and simultaneously subtracting the same amount of\n            //    margin from the other side.\n            var /** @type {?} */ left = 0;\n            var /** @type {?} */ right = 0;\n            if (this._left && this._left.opened) {\n                if (this._left.mode == 'side') {\n                    left += this._left._width;\n                }\n                else if (this._left.mode == 'push') {\n                    var /** @type {?} */ width = this._left._width;\n                    left += width;\n                    right -= width;\n                }\n            }\n            if (this._right && this._right.opened) {\n                if (this._right.mode == 'side') {\n                    right += this._right._width;\n                }\n                else if (this._right.mode == 'push') {\n                    var /** @type {?} */ width = this._right._width;\n                    right += width;\n                    left -= width;\n                }\n            }\n            if (left !== this._contentMargins.left || right !== this._contentMargins.right) {\n                this._contentMargins = { left: left, right: right };\n                // Pull back into the NgZone since in some cases we could be outside. We need to be careful\n                // to do it only when something changed, otherwise we can end up hitting the zone too often.\n                this._ngZone.run(function () { return _this._contentMarginChanges.next(_this._contentMargins); });\n            }\n        };\n    return MatDrawerContainer;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar MatSidenavContent = /*@__PURE__*/ (function (_super) {\n    __extends(MatSidenavContent, _super);\n    function MatSidenavContent(changeDetectorRef, container) {\n        return _super.call(this, changeDetectorRef, container) || this;\n    }\n    return MatSidenavContent;\n}(MatDrawerContent));\nvar MatSidenav = /*@__PURE__*/ (function (_super) {\n    __extends(MatSidenav, _super);\n    function MatSidenav() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this._fixedInViewport = false;\n        _this._fixedTopGap = 0;\n        _this._fixedBottomGap = 0;\n        return _this;\n    }\n    Object.defineProperty(MatSidenav.prototype, \"fixedInViewport\", {\n        get: /**\n         * Whether the sidenav is fixed in the viewport.\n         * @return {?}\n         */ function () { return this._fixedInViewport; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) { this._fixedInViewport = coerceBooleanProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatSidenav.prototype, \"fixedTopGap\", {\n        get: /**\n         * The gap between the top of the sidenav and the top of the viewport when the sidenav is in fixed\n         * mode.\n         * @return {?}\n         */ function () { return this._fixedTopGap; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) { this._fixedTopGap = coerceNumberProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatSidenav.prototype, \"fixedBottomGap\", {\n        get: /**\n         * The gap between the bottom of the sidenav and the bottom of the viewport when the sidenav is in\n         * fixed mode.\n         * @return {?}\n         */ function () { return this._fixedBottomGap; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) { this._fixedBottomGap = coerceNumberProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    return MatSidenav;\n}(MatDrawer));\nvar MatSidenavContainer = /*@__PURE__*/ (function (_super) {\n    __extends(MatSidenavContainer, _super);\n    function MatSidenavContainer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return MatSidenavContainer;\n}(MatDrawerContainer));\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar MatSidenavModule = /*@__PURE__*/ (function () {\n    function MatSidenavModule() {\n    }\n    return MatSidenavModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nexport { MatSidenavModule, throwMatDuplicatedDrawerError, MAT_DRAWER_DEFAULT_AUTOSIZE, MAT_DRAWER_DEFAULT_AUTOSIZE_FACTORY, MatDrawerContent, MatDrawer, MatDrawerContainer, MatSidenavContent, MatSidenav, MatSidenavContainer, matDrawerAnimations };\n//# sourceMappingURL=sidenav.es5.js.map\n",null]}