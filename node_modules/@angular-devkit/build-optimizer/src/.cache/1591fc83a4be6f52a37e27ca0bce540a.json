{"remainingRequest":"/home/liutao/Project/0/oncology/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/home/liutao/Project/0/oncology/node_modules/@angular/material/esm5/form-field.es5.js","dependencies":[{"path":"/home/liutao/Project/0/oncology/node_modules/@angular/material/esm5/form-field.es5.js","mtime":1526941038000},{"path":"/home/liutao/Project/0/oncology/node_modules/cache-loader/dist/cjs.js","mtime":1539266424898},{"path":"/home/liutao/Project/0/oncology/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1526531406000}],"contextDependencies":[],"result":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** PURE_IMPORTS_START _angular_core,_angular_animations,tslib,_angular_cdk_bidi,_angular_cdk_coercion,_angular_material_core,rxjs,rxjs_operators,_angular_cdk_platform,_angular_common PURE_IMPORTS_END */\nimport { Directive, Input, ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChild, ContentChildren, ElementRef, Inject, InjectionToken, Optional, ViewChild, ViewEncapsulation, NgModule } from '@angular/core';\nimport { animate, state, style, transition, trigger } from '@angular/animations';\nimport { __extends } from 'tslib';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { MAT_LABEL_GLOBAL_OPTIONS, mixinColor } from '@angular/material/core';\nimport { EMPTY, fromEvent, merge } from 'rxjs';\nimport { startWith, take } from 'rxjs/operators';\nimport { Platform } from '@angular/cdk/platform';\nimport { CommonModule } from '@angular/common';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar /** @type {?} */ nextUniqueId = 0;\n/**\n * Single error message to be shown underneath the form field.\n */\nvar MatError = /*@__PURE__*/ (function () {\n    function MatError() {\n        this.id = \"mat-error-\" + nextUniqueId++;\n    }\n    return MatError;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Animations used by the MatFormField.\n */\nvar /** @type {?} */ matFormFieldAnimations = {\n    /** Animation that transitions the form field's error and hint messages. */\n    transitionMessages: /*@__PURE__*/ trigger('transitionMessages', [\n        // TODO(mmalerba): Use angular animations for label animation as well.\n        /*@__PURE__*/ state('enter', /*@__PURE__*/ style({ opacity: 1, transform: 'translateY(0%)' })),\n        /*@__PURE__*/ transition('void => enter', [\n            /*@__PURE__*/ style({ opacity: 0, transform: 'translateY(-100%)' }),\n            /*@__PURE__*/ animate('300ms cubic-bezier(0.55, 0, 0.55, 0.2)'),\n        ]),\n    ])\n};\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * An interface which allows a control to work inside of a `MatFormField`.\n * @abstract\n * @template T\n */\nvar /**\n * An interface which allows a control to work inside of a `MatFormField`.\n * @abstract\n * @template T\n */ MatFormFieldControl = /*@__PURE__*/ (function () {\n    function MatFormFieldControl() {\n    }\n    return MatFormFieldControl;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * \\@docs-private\n * @return {?}\n */\nfunction getMatFormFieldPlaceholderConflictError() {\n    return Error('Placeholder attribute and child element were both specified.');\n}\n/**\n * \\@docs-private\n * @param {?} align\n * @return {?}\n */\nfunction getMatFormFieldDuplicatedHintError(align) {\n    return Error(\"A hint was already declared for 'align=\\\"\" + align + \"\\\"'.\");\n}\n/**\n * \\@docs-private\n * @return {?}\n */\nfunction getMatFormFieldMissingControlError() {\n    return Error('mat-form-field must contain a MatFormFieldControl.');\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar /** @type {?} */ nextUniqueId$1 = 0;\n/**\n * Hint text to be shown underneath the form field control.\n */\nvar MatHint = /*@__PURE__*/ (function () {\n    function MatHint() {\n        /**\n         * Whether to align the hint label at the start or end of the line.\n         */\n        this.align = 'start';\n        /**\n         * Unique ID for the hint. Used for the aria-describedby on the form field control.\n         */\n        this.id = \"mat-hint-\" + nextUniqueId$1++;\n    }\n    return MatHint;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * The floating label for a `mat-form-field`.\n */\nvar MatLabel = /*@__PURE__*/ (function () {\n    function MatLabel() {\n    }\n    return MatLabel;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * The placeholder text for an `MatFormField`.\n * @deprecated Use `<mat-label>` to specify the label and the `placeholder` attribute to specify the\n *     placeholder.\n * \\@deletion-target 8.0.0\n */\nvar MatPlaceholder = /*@__PURE__*/ (function () {\n    function MatPlaceholder() {\n    }\n    return MatPlaceholder;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Prefix to be placed the the front of the form field.\n */\nvar MatPrefix = /*@__PURE__*/ (function () {\n    function MatPrefix() {\n    }\n    return MatPrefix;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Suffix to be placed at the end of the form field.\n */\nvar MatSuffix = /*@__PURE__*/ (function () {\n    function MatSuffix() {\n    }\n    return MatSuffix;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar /** @type {?} */ nextUniqueId$2 = 0;\nvar /** @type {?} */ floatingLabelScale = 0.75;\nvar /** @type {?} */ outlineGapPadding = 5;\n/**\n * \\@docs-private\n */\nvar /**\n * \\@docs-private\n */ MatFormFieldBase = /*@__PURE__*/ (function () {\n    function MatFormFieldBase(_elementRef) {\n        this._elementRef = _elementRef;\n    }\n    return MatFormFieldBase;\n}());\nvar /** @type {?} */ _MatFormFieldMixinBase = /*@__PURE__*/ mixinColor(MatFormFieldBase, 'primary');\nvar /** @type {?} */ MAT_FORM_FIELD_DEFAULT_OPTIONS = /*@__PURE__*/ new InjectionToken('MAT_FORM_FIELD_DEFAULT_OPTIONS');\n/**\n * Container for form controls that applies Material Design styling and behavior.\n */\nvar MatFormField = /*@__PURE__*/ (function (_super) {\n    __extends(MatFormField, _super);\n    function MatFormField(_elementRef, _changeDetectorRef, labelOptions, _dir, _defaultOptions, _platform) {\n        var _this = _super.call(this, _elementRef) || this;\n        _this._elementRef = _elementRef;\n        _this._changeDetectorRef = _changeDetectorRef;\n        _this._dir = _dir;\n        _this._defaultOptions = _defaultOptions;\n        _this._platform = _platform;\n        /**\n         * Override for the logic that disables the label animation in certain cases.\n         */\n        _this._showAlwaysAnimate = false;\n        /**\n         * State of the mat-hint and mat-error animations.\n         */\n        _this._subscriptAnimationState = '';\n        _this._hintLabel = '';\n        // Unique id for the hint label.\n        _this._hintLabelId = \"mat-hint-\" + nextUniqueId$2++;\n        _this._outlineGapWidth = 0;\n        _this._outlineGapStart = 0;\n        _this._initialGapCalculated = false;\n        _this._labelOptions = labelOptions ? labelOptions : {};\n        _this.floatLabel = _this._labelOptions.float || 'auto';\n        return _this;\n    }\n    Object.defineProperty(MatFormField.prototype, \"appearance\", {\n        get: /**\n         * The form-field appearance style.\n         * @return {?}\n         */ function () {\n            return this._appearance || this._defaultOptions && this._defaultOptions.appearance || 'legacy';\n        },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._appearance = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatFormField.prototype, \"hideRequiredMarker\", {\n        get: /**\n         * Whether the required marker should be hidden.\n         * @return {?}\n         */ function () { return this._hideRequiredMarker; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._hideRequiredMarker = coerceBooleanProperty(value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatFormField.prototype, \"_shouldAlwaysFloat\", {\n        /** Whether the floating label should always float or not. */\n        get: /**\n         * Whether the floating label should always float or not.\n         * @return {?}\n         */ function () {\n            return this.floatLabel === 'always' && !this._showAlwaysAnimate;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatFormField.prototype, \"_canLabelFloat\", {\n        /** Whether the label can float or not. */\n        get: /**\n         * Whether the label can float or not.\n         * @return {?}\n         */ function () { return this.floatLabel !== 'never'; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatFormField.prototype, \"hintLabel\", {\n        get: /**\n         * Text for the form field hint.\n         * @return {?}\n         */ function () { return this._hintLabel; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._hintLabel = value;\n            this._processHints();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatFormField.prototype, \"floatLabel\", {\n        get: /**\n         * Whether the label should always float, never float or float as the user types.\n         *\n         * Note: only the legacy appearance supports the `never` option. `never` was originally added as a\n         * way to make the floating label emulate the behavior of a standard input placeholder. However\n         * the form field now supports both floating labels and placeholders. Therefore in the non-legacy\n         * appearances the `never` option has been disabled in favor of just using the placeholder.\n         * @return {?}\n         */ function () {\n            return this.appearance !== 'legacy' && this._floatLabel === 'never' ? 'auto' : this._floatLabel;\n        },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            if (value !== this._floatLabel) {\n                this._floatLabel = value || this._labelOptions.float || 'auto';\n                this._changeDetectorRef.markForCheck();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Gets an ElementRef for the element that a overlay attached to the form-field should be\n     * positioned relative to.\n     */\n    /**\n     * Gets an ElementRef for the element that a overlay attached to the form-field should be\n     * positioned relative to.\n     * @return {?}\n     */\n    MatFormField.prototype.getConnectedOverlayOrigin = /**\n     * Gets an ElementRef for the element that a overlay attached to the form-field should be\n     * positioned relative to.\n     * @return {?}\n     */\n        function () {\n            return this._connectionContainerRef || this._elementRef;\n        };\n    /**\n     * @return {?}\n     */\n    MatFormField.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            this._validateControlChild();\n            if (this._control.controlType) {\n                this._elementRef.nativeElement.classList\n                    .add(\"mat-form-field-type-\" + this._control.controlType);\n            }\n            // Subscribe to changes in the child control state in order to update the form field UI.\n            this._control.stateChanges.pipe(startWith(/** @type {?} */ ((null)))).subscribe(function () {\n                _this._validatePlaceholders();\n                _this._syncDescribedByIds();\n                _this._changeDetectorRef.markForCheck();\n            });\n            // Run change detection if the value, prefix, or suffix changes.\n            var /** @type {?} */ valueChanges = this._control.ngControl && this._control.ngControl.valueChanges || EMPTY;\n            merge(valueChanges, this._prefixChildren.changes, this._suffixChildren.changes)\n                .subscribe(function () { return _this._changeDetectorRef.markForCheck(); });\n            // Re-validate when the number of hints changes.\n            this._hintChildren.changes.pipe(startWith(null)).subscribe(function () {\n                _this._processHints();\n                _this._changeDetectorRef.markForCheck();\n            });\n            // Update the aria-described by when the number of errors changes.\n            this._errorChildren.changes.pipe(startWith(null)).subscribe(function () {\n                _this._syncDescribedByIds();\n                _this._changeDetectorRef.markForCheck();\n            });\n        };\n    /**\n     * @return {?}\n     */\n    MatFormField.prototype.ngAfterContentChecked = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            this._validateControlChild();\n            if (!this._initialGapCalculated) {\n                Promise.resolve().then(function () { return _this.updateOutlineGap(); });\n            }\n        };\n    /**\n     * @return {?}\n     */\n    MatFormField.prototype.ngAfterViewInit = /**\n     * @return {?}\n     */\n        function () {\n            // Avoid animations on load.\n            this._subscriptAnimationState = 'enter';\n            this._changeDetectorRef.detectChanges();\n        };\n    /** Determines whether a class from the NgControl should be forwarded to the host element. */\n    /**\n     * Determines whether a class from the NgControl should be forwarded to the host element.\n     * @param {?} prop\n     * @return {?}\n     */\n    MatFormField.prototype._shouldForward = /**\n     * Determines whether a class from the NgControl should be forwarded to the host element.\n     * @param {?} prop\n     * @return {?}\n     */\n        function (prop) {\n            var /** @type {?} */ ngControl = this._control ? this._control.ngControl : null;\n            return ngControl && ((ngControl))[prop];\n        };\n    /**\n     * @return {?}\n     */\n    MatFormField.prototype._hasPlaceholder = /**\n     * @return {?}\n     */\n        function () {\n            return !!(this._control && this._control.placeholder || this._placeholderChild);\n        };\n    /**\n     * @return {?}\n     */\n    MatFormField.prototype._hasLabel = /**\n     * @return {?}\n     */\n        function () {\n            return !!this._labelChild;\n        };\n    /**\n     * @return {?}\n     */\n    MatFormField.prototype._shouldLabelFloat = /**\n     * @return {?}\n     */\n        function () {\n            return this._canLabelFloat && (this._control.shouldLabelFloat || this._shouldAlwaysFloat);\n        };\n    /**\n     * @return {?}\n     */\n    MatFormField.prototype._hideControlPlaceholder = /**\n     * @return {?}\n     */\n        function () {\n            // In the legacy appearance the placeholder is promoted to a label if no label is given.\n            return this.appearance === 'legacy' && !this._hasLabel() ||\n                this._hasLabel() && !this._shouldLabelFloat();\n        };\n    /**\n     * @return {?}\n     */\n    MatFormField.prototype._hasFloatingLabel = /**\n     * @return {?}\n     */\n        function () {\n            // In the legacy appearance the placeholder is promoted to a label if no label is given.\n            return this._hasLabel() || this.appearance === 'legacy' && this._hasPlaceholder();\n        };\n    /** Determines whether to display hints or errors. */\n    /**\n     * Determines whether to display hints or errors.\n     * @return {?}\n     */\n    MatFormField.prototype._getDisplayedMessages = /**\n     * Determines whether to display hints or errors.\n     * @return {?}\n     */\n        function () {\n            return (this._errorChildren && this._errorChildren.length > 0 &&\n                this._control.errorState) ? 'error' : 'hint';\n        };\n    /** Animates the placeholder up and locks it in position. */\n    /**\n     * Animates the placeholder up and locks it in position.\n     * @return {?}\n     */\n    MatFormField.prototype._animateAndLockLabel = /**\n     * Animates the placeholder up and locks it in position.\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            if (this._hasFloatingLabel() && this._canLabelFloat) {\n                this._showAlwaysAnimate = true;\n                this.floatLabel = 'always';\n                fromEvent(this._label.nativeElement, 'transitionend').pipe(take(1)).subscribe(function () {\n                    _this._showAlwaysAnimate = false;\n                });\n                this._changeDetectorRef.markForCheck();\n            }\n        };\n    /**\n     * Ensure that there is only one placeholder (either `placeholder` attribute on the child control\n     * or child element with the `mat-placeholder` directive).\n     * @return {?}\n     */\n    MatFormField.prototype._validatePlaceholders = /**\n     * Ensure that there is only one placeholder (either `placeholder` attribute on the child control\n     * or child element with the `mat-placeholder` directive).\n     * @return {?}\n     */\n        function () {\n            if (this._control.placeholder && this._placeholderChild) {\n                throw getMatFormFieldPlaceholderConflictError();\n            }\n        };\n    /**\n     * Does any extra processing that is required when handling the hints.\n     * @return {?}\n     */\n    MatFormField.prototype._processHints = /**\n     * Does any extra processing that is required when handling the hints.\n     * @return {?}\n     */\n        function () {\n            this._validateHints();\n            this._syncDescribedByIds();\n        };\n    /**\n     * Ensure that there is a maximum of one of each `<mat-hint>` alignment specified, with the\n     * attribute being considered as `align=\"start\"`.\n     * @return {?}\n     */\n    MatFormField.prototype._validateHints = /**\n     * Ensure that there is a maximum of one of each `<mat-hint>` alignment specified, with the\n     * attribute being considered as `align=\"start\"`.\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            if (this._hintChildren) {\n                var /** @type {?} */ startHint_1;\n                var /** @type {?} */ endHint_1;\n                this._hintChildren.forEach(function (hint) {\n                    if (hint.align === 'start') {\n                        if (startHint_1 || _this.hintLabel) {\n                            throw getMatFormFieldDuplicatedHintError('start');\n                        }\n                        startHint_1 = hint;\n                    }\n                    else if (hint.align === 'end') {\n                        if (endHint_1) {\n                            throw getMatFormFieldDuplicatedHintError('end');\n                        }\n                        endHint_1 = hint;\n                    }\n                });\n            }\n        };\n    /**\n     * Sets the list of element IDs that describe the child control. This allows the control to update\n     * its `aria-describedby` attribute accordingly.\n     * @return {?}\n     */\n    MatFormField.prototype._syncDescribedByIds = /**\n     * Sets the list of element IDs that describe the child control. This allows the control to update\n     * its `aria-describedby` attribute accordingly.\n     * @return {?}\n     */\n        function () {\n            if (this._control) {\n                var /** @type {?} */ ids = [];\n                if (this._getDisplayedMessages() === 'hint') {\n                    var /** @type {?} */ startHint = this._hintChildren ?\n                        this._hintChildren.find(function (hint) { return hint.align === 'start'; }) : null;\n                    var /** @type {?} */ endHint = this._hintChildren ?\n                        this._hintChildren.find(function (hint) { return hint.align === 'end'; }) : null;\n                    if (startHint) {\n                        ids.push(startHint.id);\n                    }\n                    else if (this._hintLabel) {\n                        ids.push(this._hintLabelId);\n                    }\n                    if (endHint) {\n                        ids.push(endHint.id);\n                    }\n                }\n                else if (this._errorChildren) {\n                    ids = this._errorChildren.map(function (error) { return error.id; });\n                }\n                this._control.setDescribedByIds(ids);\n            }\n        };\n    /** Throws an error if the form field's control is missing. */\n    /**\n     * Throws an error if the form field's control is missing.\n     * @return {?}\n     */\n    MatFormField.prototype._validateControlChild = /**\n     * Throws an error if the form field's control is missing.\n     * @return {?}\n     */\n        function () {\n            if (!this._control) {\n                throw getMatFormFieldMissingControlError();\n            }\n        };\n    /**\n     * Updates the width and position of the gap in the outline. Only relevant for the outline\n     * appearance.\n     */\n    /**\n     * Updates the width and position of the gap in the outline. Only relevant for the outline\n     * appearance.\n     * @return {?}\n     */\n    MatFormField.prototype.updateOutlineGap = /**\n     * Updates the width and position of the gap in the outline. Only relevant for the outline\n     * appearance.\n     * @return {?}\n     */\n        function () {\n            if (this.appearance === 'outline' && this._label && this._label.nativeElement.children.length) {\n                if (this._platform && !this._platform.isBrowser) {\n                    // getBoundingClientRect isn't available on the server.\n                    this._initialGapCalculated = true;\n                    return;\n                }\n                if (!document.documentElement.contains(this._elementRef.nativeElement)) {\n                    return;\n                }\n                var /** @type {?} */ containerStart = this._getStartEnd(this._connectionContainerRef.nativeElement.getBoundingClientRect());\n                var /** @type {?} */ labelStart = this._getStartEnd(this._label.nativeElement.children[0].getBoundingClientRect());\n                var /** @type {?} */ labelWidth = 0;\n                for (var _i = 0, _a = this._label.nativeElement.children; _i < _a.length; _i++) {\n                    var child = _a[_i];\n                    labelWidth += child.offsetWidth;\n                }\n                this._outlineGapStart = labelStart - containerStart - outlineGapPadding;\n                this._outlineGapWidth = labelWidth * floatingLabelScale + outlineGapPadding * 2;\n            }\n            else {\n                this._outlineGapStart = 0;\n                this._outlineGapWidth = 0;\n            }\n            this._initialGapCalculated = true;\n            this._changeDetectorRef.markForCheck();\n        };\n    /**\n     * Gets the start end of the rect considering the current directionality.\n     * @param {?} rect\n     * @return {?}\n     */\n    MatFormField.prototype._getStartEnd = /**\n     * Gets the start end of the rect considering the current directionality.\n     * @param {?} rect\n     * @return {?}\n     */\n        function (rect) {\n            return this._dir && this._dir.value === 'rtl' ? rect.right : rect.left;\n        };\n    return MatFormField;\n}(_MatFormFieldMixinBase));\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar MatFormFieldModule = /*@__PURE__*/ (function () {\n    function MatFormFieldModule() {\n    }\n    return MatFormFieldModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nexport { MatFormFieldModule, MatError, MatFormFieldBase, _MatFormFieldMixinBase, MAT_FORM_FIELD_DEFAULT_OPTIONS, MatFormField, MatFormFieldControl, getMatFormFieldPlaceholderConflictError, getMatFormFieldDuplicatedHintError, getMatFormFieldMissingControlError, MatHint, MatPlaceholder, MatPrefix, MatSuffix, MatLabel, matFormFieldAnimations };\n//# sourceMappingURL=form-field.es5.js.map\n",null]}