{"remainingRequest":"/home/liutao/Project/0/oncology/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/home/liutao/Project/0/oncology/node_modules/@angular/material/esm5/list.es5.js","dependencies":[{"path":"/home/liutao/Project/0/oncology/node_modules/@angular/material/esm5/list.es5.js","mtime":1526941038000},{"path":"/home/liutao/Project/0/oncology/node_modules/cache-loader/dist/cjs.js","mtime":1539266424898},{"path":"/home/liutao/Project/0/oncology/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1526531406000}],"contextDependencies":[],"result":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** PURE_IMPORTS_START tslib,_angular_core,_angular_material_core,_angular_cdk_a11y,_angular_cdk_coercion,_angular_cdk_collections,_angular_cdk_keycodes,_angular_forms,rxjs,_angular_common,_angular_material_divider PURE_IMPORTS_END */\nimport { __extends } from 'tslib';\nimport { ChangeDetectionStrategy, Component, ContentChild, ContentChildren, Directive, ElementRef, Optional, ViewEncapsulation, Attribute, ChangeDetectorRef, EventEmitter, forwardRef, Inject, Input, Output, ViewChild, NgModule } from '@angular/core';\nimport { MatLine, MatLineSetter, mixinDisableRipple, mixinDisabled, MatCommonModule, MatLineModule, MatPseudoCheckboxModule, MatRippleModule } from '@angular/material/core';\nimport { FocusKeyManager } from '@angular/cdk/a11y';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { SelectionModel } from '@angular/cdk/collections';\nimport { SPACE, ENTER, HOME, END, UP_ARROW, DOWN_ARROW } from '@angular/cdk/keycodes';\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { Subscription } from 'rxjs';\nimport { CommonModule } from '@angular/common';\nimport { MatDividerModule } from '@angular/material/divider';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * \\@docs-private\n */\nvar /**\n * \\@docs-private\n */ MatListBase = /*@__PURE__*/ (function () {\n    function MatListBase() {\n    }\n    return MatListBase;\n}());\nvar /** @type {?} */ _MatListMixinBase = /*@__PURE__*/ mixinDisableRipple(MatListBase);\n/**\n * \\@docs-private\n */\nvar /**\n * \\@docs-private\n */ MatListItemBase = /*@__PURE__*/ (function () {\n    function MatListItemBase() {\n    }\n    return MatListItemBase;\n}());\nvar /** @type {?} */ _MatListItemMixinBase = /*@__PURE__*/ mixinDisableRipple(MatListItemBase);\nvar MatNavList = /*@__PURE__*/ (function (_super) {\n    __extends(MatNavList, _super);\n    function MatNavList() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return MatNavList;\n}(_MatListMixinBase));\nvar MatList = /*@__PURE__*/ (function (_super) {\n    __extends(MatList, _super);\n    function MatList() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return MatList;\n}(_MatListMixinBase));\n/**\n * Directive whose purpose is to add the mat- CSS styling to this selector.\n * \\@docs-private\n */\nvar MatListAvatarCssMatStyler = /*@__PURE__*/ (function () {\n    function MatListAvatarCssMatStyler() {\n    }\n    return MatListAvatarCssMatStyler;\n}());\n/**\n * Directive whose purpose is to add the mat- CSS styling to this selector.\n * \\@docs-private\n */\nvar MatListIconCssMatStyler = /*@__PURE__*/ (function () {\n    function MatListIconCssMatStyler() {\n    }\n    return MatListIconCssMatStyler;\n}());\n/**\n * Directive whose purpose is to add the mat- CSS styling to this selector.\n * \\@docs-private\n */\nvar MatListSubheaderCssMatStyler = /*@__PURE__*/ (function () {\n    function MatListSubheaderCssMatStyler() {\n    }\n    return MatListSubheaderCssMatStyler;\n}());\n/**\n * An item within a Material Design list.\n */\nvar MatListItem = /*@__PURE__*/ (function (_super) {\n    __extends(MatListItem, _super);\n    function MatListItem(_element, _navList) {\n        var _this = _super.call(this) || this;\n        _this._element = _element;\n        _this._navList = _navList;\n        _this._isNavList = false;\n        _this._isNavList = !!_navList;\n        return _this;\n    }\n    /**\n     * @return {?}\n     */\n    MatListItem.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n        function () {\n            // TODO: consider turning the setter into a function, it doesn't do anything as a class.\n            // tslint:disable-next-line:no-unused-expression\n            new MatLineSetter(this._lines, this._element);\n        };\n    /** Whether this list item should show a ripple effect when clicked. */\n    /**\n     * Whether this list item should show a ripple effect when clicked.\n     * @return {?}\n     */\n    MatListItem.prototype._isRippleDisabled = /**\n     * Whether this list item should show a ripple effect when clicked.\n     * @return {?}\n     */\n        function () {\n            return !this._isNavList || this.disableRipple || this._navList.disableRipple;\n        };\n    /**\n     * @return {?}\n     */\n    MatListItem.prototype._handleFocus = /**\n     * @return {?}\n     */\n        function () {\n            this._element.nativeElement.classList.add('mat-list-item-focus');\n        };\n    /**\n     * @return {?}\n     */\n    MatListItem.prototype._handleBlur = /**\n     * @return {?}\n     */\n        function () {\n            this._element.nativeElement.classList.remove('mat-list-item-focus');\n        };\n    /** Retrieves the DOM element of the component host. */\n    /**\n     * Retrieves the DOM element of the component host.\n     * @return {?}\n     */\n    MatListItem.prototype._getHostElement = /**\n     * Retrieves the DOM element of the component host.\n     * @return {?}\n     */\n        function () {\n            return this._element.nativeElement;\n        };\n    return MatListItem;\n}(_MatListItemMixinBase));\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * \\@docs-private\n */\nvar /**\n * \\@docs-private\n */ MatSelectionListBase = /*@__PURE__*/ (function () {\n    function MatSelectionListBase() {\n    }\n    return MatSelectionListBase;\n}());\nvar /** @type {?} */ _MatSelectionListMixinBase = /*@__PURE__*/ mixinDisableRipple(/*@__PURE__*/ mixinDisabled(MatSelectionListBase));\n/**\n * \\@docs-private\n */\nvar /**\n * \\@docs-private\n */ MatListOptionBase = /*@__PURE__*/ (function () {\n    function MatListOptionBase() {\n    }\n    return MatListOptionBase;\n}());\nvar /** @type {?} */ _MatListOptionMixinBase = /*@__PURE__*/ mixinDisableRipple(MatListOptionBase);\n/**\n * \\@docs-private\n */\nvar /** @type {?} */ MAT_SELECTION_LIST_VALUE_ACCESSOR = {\n    provide: NG_VALUE_ACCESSOR,\n    useExisting: /*@__PURE__*/ forwardRef(function () { return MatSelectionList; }),\n    multi: true\n};\n/**\n * Change event that is being fired whenever the selected state of an option changes.\n */\nvar /**\n * Change event that is being fired whenever the selected state of an option changes.\n */ MatSelectionListChange = /*@__PURE__*/ (function () {\n    function MatSelectionListChange(source, option) {\n        this.source = source;\n        this.option = option;\n    }\n    return MatSelectionListChange;\n}());\n/**\n * Component for list-options of selection-list. Each list-option can automatically\n * generate a checkbox and can put current item into the selectionModel of selection-list\n * if the current item is selected.\n */\nvar MatListOption = /*@__PURE__*/ (function (_super) {\n    __extends(MatListOption, _super);\n    function MatListOption(_element, _changeDetector, /** @docs-private */ selectionList) {\n        var _this = _super.call(this) || this;\n        _this._element = _element;\n        _this._changeDetector = _changeDetector;\n        _this.selectionList = selectionList;\n        _this._selected = false;\n        _this._disabled = false;\n        /**\n         * Whether the option has focus.\n         */\n        _this._hasFocus = false;\n        /**\n         * Whether the label should appear before or after the checkbox. Defaults to 'after'\n         */\n        _this.checkboxPosition = 'after';\n        return _this;\n    }\n    Object.defineProperty(MatListOption.prototype, \"disabled\", {\n        get: /**\n         * Whether the option is disabled.\n         * @return {?}\n         */ function () { return this._disabled || (this.selectionList && this.selectionList.disabled); },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            var /** @type {?} */ newValue = coerceBooleanProperty(value);\n            if (newValue !== this._disabled) {\n                this._disabled = newValue;\n                this._changeDetector.markForCheck();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatListOption.prototype, \"selected\", {\n        get: /**\n         * Whether the option is selected.\n         * @return {?}\n         */ function () { return this.selectionList.selectedOptions.isSelected(this); },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            var /** @type {?} */ isSelected = coerceBooleanProperty(value);\n            if (isSelected !== this._selected) {\n                this._setSelected(isSelected);\n                this.selectionList._reportValueChange();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    MatListOption.prototype.ngOnInit = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            // List options that are selected at initialization can't be reported properly to the form\n            // control. This is because it takes some time until the selection-list knows about all\n            // available options. Also it can happen that the ControlValueAccessor has an initial value\n            // that should be used instead. Deferring the value change report to the next tick ensures\n            // that the form control value is not being overwritten.\n            var /** @type {?} */ wasSelected = this._selected;\n            Promise.resolve().then(function () {\n                if (_this._selected || wasSelected) {\n                    _this.selected = true;\n                    _this._changeDetector.markForCheck();\n                }\n            });\n        };\n    /**\n     * @return {?}\n     */\n    MatListOption.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n        function () {\n            // TODO: consider turning the setter into a function, it doesn't do anything as a class.\n            // tslint:disable-next-line:no-unused-expression\n            new MatLineSetter(this._lines, this._element);\n        };\n    /**\n     * @return {?}\n     */\n    MatListOption.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            if (this.selected) {\n                // We have to delay this until the next tick in order\n                // to avoid changed after checked errors.\n                Promise.resolve().then(function () { return _this.selected = false; });\n            }\n            this.selectionList._removeOptionFromList(this);\n        };\n    /** Toggles the selection state of the option. */\n    /**\n     * Toggles the selection state of the option.\n     * @return {?}\n     */\n    MatListOption.prototype.toggle = /**\n     * Toggles the selection state of the option.\n     * @return {?}\n     */\n        function () {\n            this.selected = !this.selected;\n        };\n    /** Allows for programmatic focusing of the option. */\n    /**\n     * Allows for programmatic focusing of the option.\n     * @return {?}\n     */\n    MatListOption.prototype.focus = /**\n     * Allows for programmatic focusing of the option.\n     * @return {?}\n     */\n        function () {\n            this._element.nativeElement.focus();\n        };\n    /**\n     * Returns the list item's text label. Implemented as a part of the FocusKeyManager.\n     * @docs-private\n     */\n    /**\n     * Returns the list item's text label. Implemented as a part of the FocusKeyManager.\n     * \\@docs-private\n     * @return {?}\n     */\n    MatListOption.prototype.getLabel = /**\n     * Returns the list item's text label. Implemented as a part of the FocusKeyManager.\n     * \\@docs-private\n     * @return {?}\n     */\n        function () {\n            return this._text ? this._text.nativeElement.textContent : '';\n        };\n    /** Whether this list item should show a ripple effect when clicked. */\n    /**\n     * Whether this list item should show a ripple effect when clicked.\n     * @return {?}\n     */\n    MatListOption.prototype._isRippleDisabled = /**\n     * Whether this list item should show a ripple effect when clicked.\n     * @return {?}\n     */\n        function () {\n            return this.disabled || this.disableRipple || this.selectionList.disableRipple;\n        };\n    /**\n     * @return {?}\n     */\n    MatListOption.prototype._handleClick = /**\n     * @return {?}\n     */\n        function () {\n            if (!this.disabled) {\n                this.toggle();\n                // Emit a change event if the selected state of the option changed through user interaction.\n                this.selectionList._emitChangeEvent(this);\n            }\n        };\n    /**\n     * @return {?}\n     */\n    MatListOption.prototype._handleFocus = /**\n     * @return {?}\n     */\n        function () {\n            this._hasFocus = true;\n            this.selectionList._setFocusedOption(this);\n        };\n    /**\n     * @return {?}\n     */\n    MatListOption.prototype._handleBlur = /**\n     * @return {?}\n     */\n        function () {\n            this._hasFocus = false;\n            this.selectionList._onTouched();\n        };\n    /** Retrieves the DOM element of the component host. */\n    /**\n     * Retrieves the DOM element of the component host.\n     * @return {?}\n     */\n    MatListOption.prototype._getHostElement = /**\n     * Retrieves the DOM element of the component host.\n     * @return {?}\n     */\n        function () {\n            return this._element.nativeElement;\n        };\n    /** Sets the selected state of the option. Returns whether the value has changed. */\n    /**\n     * Sets the selected state of the option. Returns whether the value has changed.\n     * @param {?} selected\n     * @return {?}\n     */\n    MatListOption.prototype._setSelected = /**\n     * Sets the selected state of the option. Returns whether the value has changed.\n     * @param {?} selected\n     * @return {?}\n     */\n        function (selected) {\n            if (selected === this._selected) {\n                return false;\n            }\n            this._selected = selected;\n            if (selected) {\n                this.selectionList.selectedOptions.select(this);\n            }\n            else {\n                this.selectionList.selectedOptions.deselect(this);\n            }\n            this._changeDetector.markForCheck();\n            return true;\n        };\n    return MatListOption;\n}(_MatListOptionMixinBase));\n/**\n * Material Design list component where each item is a selectable option. Behaves as a listbox.\n */\nvar MatSelectionList = /*@__PURE__*/ (function (_super) {\n    __extends(MatSelectionList, _super);\n    function MatSelectionList(_element, tabIndex) {\n        var _this = _super.call(this) || this;\n        _this._element = _element;\n        /**\n         * Emits a change event whenever the selected state of an option changes.\n         */\n        _this.selectionChange = new EventEmitter();\n        /**\n         * Tabindex of the selection list.\n         */\n        _this.tabIndex = 0;\n        /**\n         * The currently selected options.\n         */\n        _this.selectedOptions = new SelectionModel(true);\n        /**\n         * View to model callback that should be called whenever the selected options change.\n         */\n        _this._onChange = function (_) { };\n        _this._modelChanges = Subscription.EMPTY;\n        /**\n         * View to model callback that should be called if the list or its options lost focus.\n         */\n        _this._onTouched = function () { };\n        _this.tabIndex = parseInt(tabIndex) || 0;\n        return _this;\n    }\n    /**\n     * @return {?}\n     */\n    MatSelectionList.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n        function () {\n            this._keyManager = new FocusKeyManager(this.options)\n                .withWrap()\n                .withTypeAhead()\n                .skipPredicate(function () { return false; });\n            if (this._tempValues) {\n                this._setOptionsFromValues(this._tempValues);\n                this._tempValues = null;\n            }\n            // Sync external changes to the model back to the options.\n            this._modelChanges = /** @type {?} */ ((this.selectedOptions.onChange)).subscribe(function (event) {\n                if (event.added) {\n                    for (var _i = 0, _a = event.added; _i < _a.length; _i++) {\n                        var item = _a[_i];\n                        item.selected = true;\n                    }\n                }\n                if (event.removed) {\n                    for (var _b = 0, _c = event.removed; _b < _c.length; _b++) {\n                        var item = _c[_b];\n                        item.selected = false;\n                    }\n                }\n            });\n        };\n    /**\n     * @return {?}\n     */\n    MatSelectionList.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            this._modelChanges.unsubscribe();\n        };\n    /** Focuses the last active list option. */\n    /**\n     * Focuses the last active list option.\n     * @return {?}\n     */\n    MatSelectionList.prototype.focus = /**\n     * Focuses the last active list option.\n     * @return {?}\n     */\n        function () {\n            this._element.nativeElement.focus();\n        };\n    /** Selects all of the options. */\n    /**\n     * Selects all of the options.\n     * @return {?}\n     */\n    MatSelectionList.prototype.selectAll = /**\n     * Selects all of the options.\n     * @return {?}\n     */\n        function () {\n            this._setAllOptionsSelected(true);\n        };\n    /** Deselects all of the options. */\n    /**\n     * Deselects all of the options.\n     * @return {?}\n     */\n    MatSelectionList.prototype.deselectAll = /**\n     * Deselects all of the options.\n     * @return {?}\n     */\n        function () {\n            this._setAllOptionsSelected(false);\n        };\n    /** Sets the focused option of the selection-list. */\n    /**\n     * Sets the focused option of the selection-list.\n     * @param {?} option\n     * @return {?}\n     */\n    MatSelectionList.prototype._setFocusedOption = /**\n     * Sets the focused option of the selection-list.\n     * @param {?} option\n     * @return {?}\n     */\n        function (option) {\n            this._keyManager.updateActiveItemIndex(this._getOptionIndex(option));\n        };\n    /** Removes an option from the selection list and updates the active item. */\n    /**\n     * Removes an option from the selection list and updates the active item.\n     * @param {?} option\n     * @return {?}\n     */\n    MatSelectionList.prototype._removeOptionFromList = /**\n     * Removes an option from the selection list and updates the active item.\n     * @param {?} option\n     * @return {?}\n     */\n        function (option) {\n            if (option._hasFocus) {\n                var /** @type {?} */ optionIndex = this._getOptionIndex(option);\n                // Check whether the option is the last item\n                if (optionIndex > 0) {\n                    this._keyManager.setPreviousItemActive();\n                }\n                else if (optionIndex === 0 && this.options.length > 1) {\n                    this._keyManager.setNextItemActive();\n                }\n            }\n        };\n    /** Passes relevant key presses to our key manager. */\n    /**\n     * Passes relevant key presses to our key manager.\n     * @param {?} event\n     * @return {?}\n     */\n    MatSelectionList.prototype._keydown = /**\n     * Passes relevant key presses to our key manager.\n     * @param {?} event\n     * @return {?}\n     */\n        function (event) {\n            var /** @type {?} */ keyCode = event.keyCode;\n            var /** @type {?} */ manager = this._keyManager;\n            var /** @type {?} */ previousFocusIndex = manager.activeItemIndex;\n            switch (keyCode) {\n                case SPACE:\n                case ENTER:\n                    if (!this.disabled) {\n                        this._toggleSelectOnFocusedOption();\n                        // Always prevent space from scrolling the page since the list has focus\n                        event.preventDefault();\n                    }\n                    break;\n                case HOME:\n                case END:\n                    keyCode === HOME ? manager.setFirstItemActive() : manager.setLastItemActive();\n                    event.preventDefault();\n                    break;\n                default:\n                    manager.onKeydown(event);\n            }\n            if ((keyCode === UP_ARROW || keyCode === DOWN_ARROW) && event.shiftKey &&\n                manager.activeItemIndex !== previousFocusIndex) {\n                this._toggleSelectOnFocusedOption();\n            }\n        };\n    /** Reports a value change to the ControlValueAccessor */\n    /**\n     * Reports a value change to the ControlValueAccessor\n     * @return {?}\n     */\n    MatSelectionList.prototype._reportValueChange = /**\n     * Reports a value change to the ControlValueAccessor\n     * @return {?}\n     */\n        function () {\n            if (this.options) {\n                this._onChange(this._getSelectedOptionValues());\n            }\n        };\n    /** Emits a change event if the selected state of an option changed. */\n    /**\n     * Emits a change event if the selected state of an option changed.\n     * @param {?} option\n     * @return {?}\n     */\n    MatSelectionList.prototype._emitChangeEvent = /**\n     * Emits a change event if the selected state of an option changed.\n     * @param {?} option\n     * @return {?}\n     */\n        function (option) {\n            this.selectionChange.emit(new MatSelectionListChange(this, option));\n        };\n    /** Implemented as part of ControlValueAccessor. */\n    /**\n     * Implemented as part of ControlValueAccessor.\n     * @param {?} values\n     * @return {?}\n     */\n    MatSelectionList.prototype.writeValue = /**\n     * Implemented as part of ControlValueAccessor.\n     * @param {?} values\n     * @return {?}\n     */\n        function (values) {\n            if (this.options) {\n                this._setOptionsFromValues(values || []);\n            }\n            else {\n                this._tempValues = values;\n            }\n        };\n    /** Implemented as a part of ControlValueAccessor. */\n    /**\n     * Implemented as a part of ControlValueAccessor.\n     * @param {?} isDisabled\n     * @return {?}\n     */\n    MatSelectionList.prototype.setDisabledState = /**\n     * Implemented as a part of ControlValueAccessor.\n     * @param {?} isDisabled\n     * @return {?}\n     */\n        function (isDisabled) {\n            if (this.options) {\n                this.options.forEach(function (option) { return option.disabled = isDisabled; });\n            }\n        };\n    /** Implemented as part of ControlValueAccessor. */\n    /**\n     * Implemented as part of ControlValueAccessor.\n     * @param {?} fn\n     * @return {?}\n     */\n    MatSelectionList.prototype.registerOnChange = /**\n     * Implemented as part of ControlValueAccessor.\n     * @param {?} fn\n     * @return {?}\n     */\n        function (fn) {\n            this._onChange = fn;\n        };\n    /** Implemented as part of ControlValueAccessor. */\n    /**\n     * Implemented as part of ControlValueAccessor.\n     * @param {?} fn\n     * @return {?}\n     */\n    MatSelectionList.prototype.registerOnTouched = /**\n     * Implemented as part of ControlValueAccessor.\n     * @param {?} fn\n     * @return {?}\n     */\n        function (fn) {\n            this._onTouched = fn;\n        };\n    /**\n     * Sets the selected options based on the specified values.\n     * @param {?} values\n     * @return {?}\n     */\n    MatSelectionList.prototype._setOptionsFromValues = /**\n     * Sets the selected options based on the specified values.\n     * @param {?} values\n     * @return {?}\n     */\n        function (values) {\n            var _this = this;\n            this.options.forEach(function (option) { return option._setSelected(false); });\n            values\n                .map(function (value) {\n                return _this.options.find(function (option) {\n                    return _this.compareWith ? _this.compareWith(option.value, value) : option.value === value;\n                });\n            })\n                .filter(Boolean)\n                .forEach(function (option) { return ((option))._setSelected(true); });\n        };\n    /**\n     * Returns the values of the selected options.\n     * @return {?}\n     */\n    MatSelectionList.prototype._getSelectedOptionValues = /**\n     * Returns the values of the selected options.\n     * @return {?}\n     */\n        function () {\n            return this.options.filter(function (option) { return option.selected; }).map(function (option) { return option.value; });\n        };\n    /**\n     * Toggles the selected state of the currently focused option.\n     * @return {?}\n     */\n    MatSelectionList.prototype._toggleSelectOnFocusedOption = /**\n     * Toggles the selected state of the currently focused option.\n     * @return {?}\n     */\n        function () {\n            var /** @type {?} */ focusedIndex = this._keyManager.activeItemIndex;\n            if (focusedIndex != null && this._isValidIndex(focusedIndex)) {\n                var /** @type {?} */ focusedOption = this.options.toArray()[focusedIndex];\n                if (focusedOption) {\n                    focusedOption.toggle();\n                    // Emit a change event because the focused option changed its state through user\n                    // interaction.\n                    this._emitChangeEvent(focusedOption);\n                }\n            }\n        };\n    /**\n     * Sets the selected state on all of the options\n     * and emits an event if anything changed.\n     * @param {?} isSelected\n     * @return {?}\n     */\n    MatSelectionList.prototype._setAllOptionsSelected = /**\n     * Sets the selected state on all of the options\n     * and emits an event if anything changed.\n     * @param {?} isSelected\n     * @return {?}\n     */\n        function (isSelected) {\n            // Keep track of whether anything changed, because we only want to\n            // emit the changed event when something actually changed.\n            var /** @type {?} */ hasChanged = false;\n            this.options.forEach(function (option) {\n                if (option._setSelected(isSelected)) {\n                    hasChanged = true;\n                }\n            });\n            if (hasChanged) {\n                this._reportValueChange();\n            }\n        };\n    /**\n     * Utility to ensure all indexes are valid.\n     * @param {?} index The index to be checked.\n     * @return {?} True if the index is valid for our list of options.\n     */\n    MatSelectionList.prototype._isValidIndex = /**\n     * Utility to ensure all indexes are valid.\n     * @param {?} index The index to be checked.\n     * @return {?} True if the index is valid for our list of options.\n     */\n        function (index) {\n            return index >= 0 && index < this.options.length;\n        };\n    /**\n     * Returns the index of the specified list option.\n     * @param {?} option\n     * @return {?}\n     */\n    MatSelectionList.prototype._getOptionIndex = /**\n     * Returns the index of the specified list option.\n     * @param {?} option\n     * @return {?}\n     */\n        function (option) {\n            return this.options.toArray().indexOf(option);\n        };\n    return MatSelectionList;\n}(_MatSelectionListMixinBase));\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar MatListModule = /*@__PURE__*/ (function () {\n    function MatListModule() {\n    }\n    return MatListModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nexport { MatListModule, MatListBase, _MatListMixinBase, MatListItemBase, _MatListItemMixinBase, MatNavList, MatList, MatListAvatarCssMatStyler, MatListIconCssMatStyler, MatListSubheaderCssMatStyler, MatListItem, MatSelectionListBase, _MatSelectionListMixinBase, MatListOptionBase, _MatListOptionMixinBase, MAT_SELECTION_LIST_VALUE_ACCESSOR, MatSelectionListChange, MatListOption, MatSelectionList };\n//# sourceMappingURL=list.es5.js.map\n",null]}