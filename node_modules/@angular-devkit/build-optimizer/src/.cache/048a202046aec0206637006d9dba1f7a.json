{"remainingRequest":"/home/liutao/Project/0/oncology/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/home/liutao/Project/0/oncology/node_modules/@angular/material/esm5/slider.es5.js","dependencies":[{"path":"/home/liutao/Project/0/oncology/node_modules/@angular/material/esm5/slider.es5.js","mtime":1526941038000},{"path":"/home/liutao/Project/0/oncology/node_modules/cache-loader/dist/cjs.js","mtime":1539266424898},{"path":"/home/liutao/Project/0/oncology/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1526531406000}],"contextDependencies":[],"result":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** PURE_IMPORTS_START tslib,_angular_cdk_a11y,_angular_cdk_bidi,_angular_cdk_coercion,_angular_cdk_keycodes,_angular_core,_angular_forms,_angular_material_core,rxjs,_angular_common,_angular_platform_browser PURE_IMPORTS_END */\nimport { __extends } from 'tslib';\nimport { FocusMonitor } from '@angular/cdk/a11y';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { coerceBooleanProperty, coerceNumberProperty } from '@angular/cdk/coercion';\nimport { DOWN_ARROW, END, HOME, LEFT_ARROW, PAGE_DOWN, PAGE_UP, RIGHT_ARROW, UP_ARROW } from '@angular/cdk/keycodes';\nimport { Attribute, ChangeDetectionStrategy, ChangeDetectorRef, Component, ElementRef, EventEmitter, forwardRef, Input, Optional, Output, ViewChild, ViewEncapsulation, NgModule } from '@angular/core';\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { mixinColor, mixinDisabled, mixinTabIndex, GestureConfig, MatCommonModule } from '@angular/material/core';\nimport { Subscription } from 'rxjs';\nimport { CommonModule } from '@angular/common';\nimport { HAMMER_GESTURE_CONFIG } from '@angular/platform-browser';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Visually, a 30px separation between tick marks looks best. This is very subjective but it is\n * the default separation we chose.\n */\nvar /** @type {?} */ MIN_AUTO_TICK_SEPARATION = 30;\n/**\n * The thumb gap size for a disabled slider.\n */\nvar /** @type {?} */ DISABLED_THUMB_GAP = 7;\n/**\n * The thumb gap size for a non-active slider at its minimum value.\n */\nvar /** @type {?} */ MIN_VALUE_NONACTIVE_THUMB_GAP = 7;\n/**\n * The thumb gap size for an active slider at its minimum value.\n */\nvar /** @type {?} */ MIN_VALUE_ACTIVE_THUMB_GAP = 10;\n/**\n * Provider Expression that allows mat-slider to register as a ControlValueAccessor.\n * This allows it to support [(ngModel)] and [formControl].\n */\nvar /** @type {?} */ MAT_SLIDER_VALUE_ACCESSOR = {\n    provide: NG_VALUE_ACCESSOR,\n    useExisting: /*@__PURE__*/ forwardRef(function () { return MatSlider; }),\n    multi: true\n};\n/**\n * A simple change event emitted by the MatSlider component.\n */\nvar /**\n * A simple change event emitted by the MatSlider component.\n */ MatSliderChange = /*@__PURE__*/ (function () {\n    function MatSliderChange() {\n    }\n    return MatSliderChange;\n}());\n/**\n * \\@docs-private\n */\nvar /**\n * \\@docs-private\n */ MatSliderBase = /*@__PURE__*/ (function () {\n    function MatSliderBase(_elementRef) {\n        this._elementRef = _elementRef;\n    }\n    return MatSliderBase;\n}());\nvar /** @type {?} */ _MatSliderMixinBase = /*@__PURE__*/ mixinTabIndex(/*@__PURE__*/ mixinColor(/*@__PURE__*/ mixinDisabled(MatSliderBase), 'accent'));\n/**\n * Allows users to select from a range of values by moving the slider thumb. It is similar in\n * behavior to the native `<input type=\"range\">` element.\n */\nvar MatSlider = /*@__PURE__*/ (function (_super) {\n    __extends(MatSlider, _super);\n    function MatSlider(elementRef, _focusMonitor, _changeDetectorRef, _dir, tabIndex) {\n        var _this = _super.call(this, elementRef) || this;\n        _this._focusMonitor = _focusMonitor;\n        _this._changeDetectorRef = _changeDetectorRef;\n        _this._dir = _dir;\n        _this._invert = false;\n        _this._max = 100;\n        _this._min = 0;\n        _this._step = 1;\n        _this._thumbLabel = false;\n        _this._tickInterval = 0;\n        _this._value = null;\n        _this._vertical = false;\n        /**\n         * Event emitted when the slider value has changed.\n         */\n        _this.change = new EventEmitter();\n        /**\n         * Event emitted when the slider thumb moves.\n         */\n        _this.input = new EventEmitter();\n        /**\n         * onTouch function registered via registerOnTouch (ControlValueAccessor).\n         */\n        _this.onTouched = function () { };\n        _this._percent = 0;\n        /**\n         * Whether or not the thumb is sliding.\n         * Used to determine if there should be a transition for the thumb and fill track.\n         */\n        _this._isSliding = false;\n        /**\n         * Whether or not the slider is active (clicked or sliding).\n         * Used to shrink and grow the thumb as according to the Material Design spec.\n         */\n        _this._isActive = false;\n        /**\n         * The size of a tick interval as a percentage of the size of the track.\n         */\n        _this._tickIntervalPercent = 0;\n        /**\n         * The dimensions of the slider.\n         */\n        _this._sliderDimensions = null;\n        _this._controlValueAccessorChangeFn = function () { };\n        /**\n         * Subscription to the Directionality change EventEmitter.\n         */\n        _this._dirChangeSubscription = Subscription.EMPTY;\n        _this.tabIndex = parseInt(tabIndex) || 0;\n        return _this;\n    }\n    Object.defineProperty(MatSlider.prototype, \"invert\", {\n        get: /**\n         * Whether the slider is inverted.\n         * @return {?}\n         */ function () { return this._invert; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._invert = coerceBooleanProperty(value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatSlider.prototype, \"max\", {\n        get: /**\n         * The maximum value that the slider can have.\n         * @return {?}\n         */ function () { return this._max; },\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */ function (v) {\n            this._max = coerceNumberProperty(v, this._max);\n            this._percent = this._calculatePercentage(this._value);\n            // Since this also modifies the percentage, we need to let the change detection know.\n            this._changeDetectorRef.markForCheck();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatSlider.prototype, \"min\", {\n        get: /**\n         * The minimum value that the slider can have.\n         * @return {?}\n         */ function () { return this._min; },\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */ function (v) {\n            this._min = coerceNumberProperty(v, this._min);\n            // If the value wasn't explicitly set by the user, set it to the min.\n            if (this._value === null) {\n                this.value = this._min;\n            }\n            this._percent = this._calculatePercentage(this._value);\n            // Since this also modifies the percentage, we need to let the change detection know.\n            this._changeDetectorRef.markForCheck();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatSlider.prototype, \"step\", {\n        get: /**\n         * The values at which the thumb will snap.\n         * @return {?}\n         */ function () { return this._step; },\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */ function (v) {\n            this._step = coerceNumberProperty(v, this._step);\n            if (this._step % 1 !== 0) {\n                this._roundToDecimal = /** @type {?} */ ((this._step.toString().split('.').pop())).length;\n            }\n            // Since this could modify the label, we need to notify the change detection.\n            this._changeDetectorRef.markForCheck();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatSlider.prototype, \"thumbLabel\", {\n        get: /**\n         * Whether or not to show the thumb label.\n         * @return {?}\n         */ function () { return this._thumbLabel; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) { this._thumbLabel = coerceBooleanProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatSlider.prototype, \"tickInterval\", {\n        get: /**\n         * How often to show ticks. Relative to the step so that a tick always appears on a step.\n         * Ex: Tick interval of 4 with a step of 3 will draw a tick every 4 steps (every 12 values).\n         * @return {?}\n         */ function () { return this._tickInterval; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            if (value === 'auto') {\n                this._tickInterval = 'auto';\n            }\n            else if (typeof value === 'number' || typeof value === 'string') {\n                this._tickInterval = coerceNumberProperty(value, /** @type {?} */ (this._tickInterval));\n            }\n            else {\n                this._tickInterval = 0;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatSlider.prototype, \"value\", {\n        get: /**\n         * Value of the slider.\n         * @return {?}\n         */ function () {\n            // If the value needs to be read and it is still uninitialized, initialize it to the min.\n            if (this._value === null) {\n                this.value = this._min;\n            }\n            return this._value;\n        },\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */ function (v) {\n            if (v !== this._value) {\n                this._value = coerceNumberProperty(v);\n                this._percent = this._calculatePercentage(this._value);\n                // Since this also modifies the percentage, we need to let the change detection know.\n                this._changeDetectorRef.markForCheck();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatSlider.prototype, \"vertical\", {\n        get: /**\n         * Whether the slider is vertical.\n         * @return {?}\n         */ function () { return this._vertical; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._vertical = coerceBooleanProperty(value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatSlider.prototype, \"displayValue\", {\n        /** The value to be used for display purposes. */\n        get: /**\n         * The value to be used for display purposes.\n         * @return {?}\n         */ function () {\n            if (this.displayWith) {\n                return this.displayWith(this.value);\n            }\n            // Note that this could be improved further by rounding something like 0.999 to 1 or\n            // 0.899 to 0.9, however it is very performance sensitive, because it gets called on\n            // every change detection cycle.\n            if (this._roundToDecimal && this.value && this.value % 1 !== 0) {\n                return this.value.toFixed(this._roundToDecimal);\n            }\n            return this.value || 0;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** set focus to the host element */\n    /**\n     * set focus to the host element\n     * @return {?}\n     */\n    MatSlider.prototype.focus = /**\n     * set focus to the host element\n     * @return {?}\n     */\n        function () {\n            this._focusHostElement();\n        };\n    /** blur the host element */\n    /**\n     * blur the host element\n     * @return {?}\n     */\n    MatSlider.prototype.blur = /**\n     * blur the host element\n     * @return {?}\n     */\n        function () {\n            this._blurHostElement();\n        };\n    Object.defineProperty(MatSlider.prototype, \"percent\", {\n        /** The percentage of the slider that coincides with the value. */\n        get: /**\n         * The percentage of the slider that coincides with the value.\n         * @return {?}\n         */ function () { return this._clamp(this._percent); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatSlider.prototype, \"_invertAxis\", {\n        /**\n         * Whether the axis of the slider is inverted.\n         * (i.e. whether moving the thumb in the positive x or y direction decreases the slider's value).\n         */\n        get: /**\n         * Whether the axis of the slider is inverted.\n         * (i.e. whether moving the thumb in the positive x or y direction decreases the slider's value).\n         * @return {?}\n         */ function () {\n            // Standard non-inverted mode for a vertical slider should be dragging the thumb from bottom to\n            // top. However from a y-axis standpoint this is inverted.\n            return this.vertical ? !this.invert : this.invert;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatSlider.prototype, \"_isMinValue\", {\n        /** Whether the slider is at its minimum value. */\n        get: /**\n         * Whether the slider is at its minimum value.\n         * @return {?}\n         */ function () {\n            return this.percent === 0;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatSlider.prototype, \"_thumbGap\", {\n        /**\n         * The amount of space to leave between the slider thumb and the track fill & track background\n         * elements.\n         */\n        get: /**\n         * The amount of space to leave between the slider thumb and the track fill & track background\n         * elements.\n         * @return {?}\n         */ function () {\n            if (this.disabled) {\n                return DISABLED_THUMB_GAP;\n            }\n            if (this._isMinValue && !this.thumbLabel) {\n                return this._isActive ? MIN_VALUE_ACTIVE_THUMB_GAP : MIN_VALUE_NONACTIVE_THUMB_GAP;\n            }\n            return 0;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatSlider.prototype, \"_trackBackgroundStyles\", {\n        /** CSS styles for the track background element. */\n        get: /**\n         * CSS styles for the track background element.\n         * @return {?}\n         */ function () {\n            var /** @type {?} */ axis = this.vertical ? 'Y' : 'X';\n            var /** @type {?} */ sign = this._invertMouseCoords ? '-' : '';\n            return {\n                'transform': \"translate\" + axis + \"(\" + sign + this._thumbGap + \"px) scale\" + axis + \"(\" + (1 - this.percent) + \")\"\n            };\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatSlider.prototype, \"_trackFillStyles\", {\n        /** CSS styles for the track fill element. */\n        get: /**\n         * CSS styles for the track fill element.\n         * @return {?}\n         */ function () {\n            var /** @type {?} */ axis = this.vertical ? 'Y' : 'X';\n            var /** @type {?} */ sign = this._invertMouseCoords ? '' : '-';\n            return {\n                'transform': \"translate\" + axis + \"(\" + sign + this._thumbGap + \"px) scale\" + axis + \"(\" + this.percent + \")\"\n            };\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatSlider.prototype, \"_ticksContainerStyles\", {\n        /** CSS styles for the ticks container element. */\n        get: /**\n         * CSS styles for the ticks container element.\n         * @return {?}\n         */ function () {\n            var /** @type {?} */ axis = this.vertical ? 'Y' : 'X';\n            // For a horizontal slider in RTL languages we push the ticks container off the left edge\n            // instead of the right edge to avoid causing a horizontal scrollbar to appear.\n            var /** @type {?} */ sign = !this.vertical && this._direction == 'rtl' ? '' : '-';\n            var /** @type {?} */ offset = this._tickIntervalPercent / 2 * 100;\n            return {\n                'transform': \"translate\" + axis + \"(\" + sign + offset + \"%)\"\n            };\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatSlider.prototype, \"_ticksStyles\", {\n        /** CSS styles for the ticks element. */\n        get: /**\n         * CSS styles for the ticks element.\n         * @return {?}\n         */ function () {\n            var /** @type {?} */ tickSize = this._tickIntervalPercent * 100;\n            var /** @type {?} */ backgroundSize = this.vertical ? \"2px \" + tickSize + \"%\" : tickSize + \"% 2px\";\n            var /** @type {?} */ axis = this.vertical ? 'Y' : 'X';\n            // Depending on the direction we pushed the ticks container, push the ticks the opposite\n            // direction to re-center them but clip off the end edge. In RTL languages we need to flip the\n            // ticks 180 degrees so we're really cutting off the end edge abd not the start.\n            var /** @type {?} */ sign = !this.vertical && this._direction == 'rtl' ? '-' : '';\n            var /** @type {?} */ rotate = !this.vertical && this._direction == 'rtl' ? ' rotate(180deg)' : '';\n            var /** @type {?} */ styles = {\n                'backgroundSize': backgroundSize,\n                // Without translateZ ticks sometimes jitter as the slider moves on Chrome & Firefox.\n                'transform': \"translateZ(0) translate\" + axis + \"(\" + sign + tickSize / 2 + \"%)\" + rotate\n            };\n            if (this._isMinValue && this._thumbGap) {\n                var /** @type {?} */ side = this.vertical ?\n                    (this._invertAxis ? 'Bottom' : 'Top') :\n                    (this._invertAxis ? 'Right' : 'Left');\n                styles[\"padding\" + side] = this._thumbGap + \"px\";\n            }\n            return styles;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatSlider.prototype, \"_thumbContainerStyles\", {\n        get: /**\n         * @return {?}\n         */ function () {\n            var /** @type {?} */ axis = this.vertical ? 'Y' : 'X';\n            // For a horizontal slider in RTL languages we push the thumb container off the left edge\n            // instead of the right edge to avoid causing a horizontal scrollbar to appear.\n            var /** @type {?} */ invertOffset = (this._direction == 'rtl' && !this.vertical) ? !this._invertAxis : this._invertAxis;\n            var /** @type {?} */ offset = (invertOffset ? this.percent : 1 - this.percent) * 100;\n            return {\n                'transform': \"translate\" + axis + \"(-\" + offset + \"%)\"\n            };\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatSlider.prototype, \"_invertMouseCoords\", {\n        get: /**\n         * Whether mouse events should be converted to a slider position by calculating their distance\n         * from the right or bottom edge of the slider as opposed to the top or left.\n         * @return {?}\n         */ function () {\n            return (this._direction == 'rtl' && !this.vertical) ? !this._invertAxis : this._invertAxis;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatSlider.prototype, \"_direction\", {\n        get: /**\n         * The language direction for this slider element.\n         * @return {?}\n         */ function () {\n            return (this._dir && this._dir.value == 'rtl') ? 'rtl' : 'ltr';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    MatSlider.prototype.ngOnInit = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            this._focusMonitor\n                .monitor(this._elementRef.nativeElement, true)\n                .subscribe(function (origin) {\n                _this._isActive = !!origin && origin !== 'keyboard';\n                _this._changeDetectorRef.detectChanges();\n            });\n            if (this._dir) {\n                this._dirChangeSubscription = this._dir.change.subscribe(function () {\n                    _this._changeDetectorRef.markForCheck();\n                });\n            }\n        };\n    /**\n     * @return {?}\n     */\n    MatSlider.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            this._focusMonitor.stopMonitoring(this._elementRef.nativeElement);\n            this._dirChangeSubscription.unsubscribe();\n        };\n    /**\n     * @return {?}\n     */\n    MatSlider.prototype._onMouseenter = /**\n     * @return {?}\n     */\n        function () {\n            if (this.disabled) {\n                return;\n            }\n            // We save the dimensions of the slider here so we can use them to update the spacing of the\n            // ticks and determine where on the slider click and slide events happen.\n            this._sliderDimensions = this._getSliderDimensions();\n            this._updateTickIntervalPercent();\n        };\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    MatSlider.prototype._onClick = /**\n     * @param {?} event\n     * @return {?}\n     */\n        function (event) {\n            if (this.disabled) {\n                return;\n            }\n            var /** @type {?} */ oldValue = this.value;\n            this._isSliding = false;\n            this._focusHostElement();\n            this._updateValueFromPosition({ x: event.clientX, y: event.clientY });\n            // Emit a change and input event if the value changed.\n            if (oldValue != this.value) {\n                this._emitInputEvent();\n                this._emitChangeEvent();\n            }\n        };\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    MatSlider.prototype._onSlide = /**\n     * @param {?} event\n     * @return {?}\n     */\n        function (event) {\n            if (this.disabled) {\n                return;\n            }\n            // The slide start event sometimes fails to fire on iOS, so if we're not already in the sliding\n            // state, call the slide start handler manually.\n            if (!this._isSliding) {\n                this._onSlideStart(null);\n            }\n            // Prevent the slide from selecting anything else.\n            event.preventDefault();\n            var /** @type {?} */ oldValue = this.value;\n            this._updateValueFromPosition({ x: event.center.x, y: event.center.y });\n            // Native range elements always emit `input` events when the value changed while sliding.\n            if (oldValue != this.value) {\n                this._emitInputEvent();\n            }\n        };\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    MatSlider.prototype._onSlideStart = /**\n     * @param {?} event\n     * @return {?}\n     */\n        function (event) {\n            if (this.disabled || this._isSliding) {\n                return;\n            }\n            // Simulate mouseenter in case this is a mobile device.\n            this._onMouseenter();\n            this._isSliding = true;\n            this._focusHostElement();\n            this._valueOnSlideStart = this.value;\n            if (event) {\n                this._updateValueFromPosition({ x: event.center.x, y: event.center.y });\n                event.preventDefault();\n            }\n        };\n    /**\n     * @return {?}\n     */\n    MatSlider.prototype._onSlideEnd = /**\n     * @return {?}\n     */\n        function () {\n            this._isSliding = false;\n            if (this._valueOnSlideStart != this.value && !this.disabled) {\n                this._emitChangeEvent();\n            }\n            this._valueOnSlideStart = null;\n        };\n    /**\n     * @return {?}\n     */\n    MatSlider.prototype._onFocus = /**\n     * @return {?}\n     */\n        function () {\n            // We save the dimensions of the slider here so we can use them to update the spacing of the\n            // ticks and determine where on the slider click and slide events happen.\n            this._sliderDimensions = this._getSliderDimensions();\n            this._updateTickIntervalPercent();\n        };\n    /**\n     * @return {?}\n     */\n    MatSlider.prototype._onBlur = /**\n     * @return {?}\n     */\n        function () {\n            this.onTouched();\n        };\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    MatSlider.prototype._onKeydown = /**\n     * @param {?} event\n     * @return {?}\n     */\n        function (event) {\n            if (this.disabled) {\n                return;\n            }\n            var /** @type {?} */ oldValue = this.value;\n            switch (event.keyCode) {\n                case PAGE_UP:\n                    this._increment(10);\n                    break;\n                case PAGE_DOWN:\n                    this._increment(-10);\n                    break;\n                case END:\n                    this.value = this.max;\n                    break;\n                case HOME:\n                    this.value = this.min;\n                    break;\n                case LEFT_ARROW:\n                    // NOTE: For a sighted user it would make more sense that when they press an arrow key on an\n                    // inverted slider the thumb moves in that direction. However for a blind user, nothing\n                    // about the slider indicates that it is inverted. They will expect left to be decrement,\n                    // regardless of how it appears on the screen. For speakers ofRTL languages, they probably\n                    // expect left to mean increment. Therefore we flip the meaning of the side arrow keys for\n                    // RTL. For inverted sliders we prefer a good a11y experience to having it \"look right\" for\n                    // sighted users, therefore we do not swap the meaning.\n                    this._increment(this._direction == 'rtl' ? 1 : -1);\n                    break;\n                case UP_ARROW:\n                    this._increment(1);\n                    break;\n                case RIGHT_ARROW:\n                    // See comment on LEFT_ARROW about the conditions under which we flip the meaning.\n                    this._increment(this._direction == 'rtl' ? -1 : 1);\n                    break;\n                case DOWN_ARROW:\n                    this._increment(-1);\n                    break;\n                default:\n                    // Return if the key is not one that we explicitly handle to avoid calling preventDefault on\n                    // it.\n                    return;\n            }\n            if (oldValue != this.value) {\n                this._emitInputEvent();\n                this._emitChangeEvent();\n            }\n            this._isSliding = true;\n            event.preventDefault();\n        };\n    /**\n     * @return {?}\n     */\n    MatSlider.prototype._onKeyup = /**\n     * @return {?}\n     */\n        function () {\n            this._isSliding = false;\n        };\n    /**\n     * Increments the slider by the given number of steps (negative number decrements).\n     * @param {?} numSteps\n     * @return {?}\n     */\n    MatSlider.prototype._increment = /**\n     * Increments the slider by the given number of steps (negative number decrements).\n     * @param {?} numSteps\n     * @return {?}\n     */\n        function (numSteps) {\n            this.value = this._clamp((this.value || 0) + this.step * numSteps, this.min, this.max);\n        };\n    /**\n     * Calculate the new value from the new physical location. The value will always be snapped.\n     * @param {?} pos\n     * @return {?}\n     */\n    MatSlider.prototype._updateValueFromPosition = /**\n     * Calculate the new value from the new physical location. The value will always be snapped.\n     * @param {?} pos\n     * @return {?}\n     */\n        function (pos) {\n            if (!this._sliderDimensions) {\n                return;\n            }\n            var /** @type {?} */ offset = this.vertical ? this._sliderDimensions.top : this._sliderDimensions.left;\n            var /** @type {?} */ size = this.vertical ? this._sliderDimensions.height : this._sliderDimensions.width;\n            var /** @type {?} */ posComponent = this.vertical ? pos.y : pos.x;\n            // The exact value is calculated from the event and used to find the closest snap value.\n            var /** @type {?} */ percent = this._clamp((posComponent - offset) / size);\n            if (this._invertMouseCoords) {\n                percent = 1 - percent;\n            }\n            // Since the steps may not divide cleanly into the max value, if the user\n            // slid to 0 or 100 percent, we jump to the min/max value. This approach\n            // is slightly more intuitive than using `Math.ceil` below, because it\n            // follows the user's pointer closer.\n            if (percent === 0) {\n                this.value = this.min;\n            }\n            else if (percent === 1) {\n                this.value = this.max;\n            }\n            else {\n                var /** @type {?} */ exactValue = this._calculateValue(percent);\n                // This calculation finds the closest step by finding the closest\n                // whole number divisible by the step relative to the min.\n                var /** @type {?} */ closestValue = Math.round((exactValue - this.min) / this.step) * this.step + this.min;\n                // If we've got a step with a decimal, we may end up with something like 33.300000000000004.\n                // Truncate the value to ensure that it matches the label and to make it easier to work with.\n                if (this._roundToDecimal) {\n                    closestValue = parseFloat(closestValue.toFixed(this._roundToDecimal));\n                }\n                // The value needs to snap to the min and max.\n                this.value = this._clamp(closestValue, this.min, this.max);\n            }\n        };\n    /**\n     * Emits a change event if the current value is different from the last emitted value.\n     * @return {?}\n     */\n    MatSlider.prototype._emitChangeEvent = /**\n     * Emits a change event if the current value is different from the last emitted value.\n     * @return {?}\n     */\n        function () {\n            this._controlValueAccessorChangeFn(this.value);\n            this.change.emit(this._createChangeEvent());\n        };\n    /**\n     * Emits an input event when the current value is different from the last emitted value.\n     * @return {?}\n     */\n    MatSlider.prototype._emitInputEvent = /**\n     * Emits an input event when the current value is different from the last emitted value.\n     * @return {?}\n     */\n        function () {\n            this.input.emit(this._createChangeEvent());\n        };\n    /**\n     * Updates the amount of space between ticks as a percentage of the width of the slider.\n     * @return {?}\n     */\n    MatSlider.prototype._updateTickIntervalPercent = /**\n     * Updates the amount of space between ticks as a percentage of the width of the slider.\n     * @return {?}\n     */\n        function () {\n            if (!this.tickInterval || !this._sliderDimensions) {\n                return;\n            }\n            if (this.tickInterval == 'auto') {\n                var /** @type {?} */ trackSize = this.vertical ? this._sliderDimensions.height : this._sliderDimensions.width;\n                var /** @type {?} */ pixelsPerStep = trackSize * this.step / (this.max - this.min);\n                var /** @type {?} */ stepsPerTick = Math.ceil(MIN_AUTO_TICK_SEPARATION / pixelsPerStep);\n                var /** @type {?} */ pixelsPerTick = stepsPerTick * this.step;\n                this._tickIntervalPercent = pixelsPerTick / trackSize;\n            }\n            else {\n                this._tickIntervalPercent = this.tickInterval * this.step / (this.max - this.min);\n            }\n        };\n    /**\n     * Creates a slider change object from the specified value.\n     * @param {?=} value\n     * @return {?}\n     */\n    MatSlider.prototype._createChangeEvent = /**\n     * Creates a slider change object from the specified value.\n     * @param {?=} value\n     * @return {?}\n     */\n        function (value) {\n            if (value === void 0) {\n                value = this.value;\n            }\n            var /** @type {?} */ event = new MatSliderChange();\n            event.source = this;\n            event.value = value;\n            return event;\n        };\n    /**\n     * Calculates the percentage of the slider that a value is.\n     * @param {?} value\n     * @return {?}\n     */\n    MatSlider.prototype._calculatePercentage = /**\n     * Calculates the percentage of the slider that a value is.\n     * @param {?} value\n     * @return {?}\n     */\n        function (value) {\n            return ((value || 0) - this.min) / (this.max - this.min);\n        };\n    /**\n     * Calculates the value a percentage of the slider corresponds to.\n     * @param {?} percentage\n     * @return {?}\n     */\n    MatSlider.prototype._calculateValue = /**\n     * Calculates the value a percentage of the slider corresponds to.\n     * @param {?} percentage\n     * @return {?}\n     */\n        function (percentage) {\n            return this.min + percentage * (this.max - this.min);\n        };\n    /**\n     * Return a number between two numbers.\n     * @param {?} value\n     * @param {?=} min\n     * @param {?=} max\n     * @return {?}\n     */\n    MatSlider.prototype._clamp = /**\n     * Return a number between two numbers.\n     * @param {?} value\n     * @param {?=} min\n     * @param {?=} max\n     * @return {?}\n     */\n        function (value, min, max) {\n            if (min === void 0) {\n                min = 0;\n            }\n            if (max === void 0) {\n                max = 1;\n            }\n            return Math.max(min, Math.min(value, max));\n        };\n    /**\n     * Get the bounding client rect of the slider track element.\n     * The track is used rather than the native element to ignore the extra space that the thumb can\n     * take up.\n     * @return {?}\n     */\n    MatSlider.prototype._getSliderDimensions = /**\n     * Get the bounding client rect of the slider track element.\n     * The track is used rather than the native element to ignore the extra space that the thumb can\n     * take up.\n     * @return {?}\n     */\n        function () {\n            return this._sliderWrapper ? this._sliderWrapper.nativeElement.getBoundingClientRect() : null;\n        };\n    /**\n     * Focuses the native element.\n     * Currently only used to allow a blur event to fire but will be used with keyboard input later.\n     * @return {?}\n     */\n    MatSlider.prototype._focusHostElement = /**\n     * Focuses the native element.\n     * Currently only used to allow a blur event to fire but will be used with keyboard input later.\n     * @return {?}\n     */\n        function () {\n            this._elementRef.nativeElement.focus();\n        };\n    /**\n     * Blurs the native element.\n     * @return {?}\n     */\n    MatSlider.prototype._blurHostElement = /**\n     * Blurs the native element.\n     * @return {?}\n     */\n        function () {\n            this._elementRef.nativeElement.blur();\n        };\n    /**\n     * Sets the model value. Implemented as part of ControlValueAccessor.\n     * @param value\n     */\n    /**\n     * Sets the model value. Implemented as part of ControlValueAccessor.\n     * @param {?} value\n     * @return {?}\n     */\n    MatSlider.prototype.writeValue = /**\n     * Sets the model value. Implemented as part of ControlValueAccessor.\n     * @param {?} value\n     * @return {?}\n     */\n        function (value) {\n            this.value = value;\n        };\n    /**\n     * Registers a callback to eb triggered when the value has changed.\n     * Implemented as part of ControlValueAccessor.\n     * @param fn Callback to be registered.\n     */\n    /**\n     * Registers a callback to eb triggered when the value has changed.\n     * Implemented as part of ControlValueAccessor.\n     * @param {?} fn Callback to be registered.\n     * @return {?}\n     */\n    MatSlider.prototype.registerOnChange = /**\n     * Registers a callback to eb triggered when the value has changed.\n     * Implemented as part of ControlValueAccessor.\n     * @param {?} fn Callback to be registered.\n     * @return {?}\n     */\n        function (fn) {\n            this._controlValueAccessorChangeFn = fn;\n        };\n    /**\n     * Registers a callback to be triggered when the component is touched.\n     * Implemented as part of ControlValueAccessor.\n     * @param fn Callback to be registered.\n     */\n    /**\n     * Registers a callback to be triggered when the component is touched.\n     * Implemented as part of ControlValueAccessor.\n     * @param {?} fn Callback to be registered.\n     * @return {?}\n     */\n    MatSlider.prototype.registerOnTouched = /**\n     * Registers a callback to be triggered when the component is touched.\n     * Implemented as part of ControlValueAccessor.\n     * @param {?} fn Callback to be registered.\n     * @return {?}\n     */\n        function (fn) {\n            this.onTouched = fn;\n        };\n    /**\n     * Sets whether the component should be disabled.\n     * Implemented as part of ControlValueAccessor.\n     * @param isDisabled\n     */\n    /**\n     * Sets whether the component should be disabled.\n     * Implemented as part of ControlValueAccessor.\n     * @param {?} isDisabled\n     * @return {?}\n     */\n    MatSlider.prototype.setDisabledState = /**\n     * Sets whether the component should be disabled.\n     * Implemented as part of ControlValueAccessor.\n     * @param {?} isDisabled\n     * @return {?}\n     */\n        function (isDisabled) {\n            this.disabled = isDisabled;\n        };\n    return MatSlider;\n}(_MatSliderMixinBase));\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar MatSliderModule = /*@__PURE__*/ (function () {\n    function MatSliderModule() {\n    }\n    return MatSliderModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nexport { MatSliderModule, MAT_SLIDER_VALUE_ACCESSOR, MatSliderChange, MatSliderBase, _MatSliderMixinBase, MatSlider };\n//# sourceMappingURL=slider.es5.js.map\n",null]}