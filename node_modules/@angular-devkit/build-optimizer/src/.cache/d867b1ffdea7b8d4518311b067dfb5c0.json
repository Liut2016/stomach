{"remainingRequest":"/home/liutao/Project/0/oncology/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/home/liutao/Project/0/oncology/node_modules/ngx-store/src/decorator/cache-item.js","dependencies":[{"path":"/home/liutao/Project/0/oncology/node_modules/ngx-store/src/decorator/cache-item.js","mtime":1526508791000},{"path":"/home/liutao/Project/0/oncology/node_modules/cache-loader/dist/cjs.js","mtime":1539266424898},{"path":"/home/liutao/Project/0/oncology/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1526531406000}],"contextDependencies":[],"result":["import { Config, debug } from '../config/index';\nimport { Cache } from './cache';\nvar isEqual = require('lodash.isequal');\nvar CacheItem = /*@__PURE__*/ (function () {\n    function CacheItem(cacheItem) {\n        this.name = '';\n        this.targets = [];\n        this.services = [];\n        this.utilities = [];\n        this.proxy = null;\n        this._key = '';\n        this.initializedTargets = new Set();\n        this._key = cacheItem.key;\n        this.name = cacheItem.name;\n        this.addTargets(cacheItem.targets);\n        this.addServices(cacheItem.services);\n        this.addUtilities(cacheItem.utilities);\n    }\n    Object.defineProperty(CacheItem.prototype, \"key\", {\n        get: function () {\n            return this._key;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    CacheItem.prototype.saveValue = function (value, config, source) {\n        if (config === void 0) {\n            config = {};\n        }\n        debug.groupCollapsed('CacheItem#saveValue for ' + this.key + ' in ' + this.currentTarget.constructor.name);\n        debug.log('new value: ', value);\n        debug.log('previous value: ', this.readValue());\n        debug.log('targets.length: ', this.targets.length);\n        debug.log('currentTarget:', this.currentTarget);\n        debug.groupEnd();\n        // prevent overwriting value by initializators\n        if (!this.initializedTargets.has(this.currentTarget)) {\n            this.initializedTargets.add(this.currentTarget);\n            var readValue = this.readValue();\n            var savedValue = (readValue !== null && readValue !== undefined) ? readValue : value;\n            var proxy = this.getProxy(savedValue, config);\n            proxy = (proxy !== null) ? proxy : value;\n            debug.log('initial value for ' + this.key + ' in ' + this.currentTarget.constructor.name, proxy);\n            this.propagateChange(savedValue, source);\n            return proxy;\n        }\n        this.propagateChange(value, source);\n        return this.getProxy(value, config);\n    };\n    CacheItem.prototype.getProxy = function (value, config) {\n        if (config === void 0) {\n            config = {};\n        }\n        if (value === undefined && this.proxy)\n            return this.proxy; // return cached proxy if value hasn't changed\n        value = (value === undefined) ? this.readValue() : value;\n        if (typeof value !== 'object' || value === null) {\n            this.proxy = value;\n            return value;\n        }\n        if ((!Config.mutateObjects && !config.mutate) || config.mutate === false)\n            return value;\n        var _self = this; // alias to use in standard function expressions\n        var prototype = Object.assign(new value.constructor(), value.__proto__);\n        prototype.save = function () {\n            // add method for triggering force save\n            _self.saveValue(value, config);\n        };\n        // TODO set prototype for Array.prototype or something\n        if (Array.isArray(value)) {\n            // handle methods that could change value of array\n            var methodsToOverwrite = [\n                'pop', 'push', 'reverse', 'shift', 'unshift', 'splice',\n                'filter', 'forEach', 'map', 'fill', 'sort', 'copyWithin'\n            ];\n            var _loop_1 = function (method) {\n                prototype[method] = function () {\n                    var readValue = _self.readValue();\n                    var result = Array.prototype[method].apply(readValue, arguments);\n                    debug.log('Saving value for ' + _self.key + ' by method ' + prototype.constructor.name + '.' + method);\n                    _self.saveValue(readValue, config);\n                    return result;\n                };\n            };\n            for (var _i = 0, methodsToOverwrite_1 = methodsToOverwrite; _i < methodsToOverwrite_1.length; _i++) {\n                var method = methodsToOverwrite_1[_i];\n                _loop_1(method);\n            }\n        }\n        Object.setPrototypeOf(value, prototype);\n        this.proxy = value;\n        return value;\n    };\n    CacheItem.prototype.readValue = function (config) {\n        if (config === void 0) {\n            config = {};\n        }\n        var entry = this.utilities[0];\n        var value = entry ? entry.utility.get(this.key, entry.config) : null;\n        return (typeof value !== 'object') ? value : JSON.parse(JSON.stringify(this.getProxy(value, entry.config)));\n    };\n    CacheItem.prototype.addTargets = function (targets) {\n        var _this = this;\n        targets.forEach(function (target) {\n            if (_this.targets.indexOf(target) === -1) {\n                if (typeof target === 'object') {\n                    // handle Angular Component destruction\n                    var originalFunction_1 = target.ngOnDestroy;\n                    var _self_1 = _this;\n                    target.ngOnDestroy = function () {\n                        if (typeof originalFunction_1 === 'function') {\n                            originalFunction_1.apply(this, arguments);\n                        }\n                        target.ngOnDestroy = originalFunction_1 || function () { };\n                        _self_1.initializedTargets.delete(target);\n                        _self_1.targets = _self_1.targets.filter(function (t) { return t !== target; });\n                        if (!_self_1.targets.length) {\n                            _self_1.services.forEach(function (service) {\n                                service.keys = service.keys.filter(function (key) { return key !== _self_1._key; });\n                            });\n                            _self_1.resetProxy();\n                            Cache.remove(_self_1);\n                        }\n                        debug.groupCollapsed(_self_1.key + \" OnDestroy handler:\");\n                        debug.log('removed target:', target.constructor.name);\n                        debug.log('remaining targets:', _self_1.targets);\n                        debug.log('cacheItem:', Cache.get(_self_1.key));\n                        debug.groupEnd();\n                    };\n                    _this.targets.push(target);\n                }\n            }\n        });\n    };\n    CacheItem.prototype.addServices = function (services) {\n        var _this = this;\n        services.forEach(function (service) {\n            if (_this.services.indexOf(service) === -1) {\n                service.keys.push(_this._key);\n                _this.services.push(service);\n            }\n        });\n    };\n    CacheItem.prototype.addUtilities = function (utilityEntries) {\n        var _this = this;\n        utilityEntries.forEach(function (entry) {\n            if (_this.utilities.findIndex(function (e) { return e.utility === entry.utility; }) === -1) {\n                _this.utilities.push(entry);\n                entry.utility.set(_this.key, _this.readValue());\n            }\n        });\n    };\n    CacheItem.prototype.resetProxy = function () {\n        this.proxy = null;\n    };\n    CacheItem.prototype.propagateChange = function (value, source) {\n        var _this = this;\n        if (isEqual(value, this.readValue()))\n            return;\n        this.utilities.forEach(function (entry) {\n            var utility = entry.utility;\n            // updating service which the change came from would affect in a cycle\n            if (utility === source)\n                return;\n            debug.log(\"propagating change on \" + _this.key + \" to:\", utility);\n            utility.set(_this._key, value, entry.config);\n        });\n    };\n    return CacheItem;\n}());\nexport { CacheItem };\n//# sourceMappingURL=cache-item.js.map\n",null]}