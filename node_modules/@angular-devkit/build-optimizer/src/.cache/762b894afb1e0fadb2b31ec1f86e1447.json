{"remainingRequest":"/home/liutao/Project/0/oncology/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/home/liutao/Project/0/oncology/node_modules/@swimlane/ngx-datatable/release/components/body/body.component.js","dependencies":[{"path":"/home/liutao/Project/0/oncology/node_modules/@swimlane/ngx-datatable/release/components/body/body.component.js","mtime":1511963642000},{"path":"/home/liutao/Project/0/oncology/node_modules/cache-loader/dist/cjs.js","mtime":1539266424898},{"path":"/home/liutao/Project/0/oncology/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1526531406000}],"contextDependencies":[],"result":["\"use strict\";\nvar __decorate = /*@__PURE__*/ require(\"tslib\").__decorate;\nvar __metadata = /*@__PURE__*/ require(\"tslib\").__metadata;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar core_1 = require(\"@angular/core\");\nvar utils_1 = require(\"../../utils\");\nvar types_1 = require(\"../../types\");\nvar scroller_component_1 = require(\"./scroller.component\");\nvar DataTableBodyComponent = /*@__PURE__*/ (function () {\n    /**\n     * Creates an instance of DataTableBodyComponent.\n     */\n    function DataTableBodyComponent(cd) {\n        var _this = this;\n        this.cd = cd;\n        this.selected = [];\n        this.scroll = new core_1.EventEmitter();\n        this.page = new core_1.EventEmitter();\n        this.activate = new core_1.EventEmitter();\n        this.select = new core_1.EventEmitter();\n        this.detailToggle = new core_1.EventEmitter();\n        this.rowContextmenu = new core_1.EventEmitter(false);\n        this.rowHeightsCache = new utils_1.RowHeightCache();\n        this.temp = [];\n        this.offsetY = 0;\n        this.indexes = {};\n        this.rowIndexes = new Map();\n        this.rowExpansions = new Map();\n        /**\n         * Get the height of the detail row.\n         */\n        this.getDetailRowHeight = function (row, index) {\n            if (!_this.rowDetail)\n                return 0;\n            var rowHeight = _this.rowDetail.rowHeight;\n            return typeof rowHeight === 'function' ? rowHeight(row, index) : rowHeight;\n        };\n        // declare fn here so we can get access to the `this` property\n        this.rowTrackingFn = function (index, row) {\n            var idx = this.getRowIndex(row);\n            if (this.trackByProp) {\n                return idx + \"-\" + this.trackByProp;\n            }\n            else {\n                return idx;\n            }\n        }.bind(this);\n    }\n    Object.defineProperty(DataTableBodyComponent.prototype, \"pageSize\", {\n        get: function () {\n            return this._pageSize;\n        },\n        set: function (val) {\n            this._pageSize = val;\n            this.recalcLayout();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataTableBodyComponent.prototype, \"rows\", {\n        get: function () {\n            return this._rows;\n        },\n        set: function (val) {\n            this._rows = val;\n            this.rowExpansions.clear();\n            this.recalcLayout();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataTableBodyComponent.prototype, \"columns\", {\n        get: function () {\n            return this._columns;\n        },\n        set: function (val) {\n            this._columns = val;\n            var colsByPin = utils_1.columnsByPin(val);\n            this.columnGroupWidths = utils_1.columnGroupWidths(colsByPin, val);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataTableBodyComponent.prototype, \"offset\", {\n        get: function () {\n            return this._offset;\n        },\n        set: function (val) {\n            this._offset = val;\n            this.recalcLayout();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataTableBodyComponent.prototype, \"rowCount\", {\n        get: function () {\n            return this._rowCount;\n        },\n        set: function (val) {\n            this._rowCount = val;\n            this.recalcLayout();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataTableBodyComponent.prototype, \"bodyWidth\", {\n        get: function () {\n            if (this.scrollbarH) {\n                return this.innerWidth + 'px';\n            }\n            else {\n                return '100%';\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataTableBodyComponent.prototype, \"bodyHeight\", {\n        get: function () {\n            return this._bodyHeight;\n        },\n        set: function (val) {\n            if (this.scrollbarV) {\n                this._bodyHeight = val + 'px';\n            }\n            else {\n                this._bodyHeight = 'auto';\n            }\n            this.recalcLayout();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataTableBodyComponent.prototype, \"selectEnabled\", {\n        /**\n         * Returns if selection is enabled.\n         */\n        get: function () {\n            return !!this.selectionType;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataTableBodyComponent.prototype, \"scrollHeight\", {\n        /**\n         * Property that would calculate the height of scroll bar\n         * based on the row heights cache for virtual scroll. Other scenarios\n         * calculate scroll height automatically (as height will be undefined).\n         */\n        get: function () {\n            if (this.scrollbarV) {\n                return this.rowHeightsCache.query(this.rowCount - 1);\n            }\n            // avoid TS7030: Not all code paths return a value.\n            return undefined;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Called after the constructor, initializing input properties\n     */\n    DataTableBodyComponent.prototype.ngOnInit = function () {\n        var _this = this;\n        if (this.rowDetail) {\n            this.listener = this.rowDetail.toggle\n                .subscribe(function (_a) {\n                var type = _a.type, value = _a.value;\n                if (type === 'row')\n                    _this.toggleRowExpansion(value);\n                if (type === 'all')\n                    _this.toggleAllRows(value);\n                // Refresh rows after toggle\n                // Fixes #883\n                _this.updateIndexes();\n                _this.updateRows();\n                _this.cd.markForCheck();\n            });\n        }\n        if (this.groupHeader) {\n            this.listener = this.groupHeader.toggle\n                .subscribe(function (_a) {\n                var type = _a.type, value = _a.value;\n                if (type === 'group')\n                    _this.toggleRowExpansion(value);\n                if (type === 'all')\n                    _this.toggleAllRows(value);\n                // Refresh rows after toggle\n                // Fixes #883\n                _this.updateIndexes();\n                _this.updateRows();\n                _this.cd.markForCheck();\n            });\n        }\n    };\n    /**\n     * Called once, before the instance is destroyed.\n     */\n    DataTableBodyComponent.prototype.ngOnDestroy = function () {\n        if (this.rowDetail)\n            this.listener.unsubscribe();\n        if (this.groupHeader)\n            this.listener.unsubscribe();\n    };\n    /**\n     * Updates the Y offset given a new offset.\n     */\n    DataTableBodyComponent.prototype.updateOffsetY = function (offset) {\n        // scroller is missing on empty table\n        if (!this.scroller)\n            return;\n        if (this.scrollbarV && offset) {\n            // First get the row Index that we need to move to.\n            var rowIndex = this.pageSize * offset;\n            offset = this.rowHeightsCache.query(rowIndex - 1);\n        }\n        this.scroller.setOffset(offset || 0);\n    };\n    /**\n     * Body was scrolled, this is mainly useful for\n     * when a user is server-side pagination via virtual scroll.\n     */\n    DataTableBodyComponent.prototype.onBodyScroll = function (event) {\n        var scrollYPos = event.scrollYPos;\n        var scrollXPos = event.scrollXPos;\n        // if scroll change, trigger update\n        // this is mainly used for header cell positions\n        if (this.offsetY !== scrollYPos || this.offsetX !== scrollXPos) {\n            this.scroll.emit({\n                offsetY: scrollYPos,\n                offsetX: scrollXPos\n            });\n        }\n        this.offsetY = scrollYPos;\n        this.offsetX = scrollXPos;\n        this.updateIndexes();\n        this.updatePage(event.direction);\n        this.updateRows();\n    };\n    /**\n     * Updates the page given a direction.\n     */\n    DataTableBodyComponent.prototype.updatePage = function (direction) {\n        var offset = this.indexes.first / this.pageSize;\n        if (direction === 'up') {\n            offset = Math.ceil(offset);\n        }\n        else if (direction === 'down') {\n            offset = Math.floor(offset);\n        }\n        if (direction !== undefined && !isNaN(offset)) {\n            this.page.emit({ offset: offset });\n        }\n    };\n    /**\n     * Updates the rows in the view port\n     */\n    DataTableBodyComponent.prototype.updateRows = function () {\n        var _a = this.indexes, first = _a.first, last = _a.last;\n        var rowIndex = first;\n        var idx = 0;\n        var temp = [];\n        this.rowIndexes.clear();\n        // if grouprowsby has been specified treat row paging \n        // parameters as group paging parameters ie if limit 10 has been \n        // specified treat it as 10 groups rather than 10 rows    \n        if (this.groupedRows) {\n            var maxRowsPerGroup = 3;\n            // if there is only one group set the maximum number of \n            // rows per group the same as the total number of rows\n            if (this.groupedRows.length === 1) {\n                maxRowsPerGroup = this.groupedRows[0].value.length;\n            }\n            while (rowIndex < last && rowIndex < this.groupedRows.length) {\n                // Add the groups into this page\n                var group = this.groupedRows[rowIndex];\n                temp[idx] = group;\n                idx++;\n                // Group index in this context\n                rowIndex++;\n            }\n        }\n        else {\n            while (rowIndex < last && rowIndex < this.rowCount) {\n                var row = this.rows[rowIndex];\n                if (row) {\n                    this.rowIndexes.set(row, rowIndex);\n                    temp[idx] = row;\n                }\n                idx++;\n                rowIndex++;\n            }\n        }\n        this.temp = temp;\n        this.cd.detectChanges();\n    };\n    /**\n     * Get the row height\n     */\n    DataTableBodyComponent.prototype.getRowHeight = function (row) {\n        var rowHeight = this.rowHeight;\n        // if its a function return it\n        if (typeof this.rowHeight === 'function') {\n            rowHeight = this.rowHeight(row);\n        }\n        return rowHeight;\n    };\n    /**\n     * @param group the group with all rows\n     */\n    DataTableBodyComponent.prototype.getGroupHeight = function (group) {\n        var rowHeight = 0;\n        if (group.value) {\n            for (var index = 0; index < group.value.length; index++) {\n                rowHeight += this.getRowAndDetailHeight(group.value[index]);\n            }\n        }\n        return rowHeight;\n    };\n    /**\n     * Calculate row height based on the expanded state of the row.\n     */\n    DataTableBodyComponent.prototype.getRowAndDetailHeight = function (row) {\n        var rowHeight = this.getRowHeight(row);\n        var expanded = this.rowExpansions.get(row);\n        // Adding detail row height if its expanded.\n        if (expanded === 1) {\n            rowHeight += this.getDetailRowHeight(row);\n        }\n        return rowHeight;\n    };\n    /**\n     * Calculates the styles for the row so that the rows can be moved in 2D space\n     * during virtual scroll inside the DOM.   In the below case the Y position is\n     * manipulated.   As an example, if the height of row 0 is 30 px and row 1 is\n     * 100 px then following styles are generated:\n     *\n     * transform: translate3d(0px, 0px, 0px);    ->  row0\n     * transform: translate3d(0px, 30px, 0px);   ->  row1\n     * transform: translate3d(0px, 130px, 0px);  ->  row2\n     *\n     * Row heights have to be calculated based on the row heights cache as we wont\n     * be able to determine which row is of what height before hand.  In the above\n     * case the positionY of the translate3d for row2 would be the sum of all the\n     * heights of the rows before it (i.e. row0 and row1).\n     *\n     * @param {*} rows The row that needs to be placed in the 2D space.\n     * @returns {*} Returns the CSS3 style to be applied\n     *\n     * @memberOf DataTableBodyComponent\n     */\n    DataTableBodyComponent.prototype.getRowsStyles = function (rows) {\n        var styles = {};\n        // only add styles for the group if there is a group\n        if (this.groupedRows) {\n            styles['width'] = this.columnGroupWidths.total;\n        }\n        if (this.scrollbarV) {\n            var idx = 0;\n            if (this.groupedRows) {\n                // Get the latest row rowindex in a group\n                var row = rows[rows.length - 1];\n                idx = row ? this.getRowIndex(row) : 0;\n            }\n            else {\n                idx = this.getRowIndex(rows);\n            }\n            // const pos = idx * rowHeight;\n            // The position of this row would be the sum of all row heights\n            // until the previous row position.\n            var pos = this.rowHeightsCache.query(idx - 1);\n            utils_1.translateXY(styles, 0, pos);\n        }\n        return styles;\n    };\n    /**\n     * Hides the loading indicator\n     */\n    DataTableBodyComponent.prototype.hideIndicator = function () {\n        var _this = this;\n        setTimeout(function () { return _this.loadingIndicator = false; }, 500);\n    };\n    /**\n     * Updates the index of the rows in the viewport\n     */\n    DataTableBodyComponent.prototype.updateIndexes = function () {\n        var first = 0;\n        var last = 0;\n        if (this.scrollbarV) {\n            // Calculation of the first and last indexes will be based on where the\n            // scrollY position would be at.  The last index would be the one\n            // that shows up inside the view port the last.\n            var height = parseInt(this.bodyHeight, 0);\n            first = this.rowHeightsCache.getRowIndex(this.offsetY);\n            last = this.rowHeightsCache.getRowIndex(height + this.offsetY) + 1;\n        }\n        else {\n            // The server is handling paging and will pass an array that begins with the\n            // element at a specified offset.  first should always be 0 with external paging.\n            if (!this.externalPaging) {\n                first = Math.max(this.offset * this.pageSize, 0);\n            }\n            last = Math.min((first + this.pageSize), this.rowCount);\n        }\n        this.indexes = { first: first, last: last };\n    };\n    /**\n     * Refreshes the full Row Height cache.  Should be used\n     * when the entire row array state has changed.\n     */\n    DataTableBodyComponent.prototype.refreshRowHeightCache = function () {\n        if (!this.scrollbarV)\n            return;\n        // clear the previous row height cache if already present.\n        // this is useful during sorts, filters where the state of the\n        // rows array is changed.\n        this.rowHeightsCache.clearCache();\n        // Initialize the tree only if there are rows inside the tree.\n        if (this.rows && this.rows.length) {\n            this.rowHeightsCache.initCache({\n                rows: this.rows,\n                rowHeight: this.rowHeight,\n                detailRowHeight: this.getDetailRowHeight,\n                externalVirtual: this.scrollbarV && this.externalPaging,\n                rowCount: this.rowCount,\n                rowIndexes: this.rowIndexes,\n                rowExpansions: this.rowExpansions\n            });\n        }\n    };\n    /**\n     * Gets the index for the view port\n     */\n    DataTableBodyComponent.prototype.getAdjustedViewPortIndex = function () {\n        // Capture the row index of the first row that is visible on the viewport.\n        // If the scroll bar is just below the row which is highlighted then make that as the\n        // first index.\n        var viewPortFirstRowIndex = this.indexes.first;\n        if (this.scrollbarV) {\n            var offsetScroll = this.rowHeightsCache.query(viewPortFirstRowIndex - 1);\n            return offsetScroll <= this.offsetY ? viewPortFirstRowIndex - 1 : viewPortFirstRowIndex;\n        }\n        return viewPortFirstRowIndex;\n    };\n    /**\n     * Toggle the Expansion of the row i.e. if the row is expanded then it will\n     * collapse and vice versa.   Note that the expanded status is stored as\n     * a part of the row object itself as we have to preserve the expanded row\n     * status in case of sorting and filtering of the row set.\n     */\n    DataTableBodyComponent.prototype.toggleRowExpansion = function (row) {\n        // Capture the row index of the first row that is visible on the viewport.\n        var viewPortFirstRowIndex = this.getAdjustedViewPortIndex();\n        var expanded = this.rowExpansions.get(row);\n        // If the detailRowHeight is auto --> only in case of non-virtualized scroll\n        if (this.scrollbarV) {\n            var detailRowHeight = this.getDetailRowHeight(row) * (expanded ? -1 : 1);\n            // const idx = this.rowIndexes.get(row) || 0;\n            var idx = this.getRowIndex(row);\n            this.rowHeightsCache.update(idx, detailRowHeight);\n        }\n        // Update the toggled row and update thive nevere heights in the cache.\n        expanded = expanded ^= 1;\n        this.rowExpansions.set(row, expanded);\n        this.detailToggle.emit({\n            rows: [row],\n            currentIndex: viewPortFirstRowIndex\n        });\n    };\n    /**\n     * Expand/Collapse all the rows no matter what their state is.\n     */\n    DataTableBodyComponent.prototype.toggleAllRows = function (expanded) {\n        // clear prev expansions\n        this.rowExpansions.clear();\n        var rowExpanded = expanded ? 1 : 0;\n        // Capture the row index of the first row that is visible on the viewport.\n        var viewPortFirstRowIndex = this.getAdjustedViewPortIndex();\n        for (var _i = 0, _a = this.rows; _i < _a.length; _i++) {\n            var row = _a[_i];\n            this.rowExpansions.set(row, rowExpanded);\n        }\n        if (this.scrollbarV) {\n            // Refresh the full row heights cache since every row was affected.\n            this.recalcLayout();\n        }\n        // Emit all rows that have been expanded.\n        this.detailToggle.emit({\n            rows: this.rows,\n            currentIndex: viewPortFirstRowIndex\n        });\n    };\n    /**\n     * Recalculates the table\n     */\n    DataTableBodyComponent.prototype.recalcLayout = function () {\n        this.refreshRowHeightCache();\n        this.updateIndexes();\n        this.updateRows();\n    };\n    /**\n     * Tracks the column\n     */\n    DataTableBodyComponent.prototype.columnTrackingFn = function (index, column) {\n        return column.$$id;\n    };\n    /**\n     * Gets the row pinning group styles\n     */\n    DataTableBodyComponent.prototype.stylesByGroup = function (group) {\n        var widths = this.columnGroupWidths;\n        var offsetX = this.offsetX;\n        var styles = {\n            width: widths[group] + \"px\"\n        };\n        if (group === 'left') {\n            utils_1.translateXY(styles, offsetX, 0);\n        }\n        else if (group === 'right') {\n            var bodyWidth = parseInt(this.innerWidth + '', 0);\n            var totalDiff = widths.total - bodyWidth;\n            var offsetDiff = totalDiff - offsetX;\n            var offset = offsetDiff * -1;\n            utils_1.translateXY(styles, offset, 0);\n        }\n        return styles;\n    };\n    /**\n     * Returns if the row was expanded and set default row expansion when row expansion is empty\n     */\n    DataTableBodyComponent.prototype.getRowExpanded = function (row) {\n        if (this.rowExpansions.size === 0 && this.groupExpansionDefault) {\n            for (var _i = 0, _a = this.groupedRows; _i < _a.length; _i++) {\n                var group = _a[_i];\n                this.rowExpansions.set(group, 1);\n            }\n        }\n        var expanded = this.rowExpansions.get(row);\n        return expanded === 1;\n    };\n    /**\n     * Gets the row index given a row\n     */\n    DataTableBodyComponent.prototype.getRowIndex = function (row) {\n        return this.rowIndexes.get(row) || 0;\n    };\n    __decorate([\n        core_1.Input(),\n        __metadata(\"design:type\", Boolean)\n    ], DataTableBodyComponent.prototype, \"scrollbarV\", void 0);\n    __decorate([\n        core_1.Input(),\n        __metadata(\"design:type\", Boolean)\n    ], DataTableBodyComponent.prototype, \"scrollbarH\", void 0);\n    __decorate([\n        core_1.Input(),\n        __metadata(\"design:type\", Boolean)\n    ], DataTableBodyComponent.prototype, \"loadingIndicator\", void 0);\n    __decorate([\n        core_1.Input(),\n        __metadata(\"design:type\", Boolean)\n    ], DataTableBodyComponent.prototype, \"externalPaging\", void 0);\n    __decorate([\n        core_1.Input(),\n        __metadata(\"design:type\", Number)\n    ], DataTableBodyComponent.prototype, \"rowHeight\", void 0);\n    __decorate([\n        core_1.Input(),\n        __metadata(\"design:type\", Number)\n    ], DataTableBodyComponent.prototype, \"offsetX\", void 0);\n    __decorate([\n        core_1.Input(),\n        __metadata(\"design:type\", String)\n    ], DataTableBodyComponent.prototype, \"emptyMessage\", void 0);\n    __decorate([\n        core_1.Input(),\n        __metadata(\"design:type\", String)\n    ], DataTableBodyComponent.prototype, \"selectionType\", void 0);\n    __decorate([\n        core_1.Input(),\n        __metadata(\"design:type\", Array)\n    ], DataTableBodyComponent.prototype, \"selected\", void 0);\n    __decorate([\n        core_1.Input(),\n        __metadata(\"design:type\", Object)\n    ], DataTableBodyComponent.prototype, \"rowIdentity\", void 0);\n    __decorate([\n        core_1.Input(),\n        __metadata(\"design:type\", Object)\n    ], DataTableBodyComponent.prototype, \"rowDetail\", void 0);\n    __decorate([\n        core_1.Input(),\n        __metadata(\"design:type\", Object)\n    ], DataTableBodyComponent.prototype, \"groupHeader\", void 0);\n    __decorate([\n        core_1.Input(),\n        __metadata(\"design:type\", Object)\n    ], DataTableBodyComponent.prototype, \"selectCheck\", void 0);\n    __decorate([\n        core_1.Input(),\n        __metadata(\"design:type\", Object)\n    ], DataTableBodyComponent.prototype, \"displayCheck\", void 0);\n    __decorate([\n        core_1.Input(),\n        __metadata(\"design:type\", String)\n    ], DataTableBodyComponent.prototype, \"trackByProp\", void 0);\n    __decorate([\n        core_1.Input(),\n        __metadata(\"design:type\", Object)\n    ], DataTableBodyComponent.prototype, \"rowClass\", void 0);\n    __decorate([\n        core_1.Input(),\n        __metadata(\"design:type\", Object)\n    ], DataTableBodyComponent.prototype, \"groupedRows\", void 0);\n    __decorate([\n        core_1.Input(),\n        __metadata(\"design:type\", Boolean)\n    ], DataTableBodyComponent.prototype, \"groupExpansionDefault\", void 0);\n    __decorate([\n        core_1.Input(),\n        __metadata(\"design:type\", Number)\n    ], DataTableBodyComponent.prototype, \"innerWidth\", void 0);\n    __decorate([\n        core_1.Input(),\n        __metadata(\"design:type\", String)\n    ], DataTableBodyComponent.prototype, \"groupRowsBy\", void 0);\n    __decorate([\n        core_1.Input(),\n        __metadata(\"design:type\", Number),\n        __metadata(\"design:paramtypes\", [Number])\n    ], DataTableBodyComponent.prototype, \"pageSize\", null);\n    __decorate([\n        core_1.Input(),\n        __metadata(\"design:type\", Array),\n        __metadata(\"design:paramtypes\", [Array])\n    ], DataTableBodyComponent.prototype, \"rows\", null);\n    __decorate([\n        core_1.Input(),\n        __metadata(\"design:type\", Array),\n        __metadata(\"design:paramtypes\", [Array])\n    ], DataTableBodyComponent.prototype, \"columns\", null);\n    __decorate([\n        core_1.Input(),\n        __metadata(\"design:type\", Number),\n        __metadata(\"design:paramtypes\", [Number])\n    ], DataTableBodyComponent.prototype, \"offset\", null);\n    __decorate([\n        core_1.Input(),\n        __metadata(\"design:type\", Number),\n        __metadata(\"design:paramtypes\", [Number])\n    ], DataTableBodyComponent.prototype, \"rowCount\", null);\n    __decorate([\n        core_1.HostBinding('style.width'),\n        __metadata(\"design:type\", String),\n        __metadata(\"design:paramtypes\", [])\n    ], DataTableBodyComponent.prototype, \"bodyWidth\", null);\n    __decorate([\n        core_1.Input(),\n        core_1.HostBinding('style.height'),\n        __metadata(\"design:type\", Object),\n        __metadata(\"design:paramtypes\", [Object])\n    ], DataTableBodyComponent.prototype, \"bodyHeight\", null);\n    __decorate([\n        core_1.Output(),\n        __metadata(\"design:type\", core_1.EventEmitter)\n    ], DataTableBodyComponent.prototype, \"scroll\", void 0);\n    __decorate([\n        core_1.Output(),\n        __metadata(\"design:type\", core_1.EventEmitter)\n    ], DataTableBodyComponent.prototype, \"page\", void 0);\n    __decorate([\n        core_1.Output(),\n        __metadata(\"design:type\", core_1.EventEmitter)\n    ], DataTableBodyComponent.prototype, \"activate\", void 0);\n    __decorate([\n        core_1.Output(),\n        __metadata(\"design:type\", core_1.EventEmitter)\n    ], DataTableBodyComponent.prototype, \"select\", void 0);\n    __decorate([\n        core_1.Output(),\n        __metadata(\"design:type\", core_1.EventEmitter)\n    ], DataTableBodyComponent.prototype, \"detailToggle\", void 0);\n    __decorate([\n        core_1.Output(),\n        __metadata(\"design:type\", Object)\n    ], DataTableBodyComponent.prototype, \"rowContextmenu\", void 0);\n    __decorate([\n        core_1.ViewChild(scroller_component_1.ScrollerComponent),\n        __metadata(\"design:type\", scroller_component_1.ScrollerComponent)\n    ], DataTableBodyComponent.prototype, \"scroller\", void 0);\n    DataTableBodyComponent = __decorate([\n        core_1.Component({\n            selector: 'datatable-body',\n            template: \"\\n    <datatable-selection\\n      #selector\\n      [selected]=\\\"selected\\\"\\n      [rows]=\\\"rows\\\"\\n      [selectCheck]=\\\"selectCheck\\\"\\n      [selectEnabled]=\\\"selectEnabled\\\"\\n      [selectionType]=\\\"selectionType\\\"\\n      [rowIdentity]=\\\"rowIdentity\\\"\\n      (select)=\\\"select.emit($event)\\\"\\n      (activate)=\\\"activate.emit($event)\\\">\\n      <datatable-progress\\n        *ngIf=\\\"loadingIndicator\\\">\\n      </datatable-progress>\\n      <datatable-scroller\\n        *ngIf=\\\"rows?.length\\\"\\n        [scrollbarV]=\\\"scrollbarV\\\"\\n        [scrollbarH]=\\\"scrollbarH\\\"\\n        [scrollHeight]=\\\"scrollHeight\\\"\\n        [scrollWidth]=\\\"columnGroupWidths?.total\\\"\\n        (scroll)=\\\"onBodyScroll($event)\\\">\\n        <datatable-row-wrapper\\n          [groupedRows]=\\\"groupedRows\\\"\\n          *ngFor=\\\"let group of temp; let i = index; trackBy: rowTrackingFn;\\\"\\n          [innerWidth]=\\\"innerWidth\\\"\\n          [ngStyle]=\\\"getRowsStyles(group)\\\"\\n          [rowDetail]=\\\"rowDetail\\\"\\n          [groupHeader]=\\\"groupHeader\\\"\\n          [offsetX]=\\\"offsetX\\\"\\n          [detailRowHeight]=\\\"getDetailRowHeight(group[i],i)\\\"\\n          [row]=\\\"group\\\"\\n          [expanded]=\\\"getRowExpanded(group)\\\"\\n          [rowIndex]=\\\"getRowIndex(group[i])\\\"\\n          (rowContextmenu)=\\\"rowContextmenu.emit($event)\\\">\\n          <datatable-body-row \\n            *ngIf=\\\"!groupedRows; else groupedRowsTemplate\\\"        \\n            tabindex=\\\"-1\\\"\\n            [isSelected]=\\\"selector.getRowSelected(group)\\\"\\n            [innerWidth]=\\\"innerWidth\\\"\\n            [offsetX]=\\\"offsetX\\\"\\n            [columns]=\\\"columns\\\"\\n            [rowHeight]=\\\"getRowHeight(group)\\\"\\n            [row]=\\\"group\\\"\\n            [rowIndex]=\\\"getRowIndex(group)\\\"\\n            [expanded]=\\\"getRowExpanded(group)\\\"            \\n            [rowClass]=\\\"rowClass\\\"\\n            [displayCheck]=\\\"displayCheck\\\"\\n            (activate)=\\\"selector.onActivate($event, indexes.first + i)\\\">\\n          </datatable-body-row>\\n          <ng-template #groupedRowsTemplate>\\n            <datatable-body-row\\n              *ngFor=\\\"let row of group.value; let i = index; trackBy: rowTrackingFn;\\\"\\n              tabindex=\\\"-1\\\"\\n              [isSelected]=\\\"selector.getRowSelected(row)\\\"\\n              [innerWidth]=\\\"innerWidth\\\"\\n              [offsetX]=\\\"offsetX\\\"\\n              [columns]=\\\"columns\\\"\\n              [rowHeight]=\\\"getRowHeight(row)\\\"\\n              [row]=\\\"row\\\"\\n              [group]=\\\"group.value\\\"\\n              [rowIndex]=\\\"getRowIndex(row)\\\"\\n              [expanded]=\\\"getRowExpanded(row)\\\"\\n              [rowClass]=\\\"rowClass\\\"\\n              (activate)=\\\"selector.onActivate($event, i)\\\">\\n            </datatable-body-row>\\n          </ng-template>\\n        </datatable-row-wrapper>\\n      </datatable-scroller>\\n      <div\\n        class=\\\"empty-row\\\"\\n        *ngIf=\\\"!rows?.length && !loadingIndicator\\\"\\n        [innerHTML]=\\\"emptyMessage\\\">\\n      </div>\\n    </datatable-selection>\\n  \",\n            changeDetection: core_1.ChangeDetectionStrategy.OnPush,\n            host: {\n                class: 'datatable-body'\n            }\n        })\n    ], DataTableBodyComponent);\n    return DataTableBodyComponent;\n}());\nexports.DataTableBodyComponent = DataTableBodyComponent;\n",null]}