{"remainingRequest":"/home/liutao/Project/0/oncology/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/home/liutao/Project/0/oncology/node_modules/@angular/cdk/esm5/observers.es5.js","dependencies":[{"path":"/home/liutao/Project/0/oncology/node_modules/@angular/cdk/esm5/observers.es5.js","mtime":1526940964000},{"path":"/home/liutao/Project/0/oncology/node_modules/cache-loader/dist/cjs.js","mtime":1539266424898},{"path":"/home/liutao/Project/0/oncology/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1526531406000}],"contextDependencies":[],"result":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** PURE_IMPORTS_START _angular_cdk_coercion,_angular_core,rxjs,rxjs_operators PURE_IMPORTS_END */\nimport { coerceBooleanProperty, coerceNumberProperty } from '@angular/cdk/coercion';\nimport { Directive, ElementRef, EventEmitter, Injectable, Input, NgModule, NgZone, Output, defineInjectable, inject } from '@angular/core';\nimport { Observable, Subject } from 'rxjs';\nimport { debounceTime } from 'rxjs/operators';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Factory that creates a new MutationObserver and allows us to stub it out in unit tests.\n * \\@docs-private\n */\nvar MutationObserverFactory = /*@__PURE__*/ (function () {\n    function MutationObserverFactory() {\n    }\n    /**\n     * @param {?} callback\n     * @return {?}\n     */\n    MutationObserverFactory.prototype.create = /**\n     * @param {?} callback\n     * @return {?}\n     */\n        function (callback) {\n            return typeof MutationObserver === 'undefined' ? null : new MutationObserver(callback);\n        };\n    /** @nocollapse */ MutationObserverFactory.ngInjectableDef = defineInjectable({ factory: function MutationObserverFactory_Factory() { return new MutationObserverFactory(); }, token: MutationObserverFactory, providedIn: \"root\" });\n    return MutationObserverFactory;\n}());\n/**\n * An injectable service that allows watching elements for changes to their content.\n */\nvar ContentObserver = /*@__PURE__*/ (function () {\n    function ContentObserver(_mutationObserverFactory) {\n        this._mutationObserverFactory = _mutationObserverFactory;\n        /**\n         * Keeps track of the existing MutationObservers so they can be reused.\n         */\n        this._observedElements = new Map();\n    }\n    /**\n     * @return {?}\n     */\n    ContentObserver.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            this._observedElements.forEach(function (_, element) { return _this._cleanupObserver(element); });\n        };\n    /**\n     * Observe content changes on an element.\n     * @param element The element to observe for content changes.\n     */\n    /**\n     * Observe content changes on an element.\n     * @param {?} element The element to observe for content changes.\n     * @return {?}\n     */\n    ContentObserver.prototype.observe = /**\n     * Observe content changes on an element.\n     * @param {?} element The element to observe for content changes.\n     * @return {?}\n     */\n        function (element) {\n            var _this = this;\n            return Observable.create(function (observer) {\n                var /** @type {?} */ stream = _this._observeElement(element);\n                var /** @type {?} */ subscription = stream.subscribe(observer);\n                return function () {\n                    subscription.unsubscribe();\n                    _this._unobserveElement(element);\n                };\n            });\n        };\n    /**\n     * Observes the given element by using the existing MutationObserver if available, or creating a\n     * new one if not.\n     * @param {?} element\n     * @return {?}\n     */\n    ContentObserver.prototype._observeElement = /**\n     * Observes the given element by using the existing MutationObserver if available, or creating a\n     * new one if not.\n     * @param {?} element\n     * @return {?}\n     */\n        function (element) {\n            if (!this._observedElements.has(element)) {\n                var /** @type {?} */ stream_1 = new Subject();\n                var /** @type {?} */ observer = this._mutationObserverFactory.create(function (mutations) { return stream_1.next(mutations); });\n                if (observer) {\n                    observer.observe(element, {\n                        characterData: true,\n                        childList: true,\n                        subtree: true\n                    });\n                }\n                this._observedElements.set(element, { observer: observer, stream: stream_1, count: 1 });\n            }\n            else {\n                /** @type {?} */ ((this._observedElements.get(element))).count++;\n            }\n            return /** @type {?} */ ((this._observedElements.get(element))).stream;\n        };\n    /**\n     * Un-observes the given element and cleans up the underlying MutationObserver if nobody else is\n     * observing this element.\n     * @param {?} element\n     * @return {?}\n     */\n    ContentObserver.prototype._unobserveElement = /**\n     * Un-observes the given element and cleans up the underlying MutationObserver if nobody else is\n     * observing this element.\n     * @param {?} element\n     * @return {?}\n     */\n        function (element) {\n            if (this._observedElements.has(element)) {\n                /** @type {?} */ ((this._observedElements.get(element))).count--;\n                if (!((this._observedElements.get(element))).count) {\n                    this._cleanupObserver(element);\n                }\n            }\n        };\n    /**\n     * Clean up the underlying MutationObserver for the specified element.\n     * @param {?} element\n     * @return {?}\n     */\n    ContentObserver.prototype._cleanupObserver = /**\n     * Clean up the underlying MutationObserver for the specified element.\n     * @param {?} element\n     * @return {?}\n     */\n        function (element) {\n            if (this._observedElements.has(element)) {\n                var _a = ((this._observedElements.get(element))), observer = _a.observer, stream = _a.stream;\n                if (observer) {\n                    observer.disconnect();\n                }\n                stream.complete();\n                this._observedElements.delete(element);\n            }\n        };\n    /** @nocollapse */ ContentObserver.ngInjectableDef = defineInjectable({ factory: function ContentObserver_Factory() { return new ContentObserver(inject(MutationObserverFactory)); }, token: ContentObserver, providedIn: \"root\" });\n    return ContentObserver;\n}());\n/**\n * Directive that triggers a callback whenever the content of\n * its associated element has changed.\n */\nvar CdkObserveContent = /*@__PURE__*/ (function () {\n    function CdkObserveContent(_contentObserver, _elementRef, _ngZone) {\n        this._contentObserver = _contentObserver;\n        this._elementRef = _elementRef;\n        this._ngZone = _ngZone;\n        /**\n         * Event emitted for each change in the element's content.\n         */\n        this.event = new EventEmitter();\n        this._disabled = false;\n        this._currentSubscription = null;\n    }\n    Object.defineProperty(CdkObserveContent.prototype, \"disabled\", {\n        get: /**\n         * Whether observing content is disabled. This option can be used\n         * to disconnect the underlying MutationObserver until it is needed.\n         * @return {?}\n         */ function () { return this._disabled; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._disabled = coerceBooleanProperty(value);\n            if (this._disabled) {\n                this._unsubscribe();\n            }\n            else {\n                this._subscribe();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkObserveContent.prototype, \"debounce\", {\n        get: /**\n         * Debounce interval for emitting the changes.\n         * @return {?}\n         */ function () { return this._debounce; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._debounce = coerceNumberProperty(value);\n            this._subscribe();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    CdkObserveContent.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n        function () {\n            if (!this._currentSubscription && !this.disabled) {\n                this._subscribe();\n            }\n        };\n    /**\n     * @return {?}\n     */\n    CdkObserveContent.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            this._unsubscribe();\n        };\n    /**\n     * @return {?}\n     */\n    CdkObserveContent.prototype._subscribe = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            this._unsubscribe();\n            var /** @type {?} */ stream = this._contentObserver.observe(this._elementRef.nativeElement);\n            // TODO(mmalerba): We shouldn't be emitting on this @Output() outside the zone.\n            // Consider brining it back inside the zone next time we're making breaking changes.\n            // Bringing it back inside can cause things like infinite change detection loops and changed\n            // after checked errors if people's code isn't handling it properly.\n            this._ngZone.runOutsideAngular(function () {\n                _this._currentSubscription =\n                    (_this.debounce ? stream.pipe(debounceTime(_this.debounce)) : stream).subscribe(_this.event);\n            });\n        };\n    /**\n     * @return {?}\n     */\n    CdkObserveContent.prototype._unsubscribe = /**\n     * @return {?}\n     */\n        function () {\n            if (this._currentSubscription) {\n                this._currentSubscription.unsubscribe();\n            }\n        };\n    return CdkObserveContent;\n}());\nvar ObserversModule = /*@__PURE__*/ (function () {\n    function ObserversModule() {\n    }\n    return ObserversModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nexport { MutationObserverFactory, ContentObserver, CdkObserveContent, ObserversModule };\n//# sourceMappingURL=observers.es5.js.map\n",null]}