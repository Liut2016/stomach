{"remainingRequest":"/home/liutao/Project/0/oncology/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/home/liutao/Project/0/oncology/node_modules/@swimlane/ngx-datatable/release/utils/sort.js","dependencies":[{"path":"/home/liutao/Project/0/oncology/node_modules/@swimlane/ngx-datatable/release/utils/sort.js","mtime":1511963642000},{"path":"/home/liutao/Project/0/oncology/node_modules/cache-loader/dist/cjs.js","mtime":1539266424898},{"path":"/home/liutao/Project/0/oncology/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1526531406000}],"contextDependencies":[],"result":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar types_1 = require(\"../types\");\nvar column_prop_getters_1 = require(\"./column-prop-getters\");\n/**\n * Gets the next sort direction\n */\nfunction nextSortDir(sortType, current) {\n    if (sortType === types_1.SortType.single) {\n        if (current === types_1.SortDirection.asc) {\n            return types_1.SortDirection.desc;\n        }\n        else {\n            return types_1.SortDirection.asc;\n        }\n    }\n    else {\n        if (!current) {\n            return types_1.SortDirection.asc;\n        }\n        else if (current === types_1.SortDirection.asc) {\n            return types_1.SortDirection.desc;\n        }\n        else if (current === types_1.SortDirection.desc) {\n            return undefined;\n        }\n        // avoid TS7030: Not all code paths return a value.\n        return undefined;\n    }\n}\nexports.nextSortDir = nextSortDir;\n/**\n * Adapted from fueld-ui on 6/216\n * https://github.com/FuelInteractive/fuel-ui/tree/master/src/pipes/OrderBy\n */\nfunction orderByComparator(a, b) {\n    if (a === null || typeof a === 'undefined')\n        a = 0;\n    if (b === null || typeof b === 'undefined')\n        b = 0;\n    if (a instanceof Date && b instanceof Date) {\n        if (a < b)\n            return -1;\n        if (a > b)\n            return 1;\n    }\n    else if ((isNaN(parseFloat(a)) || !isFinite(a)) || (isNaN(parseFloat(b)) || !isFinite(b))) {\n        // Convert to string in case of a=0 or b=0\n        a = String(a);\n        b = String(b);\n        // Isn't a number so lowercase the string to properly compare\n        if (a.toLowerCase() < b.toLowerCase())\n            return -1;\n        if (a.toLowerCase() > b.toLowerCase())\n            return 1;\n    }\n    else {\n        // Parse strings as numbers to compare properly\n        if (parseFloat(a) < parseFloat(b))\n            return -1;\n        if (parseFloat(a) > parseFloat(b))\n            return 1;\n    }\n    // equal each other\n    return 0;\n}\nexports.orderByComparator = orderByComparator;\n/**\n * Sorts the rows\n */\nfunction sortRows(rows, columns, dirs) {\n    if (!rows)\n        return [];\n    if (!dirs || !dirs.length || !columns)\n        return rows.slice();\n    /**\n     * create a mapping from each row to its row index prior to sorting\n     */\n    var rowToIndexMap = new Map();\n    rows.forEach(function (row, index) { return rowToIndexMap.set(row, index); });\n    var temp = rows.slice();\n    var cols = columns.reduce(function (obj, col) {\n        if (col.comparator && typeof col.comparator === 'function') {\n            obj[col.prop] = col.comparator;\n        }\n        return obj;\n    }, {});\n    // cache valueGetter and compareFn so that they\n    // do not need to be looked-up in the sort function body\n    var cachedDirs = dirs.map(function (dir) {\n        var prop = dir.prop;\n        return {\n            prop: prop,\n            dir: dir.dir,\n            valueGetter: column_prop_getters_1.getterForProp(prop),\n            compareFn: cols[prop] || orderByComparator\n        };\n    });\n    return temp.sort(function (rowA, rowB) {\n        for (var _i = 0, cachedDirs_1 = cachedDirs; _i < cachedDirs_1.length; _i++) {\n            var cachedDir = cachedDirs_1[_i];\n            // Get property and valuegetters for column to be sorted\n            var prop = cachedDir.prop, valueGetter = cachedDir.valueGetter;\n            // Get A and B cell values from rows based on properties of the columns\n            var propA = valueGetter(rowA, prop);\n            var propB = valueGetter(rowB, prop);\n            // Compare function gets five parameters:\n            // Two cell values to be compared as propA and propB\n            // Two rows corresponding to the cells as rowA and rowB\n            // Direction of the sort for this column as SortDirection\n            // Compare can be a standard JS comparison function (a,b) => -1|0|1\n            // as additional parameters are silently ignored. The whole row and sort\n            // direction enable more complex sort logic.\n            var comparison = cachedDir.dir !== types_1.SortDirection.desc ?\n                cachedDir.compareFn(propA, propB, rowA, rowB, cachedDir.dir) :\n                -cachedDir.compareFn(propA, propB, rowA, rowB, cachedDir.dir);\n            // Don't return 0 yet in case of needing to sort by next property\n            if (comparison !== 0)\n                return comparison;\n        }\n        /**\n         * all else being equal, preserve original order of the rows (stable sort)\n         */\n        return rowToIndexMap.get(rowA) < rowToIndexMap.get(rowB) ? -1 : 1;\n    });\n}\nexports.sortRows = sortRows;\n//# sourceMappingURL=sort.js.map",null]}