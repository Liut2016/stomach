{"remainingRequest":"/home/liutao/Project/0/oncology/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/home/liutao/Project/0/oncology/node_modules/@angular/material/esm5/chips.es5.js","dependencies":[{"path":"/home/liutao/Project/0/oncology/node_modules/@angular/material/esm5/chips.es5.js","mtime":1526941038000},{"path":"/home/liutao/Project/0/oncology/node_modules/cache-loader/dist/cjs.js","mtime":1539266424898},{"path":"/home/liutao/Project/0/oncology/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1526531406000}],"contextDependencies":[],"result":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** PURE_IMPORTS_START tslib,_angular_cdk_coercion,_angular_cdk_keycodes,_angular_cdk_platform,_angular_core,_angular_material_core,rxjs,_angular_cdk_a11y,_angular_cdk_bidi,_angular_cdk_collections,_angular_forms,_angular_material_form_field,rxjs_operators PURE_IMPORTS_END */\nimport { __extends } from 'tslib';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { BACKSPACE, DELETE, SPACE, ENTER } from '@angular/cdk/keycodes';\nimport { Platform } from '@angular/cdk/platform';\nimport { ContentChild, Directive, ElementRef, EventEmitter, forwardRef, Inject, Input, NgZone, Optional, Output, InjectionToken, ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChildren, Self, ViewEncapsulation, NgModule } from '@angular/core';\nimport { MAT_RIPPLE_GLOBAL_OPTIONS, mixinColor, mixinDisabled, mixinDisableRipple, RippleRenderer, ErrorStateMatcher, mixinErrorState } from '@angular/material/core';\nimport { Subject, merge, Subscription } from 'rxjs';\nimport { FocusKeyManager } from '@angular/cdk/a11y';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { SelectionModel } from '@angular/cdk/collections';\nimport { FormGroupDirective, NgControl, NgForm } from '@angular/forms';\nimport { MatFormFieldControl } from '@angular/material/form-field';\nimport { startWith } from 'rxjs/operators';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Event object emitted by MatChip when selected or deselected.\n */\nvar /**\n * Event object emitted by MatChip when selected or deselected.\n */ MatChipSelectionChange = /*@__PURE__*/ (function () {\n    function MatChipSelectionChange(source, selected, isUserInput) {\n        if (isUserInput === void 0) {\n            isUserInput = false;\n        }\n        this.source = source;\n        this.selected = selected;\n        this.isUserInput = isUserInput;\n    }\n    return MatChipSelectionChange;\n}());\n/**\n * \\@docs-private\n */\nvar /**\n * \\@docs-private\n */ MatChipBase = /*@__PURE__*/ (function () {\n    function MatChipBase(_elementRef) {\n        this._elementRef = _elementRef;\n    }\n    return MatChipBase;\n}());\nvar /** @type {?} */ _MatChipMixinBase = /*@__PURE__*/ mixinColor(/*@__PURE__*/ mixinDisableRipple(/*@__PURE__*/ mixinDisabled(MatChipBase)), 'primary');\nvar /** @type {?} */ CHIP_ATTRIBUTE_NAMES = ['mat-basic-chip'];\n/**\n * Dummy directive to add CSS class to chip avatar.\n * \\@docs-private\n */\nvar MatChipAvatar = /*@__PURE__*/ (function () {\n    function MatChipAvatar() {\n    }\n    return MatChipAvatar;\n}());\n/**\n * Dummy directive to add CSS class to chip trailing icon.\n * \\@docs-private\n */\nvar MatChipTrailingIcon = /*@__PURE__*/ (function () {\n    function MatChipTrailingIcon() {\n    }\n    return MatChipTrailingIcon;\n}());\n/**\n * Material design styled Chip component. Used inside the MatChipList component.\n */\nvar MatChip = /*@__PURE__*/ (function (_super) {\n    __extends(MatChip, _super);\n    function MatChip(_elementRef, ngZone, platform, globalOptions) {\n        var _this = _super.call(this, _elementRef) || this;\n        _this._elementRef = _elementRef;\n        /**\n         * Ripple configuration for ripples that are launched on pointer down.\n         * \\@docs-private\n         */\n        _this.rippleConfig = {};\n        /**\n         * Whether the chip has focus.\n         */\n        _this._hasFocus = false;\n        /**\n         * Whether the chip list is selectable\n         */\n        _this.chipListSelectable = true;\n        _this._selected = false;\n        _this._selectable = true;\n        _this._removable = true;\n        /**\n         * Emits when the chip is focused.\n         */\n        _this._onFocus = new Subject();\n        /**\n         * Emits when the chip is blured.\n         */\n        _this._onBlur = new Subject();\n        /**\n         * Emitted when the chip is selected or deselected.\n         */\n        _this.selectionChange = new EventEmitter();\n        /**\n         * Emitted when the chip is destroyed.\n         */\n        _this.destroyed = new EventEmitter();\n        /**\n         * Emitted when a chip is to be removed.\n         */\n        _this.removed = new EventEmitter();\n        _this._addHostClassName();\n        _this._chipRipple = new RippleRenderer(_this, ngZone, _elementRef, platform);\n        _this._chipRipple.setupTriggerEvents(_elementRef.nativeElement);\n        if (globalOptions) {\n            _this.rippleConfig = {\n                speedFactor: globalOptions.baseSpeedFactor,\n                animation: globalOptions.animation,\n                terminateOnPointerUp: globalOptions.terminateOnPointerUp,\n            };\n        }\n        return _this;\n    }\n    Object.defineProperty(MatChip.prototype, \"rippleDisabled\", {\n        /**\n         * Whether ripples are disabled on interaction\n         * @docs-private\n         */\n        get: /**\n         * Whether ripples are disabled on interaction\n         * \\@docs-private\n         * @return {?}\n         */ function () {\n            return this.disabled || this.disableRipple;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChip.prototype, \"selected\", {\n        get: /**\n         * Whether the chip is selected.\n         * @return {?}\n         */ function () { return this._selected; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._selected = coerceBooleanProperty(value);\n            this.selectionChange.emit({\n                source: this,\n                isUserInput: false,\n                selected: value\n            });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChip.prototype, \"value\", {\n        get: /**\n         * The value of the chip. Defaults to the content inside `<mat-chip>` tags.\n         * @return {?}\n         */ function () {\n            return this._value != undefined\n                ? this._value\n                : this._elementRef.nativeElement.textContent;\n        },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) { this._value = value; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChip.prototype, \"selectable\", {\n        get: /**\n         * Whether or not the chip is selectable. When a chip is not selectable,\n         * changes to it's selected state are always ignored. By default a chip is\n         * selectable, and it becomes non-selectable if it's parent chip list is\n         * not selectable.\n         * @return {?}\n         */ function () { return this._selectable && this.chipListSelectable; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._selectable = coerceBooleanProperty(value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChip.prototype, \"removable\", {\n        get: /**\n         * Determines whether or not the chip displays the remove styling and emits (removed) events.\n         * @return {?}\n         */ function () { return this._removable; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._removable = coerceBooleanProperty(value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChip.prototype, \"ariaSelected\", {\n        /** The ARIA selected applied to the chip. */\n        get: /**\n         * The ARIA selected applied to the chip.\n         * @return {?}\n         */ function () {\n            return this.selectable ? this.selected.toString() : null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    MatChip.prototype._addHostClassName = /**\n     * @return {?}\n     */\n        function () {\n            // Add class for the different chips\n            for (var _i = 0, CHIP_ATTRIBUTE_NAMES_1 = CHIP_ATTRIBUTE_NAMES; _i < CHIP_ATTRIBUTE_NAMES_1.length; _i++) {\n                var attr = CHIP_ATTRIBUTE_NAMES_1[_i];\n                if (this._elementRef.nativeElement.hasAttribute(attr) ||\n                    this._elementRef.nativeElement.tagName.toLowerCase() === attr) {\n                    ((this._elementRef.nativeElement)).classList.add(attr);\n                    return;\n                }\n            }\n            ((this._elementRef.nativeElement)).classList.add('mat-standard-chip');\n        };\n    /**\n     * @return {?}\n     */\n    MatChip.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            this.destroyed.emit({ chip: this });\n            this._chipRipple._removeTriggerEvents();\n        };\n    /** Selects the chip. */\n    /**\n     * Selects the chip.\n     * @return {?}\n     */\n    MatChip.prototype.select = /**\n     * Selects the chip.\n     * @return {?}\n     */\n        function () {\n            this._selected = true;\n            this.selectionChange.emit({\n                source: this,\n                isUserInput: false,\n                selected: true\n            });\n        };\n    /** Deselects the chip. */\n    /**\n     * Deselects the chip.\n     * @return {?}\n     */\n    MatChip.prototype.deselect = /**\n     * Deselects the chip.\n     * @return {?}\n     */\n        function () {\n            this._selected = false;\n            this.selectionChange.emit({\n                source: this,\n                isUserInput: false,\n                selected: false\n            });\n        };\n    /** Select this chip and emit selected event */\n    /**\n     * Select this chip and emit selected event\n     * @return {?}\n     */\n    MatChip.prototype.selectViaInteraction = /**\n     * Select this chip and emit selected event\n     * @return {?}\n     */\n        function () {\n            this._selected = true;\n            // Emit select event when selected changes.\n            this.selectionChange.emit({\n                source: this,\n                isUserInput: true,\n                selected: true\n            });\n        };\n    /** Toggles the current selected state of this chip. */\n    /**\n     * Toggles the current selected state of this chip.\n     * @param {?=} isUserInput\n     * @return {?}\n     */\n    MatChip.prototype.toggleSelected = /**\n     * Toggles the current selected state of this chip.\n     * @param {?=} isUserInput\n     * @return {?}\n     */\n        function (isUserInput) {\n            if (isUserInput === void 0) {\n                isUserInput = false;\n            }\n            this._selected = !this.selected;\n            this.selectionChange.emit({\n                source: this,\n                isUserInput: isUserInput,\n                selected: this._selected\n            });\n            return this.selected;\n        };\n    /** Allows for programmatic focusing of the chip. */\n    /**\n     * Allows for programmatic focusing of the chip.\n     * @return {?}\n     */\n    MatChip.prototype.focus = /**\n     * Allows for programmatic focusing of the chip.\n     * @return {?}\n     */\n        function () {\n            if (!this._hasFocus) {\n                this._elementRef.nativeElement.focus();\n                this._onFocus.next({ chip: this });\n            }\n            this._hasFocus = true;\n        };\n    /**\n     * Allows for programmatic removal of the chip. Called by the MatChipList when the DELETE or\n     * BACKSPACE keys are pressed.\n     *\n     * Informs any listeners of the removal request. Does not remove the chip from the DOM.\n     */\n    /**\n     * Allows for programmatic removal of the chip. Called by the MatChipList when the DELETE or\n     * BACKSPACE keys are pressed.\n     *\n     * Informs any listeners of the removal request. Does not remove the chip from the DOM.\n     * @return {?}\n     */\n    MatChip.prototype.remove = /**\n     * Allows for programmatic removal of the chip. Called by the MatChipList when the DELETE or\n     * BACKSPACE keys are pressed.\n     *\n     * Informs any listeners of the removal request. Does not remove the chip from the DOM.\n     * @return {?}\n     */\n        function () {\n            if (this.removable) {\n                this.removed.emit({ chip: this });\n            }\n        };\n    /** Ensures events fire properly upon click. */\n    /**\n     * Ensures events fire properly upon click.\n     * @param {?} event\n     * @return {?}\n     */\n    MatChip.prototype._handleClick = /**\n     * Ensures events fire properly upon click.\n     * @param {?} event\n     * @return {?}\n     */\n        function (event) {\n            // Check disabled\n            if (this.disabled) {\n                return;\n            }\n            event.preventDefault();\n            event.stopPropagation();\n        };\n    /** Handle custom key presses. */\n    /**\n     * Handle custom key presses.\n     * @param {?} event\n     * @return {?}\n     */\n    MatChip.prototype._handleKeydown = /**\n     * Handle custom key presses.\n     * @param {?} event\n     * @return {?}\n     */\n        function (event) {\n            if (this.disabled) {\n                return;\n            }\n            switch (event.keyCode) {\n                case DELETE:\n                case BACKSPACE:\n                    // If we are removable, remove the focused chip\n                    this.remove();\n                    // Always prevent so page navigation does not occur\n                    event.preventDefault();\n                    break;\n                case SPACE:\n                    // If we are selectable, toggle the focused chip\n                    if (this.selectable) {\n                        this.toggleSelected(true);\n                    }\n                    // Always prevent space from scrolling the page since the list has focus\n                    event.preventDefault();\n                    break;\n            }\n        };\n    /**\n     * @return {?}\n     */\n    MatChip.prototype._blur = /**\n     * @return {?}\n     */\n        function () {\n            this._hasFocus = false;\n            this._onBlur.next({ chip: this });\n        };\n    return MatChip;\n}(_MatChipMixinBase));\n/**\n * Applies proper (click) support and adds styling for use with the Material Design \"cancel\" icon\n * available at https://material.io/icons/#ic_cancel.\n *\n * Example:\n *\n *     `<mat-chip>\n *       <mat-icon matChipRemove>cancel</mat-icon>\n *     </mat-chip>`\n *\n * You *may* use a custom icon, but you may need to override the `mat-chip-remove` positioning\n * styles to properly center the icon within the chip.\n */\nvar MatChipRemove = /*@__PURE__*/ (function () {\n    function MatChipRemove(_parentChip) {\n        this._parentChip = _parentChip;\n    }\n    /** Calls the parent chip's public `remove()` method if applicable. */\n    /**\n     * Calls the parent chip's public `remove()` method if applicable.\n     * @return {?}\n     */\n    MatChipRemove.prototype._handleClick = /**\n     * Calls the parent chip's public `remove()` method if applicable.\n     * @return {?}\n     */\n        function () {\n            if (this._parentChip.removable) {\n                this._parentChip.remove();\n            }\n        };\n    return MatChipRemove;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Injection token to be used to override the default options for the chips module.\n */\nvar /** @type {?} */ MAT_CHIPS_DEFAULT_OPTIONS = /*@__PURE__*/ new InjectionToken('mat-chips-default-options');\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * \\@docs-private\n */\nvar /**\n * \\@docs-private\n */ MatChipListBase = /*@__PURE__*/ (function () {\n    function MatChipListBase(_defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl) {\n        this._defaultErrorStateMatcher = _defaultErrorStateMatcher;\n        this._parentForm = _parentForm;\n        this._parentFormGroup = _parentFormGroup;\n        this.ngControl = ngControl;\n    }\n    return MatChipListBase;\n}());\nvar /** @type {?} */ _MatChipListMixinBase = /*@__PURE__*/ mixinErrorState(MatChipListBase);\n// Increasing integer for generating unique ids for chip-list components.\nvar /** @type {?} */ nextUniqueId = 0;\n/**\n * Change event object that is emitted when the chip list value has changed.\n */\nvar /**\n * Change event object that is emitted when the chip list value has changed.\n */ MatChipListChange = /*@__PURE__*/ (function () {\n    function MatChipListChange(source, value) {\n        this.source = source;\n        this.value = value;\n    }\n    return MatChipListChange;\n}());\n/**\n * A material design chips component (named ChipList for it's similarity to the List component).\n */\nvar MatChipList = /*@__PURE__*/ (function (_super) {\n    __extends(MatChipList, _super);\n    function MatChipList(_elementRef, _changeDetectorRef, _dir, _parentForm, _parentFormGroup, _defaultErrorStateMatcher, /** @docs-private */ ngControl) {\n        var _this = _super.call(this, _defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl) || this;\n        _this._elementRef = _elementRef;\n        _this._changeDetectorRef = _changeDetectorRef;\n        _this._dir = _dir;\n        _this.ngControl = ngControl;\n        /**\n         * Implemented as part of MatFormFieldControl.\n         * \\@docs-private\n         */\n        _this.controlType = 'mat-chip-list';\n        /**\n         * When a chip is destroyed, we track the index so we can focus the appropriate next chip.\n         */\n        _this._lastDestroyedIndex = null;\n        /**\n         * Track which chips we're listening to for focus/destruction.\n         */\n        _this._chipSet = new WeakMap();\n        /**\n         * Subscription to tabbing out from the chip list.\n         */\n        _this._tabOutSubscription = Subscription.EMPTY;\n        /**\n         * Uid of the chip list\n         */\n        _this._uid = \"mat-chip-list-\" + nextUniqueId++;\n        /**\n         * Tab index for the chip list.\n         */\n        _this._tabIndex = 0;\n        /**\n         * User defined tab index.\n         * When it is not null, use user defined tab index. Otherwise use _tabIndex\n         */\n        _this._userTabIndex = null;\n        /**\n         * Function when touched\n         */\n        _this._onTouched = function () { };\n        /**\n         * Function when changed\n         */\n        _this._onChange = function () { };\n        _this._multiple = false;\n        _this._compareWith = function (o1, o2) { return o1 === o2; };\n        _this._required = false;\n        _this._disabled = false;\n        /**\n         * Orientation of the chip list.\n         */\n        _this.ariaOrientation = 'horizontal';\n        _this._selectable = true;\n        /**\n         * Event emitted when the selected chip list value has been changed by the user.\n         */\n        _this.change = new EventEmitter();\n        /**\n         * Event that emits whenever the raw value of the chip-list changes. This is here primarily\n         * to facilitate the two-way binding for the `value` input.\n         * \\@docs-private\n         */\n        _this.valueChange = new EventEmitter();\n        if (_this.ngControl) {\n            _this.ngControl.valueAccessor = _this;\n        }\n        return _this;\n    }\n    Object.defineProperty(MatChipList.prototype, \"selected\", {\n        /** The array of selected chips inside chip list. */\n        get: /**\n         * The array of selected chips inside chip list.\n         * @return {?}\n         */ function () {\n            return this.multiple ? this._selectionModel.selected : this._selectionModel.selected[0];\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChipList.prototype, \"role\", {\n        /** The ARIA role applied to the chip list. */\n        get: /**\n         * The ARIA role applied to the chip list.\n         * @return {?}\n         */ function () { return this.empty ? null : 'listbox'; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChipList.prototype, \"multiple\", {\n        get: /**\n         * Whether the user should be allowed to select multiple chips.\n         * @return {?}\n         */ function () { return this._multiple; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._multiple = coerceBooleanProperty(value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChipList.prototype, \"compareWith\", {\n        get: /**\n         * A function to compare the option values with the selected values. The first argument\n         * is a value from an option. The second is a value from the selection. A boolean\n         * should be returned.\n         * @return {?}\n         */ function () { return this._compareWith; },\n        set: /**\n         * @param {?} fn\n         * @return {?}\n         */ function (fn) {\n            this._compareWith = fn;\n            if (this._selectionModel) {\n                // A different comparator means the selection could change.\n                this._initializeSelection();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChipList.prototype, \"value\", {\n        get: /**\n         * Implemented as part of MatFormFieldControl.\n         * \\@docs-private\n         * @return {?}\n         */ function () { return this._value; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this.writeValue(value);\n            this._value = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChipList.prototype, \"id\", {\n        /**\n         * Implemented as part of MatFormFieldControl.\n         * @docs-private\n         */\n        get: /**\n         * Implemented as part of MatFormFieldControl.\n         * \\@docs-private\n         * @return {?}\n         */ function () {\n            return this._chipInput ? this._chipInput.id : this._uid;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChipList.prototype, \"required\", {\n        get: /**\n         * Implemented as part of MatFormFieldControl.\n         * \\@docs-private\n         * @return {?}\n         */ function () { return this._required; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._required = coerceBooleanProperty(value);\n            this.stateChanges.next();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChipList.prototype, \"placeholder\", {\n        get: /**\n         * Implemented as part of MatFormFieldControl.\n         * \\@docs-private\n         * @return {?}\n         */ function () {\n            return this._chipInput ? this._chipInput.placeholder : this._placeholder;\n        },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._placeholder = value;\n            this.stateChanges.next();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChipList.prototype, \"focused\", {\n        /** Whether any chips or the matChipInput inside of this chip-list has focus. */\n        get: /**\n         * Whether any chips or the matChipInput inside of this chip-list has focus.\n         * @return {?}\n         */ function () {\n            return this.chips.some(function (chip) { return chip._hasFocus; }) ||\n                (this._chipInput && this._chipInput.focused);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChipList.prototype, \"empty\", {\n        /**\n         * Implemented as part of MatFormFieldControl.\n         * @docs-private\n         */\n        get: /**\n         * Implemented as part of MatFormFieldControl.\n         * \\@docs-private\n         * @return {?}\n         */ function () {\n            return (!this._chipInput || this._chipInput.empty) && this.chips.length === 0;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChipList.prototype, \"shouldLabelFloat\", {\n        /**\n         * Implemented as part of MatFormFieldControl.\n         * @docs-private\n         */\n        get: /**\n         * Implemented as part of MatFormFieldControl.\n         * \\@docs-private\n         * @return {?}\n         */ function () { return !this.empty || this.focused; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChipList.prototype, \"disabled\", {\n        get: /**\n         * Implemented as part of MatFormFieldControl.\n         * \\@docs-private\n         * @return {?}\n         */ function () { return this.ngControl ? !!this.ngControl.disabled : this._disabled; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) { this._disabled = coerceBooleanProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChipList.prototype, \"selectable\", {\n        get: /**\n         * Whether or not this chip list is selectable. When a chip list is not selectable,\n         * the selected states for all the chips inside the chip list are always ignored.\n         * @return {?}\n         */ function () { return this._selectable; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            var _this = this;\n            this._selectable = coerceBooleanProperty(value);\n            if (this.chips) {\n                this.chips.forEach(function (chip) { return chip.chipListSelectable = _this._selectable; });\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChipList.prototype, \"tabIndex\", {\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._userTabIndex = value;\n            this._tabIndex = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChipList.prototype, \"chipSelectionChanges\", {\n        /** Combined stream of all of the child chips' selection change events. */\n        get: /**\n         * Combined stream of all of the child chips' selection change events.\n         * @return {?}\n         */ function () {\n            return merge.apply(void 0, this.chips.map(function (chip) { return chip.selectionChange; }));\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChipList.prototype, \"chipFocusChanges\", {\n        /** Combined stream of all of the child chips' focus change events. */\n        get: /**\n         * Combined stream of all of the child chips' focus change events.\n         * @return {?}\n         */ function () {\n            return merge.apply(void 0, this.chips.map(function (chip) { return chip._onFocus; }));\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChipList.prototype, \"chipBlurChanges\", {\n        /** Combined stream of all of the child chips' blur change events. */\n        get: /**\n         * Combined stream of all of the child chips' blur change events.\n         * @return {?}\n         */ function () {\n            return merge.apply(void 0, this.chips.map(function (chip) { return chip._onBlur; }));\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChipList.prototype, \"chipRemoveChanges\", {\n        /** Combined stream of all of the child chips' remove change events. */\n        get: /**\n         * Combined stream of all of the child chips' remove change events.\n         * @return {?}\n         */ function () {\n            return merge.apply(void 0, this.chips.map(function (chip) { return chip.destroyed; }));\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    MatChipList.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            this._keyManager = new FocusKeyManager(this.chips)\n                .withWrap()\n                .withVerticalOrientation()\n                .withHorizontalOrientation(this._dir ? this._dir.value : 'ltr');\n            // Prevents the chip list from capturing focus and redirecting\n            // it back to the first chip when the user tabs out.\n            this._tabOutSubscription = this._keyManager.tabOut.subscribe(function () {\n                _this._tabIndex = -1;\n                setTimeout(function () { return _this._tabIndex = _this._userTabIndex || 0; });\n            });\n            // When the list changes, re-subscribe\n            this._changeSubscription = this.chips.changes.pipe(startWith(null)).subscribe(function () {\n                _this._resetChips();\n                // Reset chips selected/deselected status\n                // Reset chips selected/deselected status\n                _this._initializeSelection();\n                // Check to see if we need to update our tab index\n                // Check to see if we need to update our tab index\n                _this._updateTabIndex();\n                // Check to see if we have a destroyed chip and need to refocus\n                // Check to see if we have a destroyed chip and need to refocus\n                _this._updateFocusForDestroyedChips();\n                _this.stateChanges.next();\n            });\n        };\n    /**\n     * @return {?}\n     */\n    MatChipList.prototype.ngOnInit = /**\n     * @return {?}\n     */\n        function () {\n            this._selectionModel = new SelectionModel(this.multiple, undefined, false);\n            this.stateChanges.next();\n        };\n    /**\n     * @return {?}\n     */\n    MatChipList.prototype.ngDoCheck = /**\n     * @return {?}\n     */\n        function () {\n            if (this.ngControl) {\n                // We need to re-evaluate this on every change detection cycle, because there are some\n                // error triggers that we can't subscribe to (e.g. parent form submissions). This means\n                // that whatever logic is in here has to be super lean or we risk destroying the performance.\n                this.updateErrorState();\n            }\n        };\n    /**\n     * @return {?}\n     */\n    MatChipList.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            this._tabOutSubscription.unsubscribe();\n            if (this._changeSubscription) {\n                this._changeSubscription.unsubscribe();\n            }\n            if (this._chipRemoveSubscription) {\n                this._chipRemoveSubscription.unsubscribe();\n            }\n            this._dropSubscriptions();\n            this.stateChanges.complete();\n        };\n    /** Associates an HTML input element with this chip list. */\n    /**\n     * Associates an HTML input element with this chip list.\n     * @param {?} inputElement\n     * @return {?}\n     */\n    MatChipList.prototype.registerInput = /**\n     * Associates an HTML input element with this chip list.\n     * @param {?} inputElement\n     * @return {?}\n     */\n        function (inputElement) {\n            this._chipInput = inputElement;\n        };\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     * @param {?} ids\n     * @return {?}\n     */\n    MatChipList.prototype.setDescribedByIds = /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     * @param {?} ids\n     * @return {?}\n     */\n        function (ids) { this._ariaDescribedby = ids.join(' '); };\n    // Implemented as part of ControlValueAccessor.\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    MatChipList.prototype.writeValue = /**\n     * @param {?} value\n     * @return {?}\n     */\n        function (value) {\n            if (this.chips) {\n                this._setSelectionByValue(value, false);\n            }\n        };\n    // Implemented as part of ControlValueAccessor.\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    MatChipList.prototype.registerOnChange = /**\n     * @param {?} fn\n     * @return {?}\n     */\n        function (fn) {\n            this._onChange = fn;\n        };\n    // Implemented as part of ControlValueAccessor.\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    MatChipList.prototype.registerOnTouched = /**\n     * @param {?} fn\n     * @return {?}\n     */\n        function (fn) {\n            this._onTouched = fn;\n        };\n    // Implemented as part of ControlValueAccessor.\n    /**\n     * @param {?} isDisabled\n     * @return {?}\n     */\n    MatChipList.prototype.setDisabledState = /**\n     * @param {?} isDisabled\n     * @return {?}\n     */\n        function (isDisabled) {\n            this.disabled = isDisabled;\n            this._elementRef.nativeElement.disabled = isDisabled;\n            this.stateChanges.next();\n        };\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     * @return {?}\n     */\n    MatChipList.prototype.onContainerClick = /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     * @return {?}\n     */\n        function () { this.focus(); };\n    /**\n     * Focuses the the first non-disabled chip in this chip list, or the associated input when there\n     * are no eligible chips.\n     */\n    /**\n     * Focuses the the first non-disabled chip in this chip list, or the associated input when there\n     * are no eligible chips.\n     * @return {?}\n     */\n    MatChipList.prototype.focus = /**\n     * Focuses the the first non-disabled chip in this chip list, or the associated input when there\n     * are no eligible chips.\n     * @return {?}\n     */\n        function () {\n            // TODO: ARIA says this should focus the first `selected` chip if any are selected.\n            // Focus on first element if there's no chipInput inside chip-list\n            if (this._chipInput && this._chipInput.focused) {\n                // do nothing\n            }\n            else if (this.chips.length > 0) {\n                this._keyManager.setFirstItemActive();\n                this.stateChanges.next();\n            }\n            else {\n                this._focusInput();\n                this.stateChanges.next();\n            }\n        };\n    /** Attempt to focus an input if we have one. */\n    /**\n     * Attempt to focus an input if we have one.\n     * @return {?}\n     */\n    MatChipList.prototype._focusInput = /**\n     * Attempt to focus an input if we have one.\n     * @return {?}\n     */\n        function () {\n            if (this._chipInput) {\n                this._chipInput.focus();\n            }\n        };\n    /**\n     * Pass events to the keyboard manager. Available here for tests.\n     */\n    /**\n     * Pass events to the keyboard manager. Available here for tests.\n     * @param {?} event\n     * @return {?}\n     */\n    MatChipList.prototype._keydown = /**\n     * Pass events to the keyboard manager. Available here for tests.\n     * @param {?} event\n     * @return {?}\n     */\n        function (event) {\n            var /** @type {?} */ target = (event.target);\n            // If they are on an empty input and hit backspace, focus the last chip\n            if (event.keyCode === BACKSPACE && this._isInputEmpty(target)) {\n                this._keyManager.setLastItemActive();\n                event.preventDefault();\n            }\n            else if (target && target.classList.contains('mat-chip')) {\n                this._keyManager.onKeydown(event);\n                this.stateChanges.next();\n            }\n        };\n    /**\n     * Check the tab index as you should not be allowed to focus an empty list.\n     */\n    /**\n     * Check the tab index as you should not be allowed to focus an empty list.\n     * @return {?}\n     */\n    MatChipList.prototype._updateTabIndex = /**\n     * Check the tab index as you should not be allowed to focus an empty list.\n     * @return {?}\n     */\n        function () {\n            // If we have 0 chips, we should not allow keyboard focus\n            this._tabIndex = this._userTabIndex || (this.chips.length === 0 ? -1 : 0);\n        };\n    /**\n     * Update key manager's active item when chip is deleted.\n     * If the deleted chip is the last chip in chip list, focus the new last chip.\n     * Otherwise focus the next chip in the list.\n     * Save `_lastDestroyedIndex` so we can set the correct focus.\n     */\n    /**\n     * Update key manager's active item when chip is deleted.\n     * If the deleted chip is the last chip in chip list, focus the new last chip.\n     * Otherwise focus the next chip in the list.\n     * Save `_lastDestroyedIndex` so we can set the correct focus.\n     * @param {?} chip\n     * @return {?}\n     */\n    MatChipList.prototype._updateKeyManager = /**\n     * Update key manager's active item when chip is deleted.\n     * If the deleted chip is the last chip in chip list, focus the new last chip.\n     * Otherwise focus the next chip in the list.\n     * Save `_lastDestroyedIndex` so we can set the correct focus.\n     * @param {?} chip\n     * @return {?}\n     */\n        function (chip) {\n            var /** @type {?} */ chipIndex = this.chips.toArray().indexOf(chip);\n            if (this._isValidIndex(chipIndex)) {\n                if (chip._hasFocus) {\n                    // Check whether the chip is not the last item\n                    if (chipIndex < this.chips.length - 1) {\n                        this._keyManager.setActiveItem(chipIndex);\n                    }\n                    else if (chipIndex - 1 >= 0) {\n                        this._keyManager.setActiveItem(chipIndex - 1);\n                    }\n                }\n                if (this._keyManager.activeItemIndex === chipIndex) {\n                    this._lastDestroyedIndex = chipIndex;\n                }\n            }\n        };\n    /**\n     * Checks to see if a focus chip was recently destroyed so that we can refocus the next closest\n     * one.\n     */\n    /**\n     * Checks to see if a focus chip was recently destroyed so that we can refocus the next closest\n     * one.\n     * @return {?}\n     */\n    MatChipList.prototype._updateFocusForDestroyedChips = /**\n     * Checks to see if a focus chip was recently destroyed so that we can refocus the next closest\n     * one.\n     * @return {?}\n     */\n        function () {\n            var /** @type {?} */ chipsArray = this.chips;\n            if (this._lastDestroyedIndex != null && chipsArray.length > 0 && this.focused) {\n                // Check whether the destroyed chip was the last item\n                var /** @type {?} */ newFocusIndex = Math.min(this._lastDestroyedIndex, chipsArray.length - 1);\n                this._keyManager.setActiveItem(newFocusIndex);\n                var /** @type {?} */ focusChip = this._keyManager.activeItem;\n                // Focus the chip\n                if (focusChip) {\n                    focusChip.focus();\n                }\n            }\n            // Reset our destroyed index\n            this._lastDestroyedIndex = null;\n        };\n    /**\n     * Utility to ensure all indexes are valid.\n     *\n     * @param {?} index The index to be checked.\n     * @return {?} True if the index is valid for our list of chips.\n     */\n    MatChipList.prototype._isValidIndex = /**\n     * Utility to ensure all indexes are valid.\n     *\n     * @param {?} index The index to be checked.\n     * @return {?} True if the index is valid for our list of chips.\n     */\n        function (index) {\n            return index >= 0 && index < this.chips.length;\n        };\n    /**\n     * @param {?} element\n     * @return {?}\n     */\n    MatChipList.prototype._isInputEmpty = /**\n     * @param {?} element\n     * @return {?}\n     */\n        function (element) {\n            if (element && element.nodeName.toLowerCase() === 'input') {\n                var /** @type {?} */ input = (element);\n                return !input.value;\n            }\n            return false;\n        };\n    /**\n     * @param {?} value\n     * @param {?=} isUserInput\n     * @return {?}\n     */\n    MatChipList.prototype._setSelectionByValue = /**\n     * @param {?} value\n     * @param {?=} isUserInput\n     * @return {?}\n     */\n        function (value, isUserInput) {\n            var _this = this;\n            if (isUserInput === void 0) {\n                isUserInput = true;\n            }\n            this._clearSelection();\n            this.chips.forEach(function (chip) { return chip.deselect(); });\n            if (Array.isArray(value)) {\n                value.forEach(function (currentValue) { return _this._selectValue(currentValue, isUserInput); });\n                this._sortValues();\n            }\n            else {\n                var /** @type {?} */ correspondingChip = this._selectValue(value, isUserInput);\n                // Shift focus to the active item. Note that we shouldn't do this in multiple\n                // mode, because we don't know what chip the user interacted with last.\n                if (correspondingChip) {\n                    if (isUserInput) {\n                        this._keyManager.setActiveItem(correspondingChip);\n                    }\n                }\n            }\n        };\n    /**\n     * Finds and selects the chip based on its value.\n     * @param {?} value\n     * @param {?=} isUserInput\n     * @return {?} Chip that has the corresponding value.\n     */\n    MatChipList.prototype._selectValue = /**\n     * Finds and selects the chip based on its value.\n     * @param {?} value\n     * @param {?=} isUserInput\n     * @return {?} Chip that has the corresponding value.\n     */\n        function (value, isUserInput) {\n            var _this = this;\n            if (isUserInput === void 0) {\n                isUserInput = true;\n            }\n            var /** @type {?} */ correspondingChip = this.chips.find(function (chip) {\n                return chip.value != null && _this._compareWith(chip.value, value);\n            });\n            if (correspondingChip) {\n                isUserInput ? correspondingChip.selectViaInteraction() : correspondingChip.select();\n                this._selectionModel.select(correspondingChip);\n            }\n            return correspondingChip;\n        };\n    /**\n     * @return {?}\n     */\n    MatChipList.prototype._initializeSelection = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            // Defer setting the value in order to avoid the \"Expression\n            // has changed after it was checked\" errors from Angular.\n            Promise.resolve().then(function () {\n                if (_this.ngControl || _this._value) {\n                    _this._setSelectionByValue(_this.ngControl ? _this.ngControl.value : _this._value, false);\n                    _this.stateChanges.next();\n                }\n            });\n        };\n    /**\n     * Deselects every chip in the list.\n     * @param {?=} skip Chip that should not be deselected.\n     * @return {?}\n     */\n    MatChipList.prototype._clearSelection = /**\n     * Deselects every chip in the list.\n     * @param {?=} skip Chip that should not be deselected.\n     * @return {?}\n     */\n        function (skip) {\n            this._selectionModel.clear();\n            this.chips.forEach(function (chip) {\n                if (chip !== skip) {\n                    chip.deselect();\n                }\n            });\n            this.stateChanges.next();\n        };\n    /**\n     * Sorts the model values, ensuring that they keep the same\n     * order that they have in the panel.\n     * @return {?}\n     */\n    MatChipList.prototype._sortValues = /**\n     * Sorts the model values, ensuring that they keep the same\n     * order that they have in the panel.\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            if (this._multiple) {\n                this._selectionModel.clear();\n                this.chips.forEach(function (chip) {\n                    if (chip.selected) {\n                        _this._selectionModel.select(chip);\n                    }\n                });\n                this.stateChanges.next();\n            }\n        };\n    /**\n     * Emits change event to set the model value.\n     * @param {?=} fallbackValue\n     * @return {?}\n     */\n    MatChipList.prototype._propagateChanges = /**\n     * Emits change event to set the model value.\n     * @param {?=} fallbackValue\n     * @return {?}\n     */\n        function (fallbackValue) {\n            var /** @type {?} */ valueToEmit = null;\n            if (Array.isArray(this.selected)) {\n                valueToEmit = this.selected.map(function (chip) { return chip.value; });\n            }\n            else {\n                valueToEmit = this.selected ? this.selected.value : fallbackValue;\n            }\n            this._value = valueToEmit;\n            this.change.emit(new MatChipListChange(this, valueToEmit));\n            this.valueChange.emit(valueToEmit);\n            this._onChange(valueToEmit);\n            this._changeDetectorRef.markForCheck();\n        };\n    /** When blurred, mark the field as touched when focus moved outside the chip list. */\n    /**\n     * When blurred, mark the field as touched when focus moved outside the chip list.\n     * @return {?}\n     */\n    MatChipList.prototype._blur = /**\n     * When blurred, mark the field as touched when focus moved outside the chip list.\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            this._keyManager.setActiveItem(-1);\n            if (!this.disabled) {\n                if (this._chipInput) {\n                    // If there's a chip input, we should check whether the focus moved to chip input.\n                    // If the focus is not moved to chip input, mark the field as touched. If the focus moved\n                    // to chip input, do nothing.\n                    // Timeout is needed to wait for the focus() event trigger on chip input.\n                    setTimeout(function () {\n                        if (!_this.focused) {\n                            _this._markAsTouched();\n                        }\n                    });\n                }\n                else {\n                    // If there's no chip input, then mark the field as touched.\n                    this._markAsTouched();\n                }\n            }\n        };\n    /** Mark the field as touched */\n    /**\n     * Mark the field as touched\n     * @return {?}\n     */\n    MatChipList.prototype._markAsTouched = /**\n     * Mark the field as touched\n     * @return {?}\n     */\n        function () {\n            this._onTouched();\n            this._changeDetectorRef.markForCheck();\n            this.stateChanges.next();\n        };\n    /**\n     * @return {?}\n     */\n    MatChipList.prototype._resetChips = /**\n     * @return {?}\n     */\n        function () {\n            this._dropSubscriptions();\n            this._listenToChipsFocus();\n            this._listenToChipsSelection();\n            this._listenToChipsRemoved();\n        };\n    /**\n     * @return {?}\n     */\n    MatChipList.prototype._dropSubscriptions = /**\n     * @return {?}\n     */\n        function () {\n            if (this._chipFocusSubscription) {\n                this._chipFocusSubscription.unsubscribe();\n                this._chipFocusSubscription = null;\n            }\n            if (this._chipBlurSubscription) {\n                this._chipBlurSubscription.unsubscribe();\n                this._chipBlurSubscription = null;\n            }\n            if (this._chipSelectionSubscription) {\n                this._chipSelectionSubscription.unsubscribe();\n                this._chipSelectionSubscription = null;\n            }\n        };\n    /**\n     * Listens to user-generated selection events on each chip.\n     * @return {?}\n     */\n    MatChipList.prototype._listenToChipsSelection = /**\n     * Listens to user-generated selection events on each chip.\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            this._chipSelectionSubscription = this.chipSelectionChanges.subscribe(function (event) {\n                event.source.selected\n                    ? _this._selectionModel.select(event.source)\n                    : _this._selectionModel.deselect(event.source);\n                // For single selection chip list, make sure the deselected value is unselected.\n                if (!_this.multiple) {\n                    _this.chips.forEach(function (chip) {\n                        if (!_this._selectionModel.isSelected(chip) && chip.selected) {\n                            chip.deselect();\n                        }\n                    });\n                }\n                if (event.isUserInput) {\n                    _this._propagateChanges();\n                }\n            });\n        };\n    /**\n     * Listens to user-generated selection events on each chip.\n     * @return {?}\n     */\n    MatChipList.prototype._listenToChipsFocus = /**\n     * Listens to user-generated selection events on each chip.\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            this._chipFocusSubscription = this.chipFocusChanges.subscribe(function (event) {\n                var /** @type {?} */ chipIndex = _this.chips.toArray().indexOf(event.chip);\n                if (_this._isValidIndex(chipIndex)) {\n                    _this._keyManager.updateActiveItemIndex(chipIndex);\n                }\n                _this.stateChanges.next();\n            });\n            this._chipBlurSubscription = this.chipBlurChanges.subscribe(function () {\n                _this._blur();\n                _this.stateChanges.next();\n            });\n        };\n    /**\n     * @return {?}\n     */\n    MatChipList.prototype._listenToChipsRemoved = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            this._chipRemoveSubscription = this.chipRemoveChanges.subscribe(function (event) {\n                _this._updateKeyManager(event.chip);\n            });\n        };\n    return MatChipList;\n}(_MatChipListMixinBase));\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n// Increasing integer for generating unique ids.\nvar /** @type {?} */ nextUniqueId$1 = 0;\n/**\n * Directive that adds chip-specific behaviors to an input element inside `<mat-form-field>`.\n * May be placed inside or outside of an `<mat-chip-list>`.\n */\nvar MatChipInput = /*@__PURE__*/ (function () {\n    function MatChipInput(_elementRef, _defaultOptions) {\n        this._elementRef = _elementRef;\n        this._defaultOptions = _defaultOptions;\n        /**\n         * Whether the control is focused.\n         */\n        this.focused = false;\n        this._addOnBlur = false;\n        /**\n         * The list of key codes that will trigger a chipEnd event.\n         *\n         * Defaults to `[ENTER]`.\n         */\n        this.separatorKeyCodes = this._defaultOptions.separatorKeyCodes;\n        /**\n         * Emitted when a chip is to be added.\n         */\n        this.chipEnd = new EventEmitter();\n        /**\n         * The input's placeholder text.\n         * @deprecated Bind to the `placeholder` attribute directly.\n         * \\@deletion-target 7.0.0\n         */\n        this.placeholder = '';\n        /**\n         * Unique id for the input.\n         */\n        this.id = \"mat-chip-list-input-\" + nextUniqueId$1++;\n        this._inputElement = /** @type {?} */ (this._elementRef.nativeElement);\n    }\n    Object.defineProperty(MatChipInput.prototype, \"chipList\", {\n        set: /**\n         * Register input for chip list\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            if (value) {\n                this._chipList = value;\n                this._chipList.registerInput(this);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChipInput.prototype, \"addOnBlur\", {\n        get: /**\n         * Whether or not the chipEnd event will be emitted when the input is blurred.\n         * @return {?}\n         */ function () { return this._addOnBlur; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) { this._addOnBlur = coerceBooleanProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChipInput.prototype, \"empty\", {\n        /** Whether the input is empty. */\n        get: /**\n         * Whether the input is empty.\n         * @return {?}\n         */ function () { return !this._inputElement.value; },\n        enumerable: true,\n        configurable: true\n    });\n    /** Utility method to make host definition/tests more clear. */\n    /**\n     * Utility method to make host definition/tests more clear.\n     * @param {?=} event\n     * @return {?}\n     */\n    MatChipInput.prototype._keydown = /**\n     * Utility method to make host definition/tests more clear.\n     * @param {?=} event\n     * @return {?}\n     */\n        function (event) {\n            this._emitChipEnd(event);\n        };\n    /** Checks to see if the blur should emit the (chipEnd) event. */\n    /**\n     * Checks to see if the blur should emit the (chipEnd) event.\n     * @return {?}\n     */\n    MatChipInput.prototype._blur = /**\n     * Checks to see if the blur should emit the (chipEnd) event.\n     * @return {?}\n     */\n        function () {\n            if (this.addOnBlur) {\n                this._emitChipEnd();\n            }\n            this.focused = false;\n            // Blur the chip list if it is not focused\n            if (!this._chipList.focused) {\n                this._chipList._blur();\n            }\n            this._chipList.stateChanges.next();\n        };\n    /**\n     * @return {?}\n     */\n    MatChipInput.prototype._focus = /**\n     * @return {?}\n     */\n        function () {\n            this.focused = true;\n            this._chipList.stateChanges.next();\n        };\n    /** Checks to see if the (chipEnd) event needs to be emitted. */\n    /**\n     * Checks to see if the (chipEnd) event needs to be emitted.\n     * @param {?=} event\n     * @return {?}\n     */\n    MatChipInput.prototype._emitChipEnd = /**\n     * Checks to see if the (chipEnd) event needs to be emitted.\n     * @param {?=} event\n     * @return {?}\n     */\n        function (event) {\n            if (!this._inputElement.value && !!event) {\n                this._chipList._keydown(event);\n            }\n            if (!event || this.separatorKeyCodes.indexOf(event.keyCode) > -1) {\n                this.chipEnd.emit({ input: this._inputElement, value: this._inputElement.value });\n                if (event) {\n                    event.preventDefault();\n                }\n            }\n        };\n    /**\n     * @return {?}\n     */\n    MatChipInput.prototype._onInput = /**\n     * @return {?}\n     */\n        function () {\n            // Let chip list know whenever the value changes.\n            this._chipList.stateChanges.next();\n        };\n    /** Focuses the input. */\n    /**\n     * Focuses the input.\n     * @return {?}\n     */\n    MatChipInput.prototype.focus = /**\n     * Focuses the input.\n     * @return {?}\n     */\n        function () { this._inputElement.focus(); };\n    return MatChipInput;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar /** @type {?} */ CHIP_DECLARATIONS = [\n    MatChipList,\n    MatChip,\n    MatChipInput,\n    MatChipRemove,\n    MatChipAvatar,\n    MatChipTrailingIcon,\n];\nvar ɵ0 = {\n    separatorKeyCodes: [ENTER]\n};\nvar MatChipsModule = /*@__PURE__*/ (function () {\n    function MatChipsModule() {\n    }\n    return MatChipsModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nexport { MatChipsModule, MatChipListBase, _MatChipListMixinBase, MatChipListChange, MatChipList, MatChipSelectionChange, MatChipBase, _MatChipMixinBase, MatChipAvatar, MatChipTrailingIcon, MatChip, MatChipRemove, MatChipInput, MAT_CHIPS_DEFAULT_OPTIONS };\n//# sourceMappingURL=chips.es5.js.map\n",null]}