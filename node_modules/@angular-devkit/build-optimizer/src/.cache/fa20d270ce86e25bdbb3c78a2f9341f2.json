{"remainingRequest":"/home/liutao/Project/0/oncology/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/home/liutao/Project/0/oncology/node_modules/@angular/material/esm5/menu.es5.js","dependencies":[{"path":"/home/liutao/Project/0/oncology/node_modules/@angular/material/esm5/menu.es5.js","mtime":1526941038000},{"path":"/home/liutao/Project/0/oncology/node_modules/cache-loader/dist/cjs.js","mtime":1539266424898},{"path":"/home/liutao/Project/0/oncology/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1526531406000}],"contextDependencies":[],"result":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** PURE_IMPORTS_START _angular_core,_angular_cdk_portal,_angular_common,_angular_animations,tslib,_angular_cdk_a11y,_angular_material_core,rxjs,_angular_cdk_coercion,_angular_cdk_keycodes,rxjs_operators,_angular_cdk_bidi,_angular_cdk_overlay PURE_IMPORTS_END */\nimport { Directive, TemplateRef, ComponentFactoryResolver, ApplicationRef, Injector, ViewContainerRef, Inject, InjectionToken, ChangeDetectionStrategy, Component, ElementRef, ViewEncapsulation, Optional, ContentChild, ContentChildren, EventEmitter, Input, NgZone, Output, ViewChild, Self, NgModule } from '@angular/core';\nimport { TemplatePortal, DomPortalOutlet } from '@angular/cdk/portal';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport { trigger, state, style, animate, transition, query, group, sequence } from '@angular/animations';\nimport { __extends } from 'tslib';\nimport { FocusMonitor, FocusKeyManager, isFakeMousedownFromScreenReader } from '@angular/cdk/a11y';\nimport { mixinDisabled, mixinDisableRipple, MatCommonModule, MatRippleModule } from '@angular/material/core';\nimport { Subject, merge, Subscription, asapScheduler, of } from 'rxjs';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { ESCAPE, LEFT_ARROW, RIGHT_ARROW, DOWN_ARROW, UP_ARROW } from '@angular/cdk/keycodes';\nimport { startWith, switchMap, take, delay, filter, takeUntil } from 'rxjs/operators';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { Overlay, OverlayConfig, OverlayModule } from '@angular/cdk/overlay';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Menu content that will be rendered lazily once the menu is opened.\n */\nvar MatMenuContent = /*@__PURE__*/ (function () {\n    function MatMenuContent(_template, _componentFactoryResolver, _appRef, _injector, _viewContainerRef, _document) {\n        this._template = _template;\n        this._componentFactoryResolver = _componentFactoryResolver;\n        this._appRef = _appRef;\n        this._injector = _injector;\n        this._viewContainerRef = _viewContainerRef;\n        this._document = _document;\n    }\n    /**\n     * Attaches the content with a particular context.\n     * @docs-private\n     */\n    /**\n     * Attaches the content with a particular context.\n     * \\@docs-private\n     * @param {?=} context\n     * @return {?}\n     */\n    MatMenuContent.prototype.attach = /**\n     * Attaches the content with a particular context.\n     * \\@docs-private\n     * @param {?=} context\n     * @return {?}\n     */\n        function (context) {\n            if (context === void 0) {\n                context = {};\n            }\n            if (!this._portal) {\n                this._portal = new TemplatePortal(this._template, this._viewContainerRef);\n            }\n            this.detach();\n            if (!this._outlet) {\n                this._outlet = new DomPortalOutlet(this._document.createElement('div'), this._componentFactoryResolver, this._appRef, this._injector);\n            }\n            var /** @type {?} */ element = this._template.elementRef.nativeElement; /** @type {?} */\n            ((\n            // Because we support opening the same menu from different triggers (which in turn have their\n            // own `OverlayRef` panel), we have to re-insert the host element every time, otherwise we\n            // risk it staying attached to a pane that's no longer in the DOM.\n            element.parentNode)).insertBefore(this._outlet.outletElement, element);\n            this._portal.attach(this._outlet, context);\n        };\n    /**\n     * Detaches the content.\n     * @docs-private\n     */\n    /**\n     * Detaches the content.\n     * \\@docs-private\n     * @return {?}\n     */\n    MatMenuContent.prototype.detach = /**\n     * Detaches the content.\n     * \\@docs-private\n     * @return {?}\n     */\n        function () {\n            if (this._portal.isAttached) {\n                this._portal.detach();\n            }\n        };\n    /**\n     * @return {?}\n     */\n    MatMenuContent.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            if (this._outlet) {\n                this._outlet.dispose();\n            }\n        };\n    return MatMenuContent;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Animations used by the mat-menu component.\n * Animation duration and timing values are based on:\n * https://material.io/guidelines/components/menus.html#menus-usage\n */\nvar /** @type {?} */ matMenuAnimations = {\n    /**\n       * This animation controls the menu panel's entry and exit from the page.\n       *\n       * When the menu panel is added to the DOM, it scales in and fades in its border.\n       *\n       * When the menu panel is removed from the DOM, it simply fades out after a brief\n       * delay to display the ripple.\n       */\n    transformMenu: /*@__PURE__*/ trigger('transformMenu', [\n        /*@__PURE__*/ state('void', /*@__PURE__*/ style({\n            opacity: 0,\n            // This starts off from 0.01, instead of 0, because there's an issue in the Angular animations\n            // as of 4.2, which causes the animation to be skipped if it starts from 0.\n            transform: 'scale(0.01, 0.01)'\n        })),\n        /*@__PURE__*/ transition('void => enter', /*@__PURE__*/ sequence([\n            /*@__PURE__*/ query('.mat-menu-content', /*@__PURE__*/ style({ opacity: 0 })),\n            /*@__PURE__*/ animate('100ms linear', /*@__PURE__*/ style({ opacity: 1, transform: 'scale(1, 0.5)' })),\n            /*@__PURE__*/ group([\n                /*@__PURE__*/ query('.mat-menu-content', /*@__PURE__*/ animate('400ms cubic-bezier(0.55, 0, 0.55, 0.2)', /*@__PURE__*/ style({ opacity: 1 }))),\n                /*@__PURE__*/ animate('300ms cubic-bezier(0.25, 0.8, 0.25, 1)', /*@__PURE__*/ style({ transform: 'scale(1, 1)' })),\n            ])\n        ])),\n        /*@__PURE__*/ transition('* => void', /*@__PURE__*/ animate('150ms 50ms linear', /*@__PURE__*/ style({ opacity: 0 })))\n    ]),\n    /**\n       * This animation fades in the background color and content of the menu panel\n       * after its containing element is scaled in.\n       */\n    fadeInItems: /*@__PURE__*/ trigger('fadeInItems', [\n        // TODO(crisbeto): this is inside the `transformMenu`\n        // now. Remove next time we do breaking changes.\n        /*@__PURE__*/ state('showing', /*@__PURE__*/ style({ opacity: 1 })),\n        /*@__PURE__*/ transition('void => *', [\n            /*@__PURE__*/ style({ opacity: 0 }),\n            /*@__PURE__*/ animate('400ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)')\n        ])\n    ])\n};\n/**\n * @deprecated\n * \\@deletion-target 7.0.0\n */\nvar /** @type {?} */ fadeInItems = matMenuAnimations.fadeInItems;\n/**\n * @deprecated\n * \\@deletion-target 7.0.0\n */\nvar /** @type {?} */ transformMenu = matMenuAnimations.transformMenu;\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Throws an exception for the case when menu trigger doesn't have a valid mat-menu instance\n * \\@docs-private\n * @return {?}\n */\nfunction throwMatMenuMissingError() {\n    throw Error(\"mat-menu-trigger: must pass in an mat-menu instance.\\n\\n    Example:\\n      <mat-menu #menu=\\\"matMenu\\\"></mat-menu>\\n      <button [matMenuTriggerFor]=\\\"menu\\\"></button>\");\n}\n/**\n * Throws an exception for the case when menu's x-position value isn't valid.\n * In other words, it doesn't match 'before' or 'after'.\n * \\@docs-private\n * @return {?}\n */\nfunction throwMatMenuInvalidPositionX() {\n    throw Error(\"x-position value must be either 'before' or after'.\\n      Example: <mat-menu x-position=\\\"before\\\" #menu=\\\"matMenu\\\"></mat-menu>\");\n}\n/**\n * Throws an exception for the case when menu's y-position value isn't valid.\n * In other words, it doesn't match 'above' or 'below'.\n * \\@docs-private\n * @return {?}\n */\nfunction throwMatMenuInvalidPositionY() {\n    throw Error(\"y-position value must be either 'above' or below'.\\n      Example: <mat-menu y-position=\\\"above\\\" #menu=\\\"matMenu\\\"></mat-menu>\");\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Injection token used to provide the parent menu to menu-specific components.\n * \\@docs-private\n */\nvar /** @type {?} */ MAT_MENU_PANEL = /*@__PURE__*/ new InjectionToken('MAT_MENU_PANEL');\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * \\@docs-private\n */\nvar /**\n * \\@docs-private\n */ MatMenuItemBase = /*@__PURE__*/ (function () {\n    function MatMenuItemBase() {\n    }\n    return MatMenuItemBase;\n}());\nvar /** @type {?} */ _MatMenuItemMixinBase = /*@__PURE__*/ mixinDisableRipple(/*@__PURE__*/ mixinDisabled(MatMenuItemBase));\n/**\n * This directive is intended to be used inside an mat-menu tag.\n * It exists mostly to set the role attribute.\n */\nvar MatMenuItem = /*@__PURE__*/ (function (_super) {\n    __extends(MatMenuItem, _super);\n    function MatMenuItem(_elementRef, document, _focusMonitor, _parentMenu) {\n        var _this = \n        // @deletion-target 7.0.0 make `_focusMonitor` and `document` required params.\n        _super.call(this) || this;\n        _this._elementRef = _elementRef;\n        _this._focusMonitor = _focusMonitor;\n        _this._parentMenu = _parentMenu;\n        /**\n         * Stream that emits when the menu item is hovered.\n         */\n        _this._hovered = new Subject();\n        /**\n         * Whether the menu item is highlighted.\n         */\n        _this._highlighted = false;\n        /**\n         * Whether the menu item acts as a trigger for a sub-menu.\n         */\n        _this._triggersSubmenu = false;\n        if (_focusMonitor) {\n            // Start monitoring the element so it gets the appropriate focused classes. We want\n            // to show the focus style for menu items only when the focus was not caused by a\n            // mouse or touch interaction.\n            _focusMonitor.monitor(_this._getHostElement(), false);\n        }\n        if (_parentMenu && _parentMenu.addItem) {\n            _parentMenu.addItem(_this);\n        }\n        _this._document = document;\n        return _this;\n    }\n    /** Focuses the menu item. */\n    /**\n     * Focuses the menu item.\n     * @param {?=} origin\n     * @return {?}\n     */\n    MatMenuItem.prototype.focus = /**\n     * Focuses the menu item.\n     * @param {?=} origin\n     * @return {?}\n     */\n        function (origin) {\n            if (origin === void 0) {\n                origin = 'program';\n            }\n            if (this._focusMonitor) {\n                this._focusMonitor.focusVia(this._getHostElement(), origin);\n            }\n            else {\n                this._getHostElement().focus();\n            }\n        };\n    /**\n     * @return {?}\n     */\n    MatMenuItem.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            if (this._focusMonitor) {\n                this._focusMonitor.stopMonitoring(this._getHostElement());\n            }\n            if (this._parentMenu && this._parentMenu.removeItem) {\n                this._parentMenu.removeItem(this);\n            }\n            this._hovered.complete();\n        };\n    /** Used to set the `tabindex`. */\n    /**\n     * Used to set the `tabindex`.\n     * @return {?}\n     */\n    MatMenuItem.prototype._getTabIndex = /**\n     * Used to set the `tabindex`.\n     * @return {?}\n     */\n        function () {\n            return this.disabled ? '-1' : '0';\n        };\n    /** Returns the host DOM element. */\n    /**\n     * Returns the host DOM element.\n     * @return {?}\n     */\n    MatMenuItem.prototype._getHostElement = /**\n     * Returns the host DOM element.\n     * @return {?}\n     */\n        function () {\n            return this._elementRef.nativeElement;\n        };\n    /** Prevents the default element actions if it is disabled. */\n    /**\n     * Prevents the default element actions if it is disabled.\n     * @param {?} event\n     * @return {?}\n     */\n    MatMenuItem.prototype._checkDisabled = /**\n     * Prevents the default element actions if it is disabled.\n     * @param {?} event\n     * @return {?}\n     */\n        function (event) {\n            if (this.disabled) {\n                event.preventDefault();\n                event.stopPropagation();\n            }\n        };\n    /** Emits to the hover stream. */\n    /**\n     * Emits to the hover stream.\n     * @return {?}\n     */\n    MatMenuItem.prototype._handleMouseEnter = /**\n     * Emits to the hover stream.\n     * @return {?}\n     */\n        function () {\n            this._hovered.next(this);\n        };\n    /** Gets the label to be used when determining whether the option should be focused. */\n    /**\n     * Gets the label to be used when determining whether the option should be focused.\n     * @return {?}\n     */\n    MatMenuItem.prototype.getLabel = /**\n     * Gets the label to be used when determining whether the option should be focused.\n     * @return {?}\n     */\n        function () {\n            var /** @type {?} */ element = this._elementRef.nativeElement;\n            var /** @type {?} */ textNodeType = this._document ? this._document.TEXT_NODE : 3;\n            var /** @type {?} */ output = '';\n            if (element.childNodes) {\n                var /** @type {?} */ length_1 = element.childNodes.length;\n                // Go through all the top-level text nodes and extract their text.\n                // We skip anything that's not a text node to prevent the text from\n                // being thrown off by something like an icon.\n                for (var /** @type {?} */ i = 0; i < length_1; i++) {\n                    if (element.childNodes[i].nodeType === textNodeType) {\n                        output += element.childNodes[i].textContent;\n                    }\n                }\n            }\n            return output.trim();\n        };\n    return MatMenuItem;\n}(_MatMenuItemMixinBase));\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Injection token to be used to override the default options for `mat-menu`.\n */\nvar /** @type {?} */ MAT_MENU_DEFAULT_OPTIONS = /*@__PURE__*/ new InjectionToken('mat-menu-default-options', {\n    providedIn: 'root',\n    factory: MAT_MENU_DEFAULT_OPTIONS_FACTORY\n});\n/**\n * \\@docs-private\n * @return {?}\n */\nfunction MAT_MENU_DEFAULT_OPTIONS_FACTORY() {\n    return {\n        overlapTrigger: true,\n        xPosition: 'after',\n        yPosition: 'below',\n        backdropClass: 'cdk-overlay-transparent-backdrop',\n    };\n}\n/**\n * Start elevation for the menu panel.\n * \\@docs-private\n */\nvar /** @type {?} */ MAT_MENU_BASE_ELEVATION = 2;\nvar MatMenu = /*@__PURE__*/ (function () {\n    function MatMenu(_elementRef, _ngZone, _defaultOptions) {\n        this._elementRef = _elementRef;\n        this._ngZone = _ngZone;\n        this._defaultOptions = _defaultOptions;\n        this._xPosition = this._defaultOptions.xPosition;\n        this._yPosition = this._defaultOptions.yPosition;\n        /**\n         * Menu items inside the current menu.\n         */\n        this._items = [];\n        /**\n         * Emits whenever the amount of menu items changes.\n         */\n        this._itemChanges = new Subject();\n        /**\n         * Subscription to tab events on the menu panel\n         */\n        this._tabSubscription = Subscription.EMPTY;\n        /**\n         * Config object to be passed into the menu's ngClass\n         */\n        this._classList = {};\n        /**\n         * Current state of the panel animation.\n         */\n        this._panelAnimationState = 'void';\n        /**\n         * Emits whenever an animation on the menu completes.\n         */\n        this._animationDone = new Subject();\n        /**\n         * Class to be added to the backdrop element.\n         */\n        this.backdropClass = this._defaultOptions.backdropClass;\n        this._overlapTrigger = this._defaultOptions.overlapTrigger;\n        this._hasBackdrop = this._defaultOptions.hasBackdrop;\n        /**\n         * Event emitted when the menu is closed.\n         */\n        this.closed = new EventEmitter();\n        /**\n         * Event emitted when the menu is closed.\n         * @deprecated Switch to `closed` instead\n         * \\@deletion-target 7.0.0\n         */\n        this.close = this.closed;\n    }\n    Object.defineProperty(MatMenu.prototype, \"xPosition\", {\n        get: /**\n         * Position of the menu in the X axis.\n         * @return {?}\n         */ function () { return this._xPosition; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            if (value !== 'before' && value !== 'after') {\n                throwMatMenuInvalidPositionX();\n            }\n            this._xPosition = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatMenu.prototype, \"yPosition\", {\n        get: /**\n         * Position of the menu in the Y axis.\n         * @return {?}\n         */ function () { return this._yPosition; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            if (value !== 'above' && value !== 'below') {\n                throwMatMenuInvalidPositionY();\n            }\n            this._yPosition = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatMenu.prototype, \"overlapTrigger\", {\n        get: /**\n         * Whether the menu should overlap its trigger.\n         * @return {?}\n         */ function () { return this._overlapTrigger; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._overlapTrigger = coerceBooleanProperty(value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatMenu.prototype, \"hasBackdrop\", {\n        get: /**\n         * Whether the menu has a backdrop.\n         * @return {?}\n         */ function () { return this._hasBackdrop; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */ function (value) {\n            this._hasBackdrop = coerceBooleanProperty(value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatMenu.prototype, \"panelClass\", {\n        set: /**\n         * This method takes classes set on the host mat-menu element and applies them on the\n         * menu template that displays in the overlay container.  Otherwise, it's difficult\n         * to style the containing menu from outside the component.\n         * @param {?} classes list of class names\n         * @return {?}\n         */ function (classes) {\n            if (classes && classes.length) {\n                this._classList = classes.split(' ').reduce(function (obj, className) {\n                    obj[className] = true;\n                    return obj;\n                }, {});\n                this._elementRef.nativeElement.className = '';\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatMenu.prototype, \"classList\", {\n        get: /**\n         * This method takes classes set on the host mat-menu element and applies them on the\n         * menu template that displays in the overlay container.  Otherwise, it's difficult\n         * to style the containing menu from outside the component.\n         * @deprecated Use `panelClass` instead.\n         * \\@deletion-target 7.0.0\n         * @return {?}\n         */ function () { return this.panelClass; },\n        set: /**\n         * @param {?} classes\n         * @return {?}\n         */ function (classes) { this.panelClass = classes; },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    MatMenu.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            this._keyManager = new FocusKeyManager(this._items).withWrap().withTypeAhead();\n            this._tabSubscription = this._keyManager.tabOut.subscribe(function () { return _this.close.emit('tab'); });\n        };\n    /**\n     * @return {?}\n     */\n    MatMenu.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            this._tabSubscription.unsubscribe();\n            this.closed.complete();\n        };\n    /** Stream that emits whenever the hovered menu item changes. */\n    /**\n     * Stream that emits whenever the hovered menu item changes.\n     * @return {?}\n     */\n    MatMenu.prototype._hovered = /**\n     * Stream that emits whenever the hovered menu item changes.\n     * @return {?}\n     */\n        function () {\n            return this._itemChanges.pipe(startWith(this._items), switchMap(function (items) { return merge.apply(void 0, items.map(function (item) { return item._hovered; })); }));\n        };\n    /** Handle a keyboard event from the menu, delegating to the appropriate action. */\n    /**\n     * Handle a keyboard event from the menu, delegating to the appropriate action.\n     * @param {?} event\n     * @return {?}\n     */\n    MatMenu.prototype._handleKeydown = /**\n     * Handle a keyboard event from the menu, delegating to the appropriate action.\n     * @param {?} event\n     * @return {?}\n     */\n        function (event) {\n            var /** @type {?} */ keyCode = event.keyCode;\n            switch (keyCode) {\n                case ESCAPE:\n                    this.closed.emit('keydown');\n                    event.stopPropagation();\n                    break;\n                case LEFT_ARROW:\n                    if (this.parentMenu && this.direction === 'ltr') {\n                        this.closed.emit('keydown');\n                    }\n                    break;\n                case RIGHT_ARROW:\n                    if (this.parentMenu && this.direction === 'rtl') {\n                        this.closed.emit('keydown');\n                    }\n                    break;\n                default:\n                    if (keyCode === UP_ARROW || keyCode === DOWN_ARROW) {\n                        this._keyManager.setFocusOrigin('keyboard');\n                    }\n                    this._keyManager.onKeydown(event);\n            }\n        };\n    /**\n     * Focus the first item in the menu.\n     * @param origin Action from which the focus originated. Used to set the correct styling.\n     */\n    /**\n     * Focus the first item in the menu.\n     * @param {?=} origin Action from which the focus originated. Used to set the correct styling.\n     * @return {?}\n     */\n    MatMenu.prototype.focusFirstItem = /**\n     * Focus the first item in the menu.\n     * @param {?=} origin Action from which the focus originated. Used to set the correct styling.\n     * @return {?}\n     */\n        function (origin) {\n            var _this = this;\n            if (origin === void 0) {\n                origin = 'program';\n            }\n            // When the content is rendered lazily, it takes a bit before the items are inside the DOM.\n            if (this.lazyContent) {\n                this._ngZone.onStable.asObservable()\n                    .pipe(take(1))\n                    .subscribe(function () { return _this._keyManager.setFocusOrigin(origin).setFirstItemActive(); });\n            }\n            else {\n                this._keyManager.setFocusOrigin(origin).setFirstItemActive();\n            }\n        };\n    /**\n     * Resets the active item in the menu. This is used when the menu is opened, allowing\n     * the user to start from the first option when pressing the down arrow.\n     */\n    /**\n     * Resets the active item in the menu. This is used when the menu is opened, allowing\n     * the user to start from the first option when pressing the down arrow.\n     * @return {?}\n     */\n    MatMenu.prototype.resetActiveItem = /**\n     * Resets the active item in the menu. This is used when the menu is opened, allowing\n     * the user to start from the first option when pressing the down arrow.\n     * @return {?}\n     */\n        function () {\n            this._keyManager.setActiveItem(-1);\n        };\n    /**\n     * Sets the menu panel elevation.\n     * @param depth Number of parent menus that come before the menu.\n     */\n    /**\n     * Sets the menu panel elevation.\n     * @param {?} depth Number of parent menus that come before the menu.\n     * @return {?}\n     */\n    MatMenu.prototype.setElevation = /**\n     * Sets the menu panel elevation.\n     * @param {?} depth Number of parent menus that come before the menu.\n     * @return {?}\n     */\n        function (depth) {\n            // The elevation starts at the base and increases by one for each level.\n            var /** @type {?} */ newElevation = \"mat-elevation-z\" + (MAT_MENU_BASE_ELEVATION + depth);\n            var /** @type {?} */ customElevation = Object.keys(this._classList).find(function (c) { return c.startsWith('mat-elevation-z'); });\n            if (!customElevation || customElevation === this._previousElevation) {\n                if (this._previousElevation) {\n                    this._classList[this._previousElevation] = false;\n                }\n                this._classList[newElevation] = true;\n                this._previousElevation = newElevation;\n            }\n        };\n    /**\n     * Registers a menu item with the menu.\n     * @docs-private\n     */\n    /**\n     * Registers a menu item with the menu.\n     * \\@docs-private\n     * @param {?} item\n     * @return {?}\n     */\n    MatMenu.prototype.addItem = /**\n     * Registers a menu item with the menu.\n     * \\@docs-private\n     * @param {?} item\n     * @return {?}\n     */\n        function (item) {\n            // We register the items through this method, rather than picking them up through\n            // `ContentChildren`, because we need the items to be picked up by their closest\n            // `mat-menu` ancestor. If we used `@ContentChildren(MatMenuItem, {descendants: true})`,\n            // all descendant items will bleed into the top-level menu in the case where the consumer\n            // has `mat-menu` instances nested inside each other.\n            if (this._items.indexOf(item) === -1) {\n                this._items.push(item);\n                this._itemChanges.next(this._items);\n            }\n        };\n    /**\n     * Removes an item from the menu.\n     * @docs-private\n     */\n    /**\n     * Removes an item from the menu.\n     * \\@docs-private\n     * @param {?} item\n     * @return {?}\n     */\n    MatMenu.prototype.removeItem = /**\n     * Removes an item from the menu.\n     * \\@docs-private\n     * @param {?} item\n     * @return {?}\n     */\n        function (item) {\n            var /** @type {?} */ index = this._items.indexOf(item);\n            if (this._items.indexOf(item) > -1) {\n                this._items.splice(index, 1);\n                this._itemChanges.next(this._items);\n            }\n        };\n    /** Starts the enter animation. */\n    /**\n     * Starts the enter animation.\n     * @return {?}\n     */\n    MatMenu.prototype._startAnimation = /**\n     * Starts the enter animation.\n     * @return {?}\n     */\n        function () {\n            // @deletion-target 7.0.0 Combine with _resetAnimation.\n            this._panelAnimationState = 'enter';\n        };\n    /** Resets the panel animation to its initial state. */\n    /**\n     * Resets the panel animation to its initial state.\n     * @return {?}\n     */\n    MatMenu.prototype._resetAnimation = /**\n     * Resets the panel animation to its initial state.\n     * @return {?}\n     */\n        function () {\n            // @deletion-target 7.0.0 Combine with _startAnimation.\n            this._panelAnimationState = 'void';\n        };\n    /** Callback that is invoked when the panel animation completes. */\n    /**\n     * Callback that is invoked when the panel animation completes.\n     * @param {?} event\n     * @return {?}\n     */\n    MatMenu.prototype._onAnimationDone = /**\n     * Callback that is invoked when the panel animation completes.\n     * @param {?} event\n     * @return {?}\n     */\n        function (event) {\n            this._animationDone.next(event);\n            this._isAnimating = false;\n        };\n    return MatMenu;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Injection token that determines the scroll handling while the menu is open.\n */\nvar /** @type {?} */ MAT_MENU_SCROLL_STRATEGY = /*@__PURE__*/ new InjectionToken('mat-menu-scroll-strategy');\n/**\n * \\@docs-private\n * @param {?} overlay\n * @return {?}\n */\nfunction MAT_MENU_SCROLL_STRATEGY_FACTORY(overlay) {\n    return function () { return overlay.scrollStrategies.reposition(); };\n}\n/**\n * \\@docs-private\n */\nvar /** @type {?} */ MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER = {\n    provide: MAT_MENU_SCROLL_STRATEGY,\n    deps: [Overlay],\n    useFactory: MAT_MENU_SCROLL_STRATEGY_FACTORY,\n};\n/**\n * Default top padding of the menu panel.\n */\nvar /** @type {?} */ MENU_PANEL_TOP_PADDING = 8;\n/**\n * This directive is intended to be used in conjunction with an mat-menu tag.  It is\n * responsible for toggling the display of the provided menu instance.\n */\nvar MatMenuTrigger = /*@__PURE__*/ (function () {\n    function MatMenuTrigger(_overlay, _element, _viewContainerRef, _scrollStrategy, _parentMenu, _menuItemInstance, _dir, _focusMonitor) {\n        this._overlay = _overlay;\n        this._element = _element;\n        this._viewContainerRef = _viewContainerRef;\n        this._scrollStrategy = _scrollStrategy;\n        this._parentMenu = _parentMenu;\n        this._menuItemInstance = _menuItemInstance;\n        this._dir = _dir;\n        this._focusMonitor = _focusMonitor;\n        this._overlayRef = null;\n        this._menuOpen = false;\n        this._closeSubscription = Subscription.EMPTY;\n        this._hoverSubscription = Subscription.EMPTY;\n        this._openedByMouse = false;\n        /**\n         * Event emitted when the associated menu is opened.\n         */\n        this.menuOpened = new EventEmitter();\n        /**\n         * Event emitted when the associated menu is opened.\n         * @deprecated Switch to `menuOpened` instead\n         * \\@deletion-target 7.0.0\n         */\n        this.onMenuOpen = this.menuOpened;\n        /**\n         * Event emitted when the associated menu is closed.\n         */\n        this.menuClosed = new EventEmitter();\n        /**\n         * Event emitted when the associated menu is closed.\n         * @deprecated Switch to `menuClosed` instead\n         * \\@deletion-target 7.0.0\n         */\n        this.onMenuClose = this.menuClosed;\n        if (_menuItemInstance) {\n            _menuItemInstance._triggersSubmenu = this.triggersSubmenu();\n        }\n    }\n    Object.defineProperty(MatMenuTrigger.prototype, \"_deprecatedMatMenuTriggerFor\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 7.0.0\n         * @return {?}\n         */ function () {\n            return this.menu;\n        },\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */ function (v) {\n            this.menu = v;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    MatMenuTrigger.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            this._checkMenu();\n            this.menu.close.subscribe(function (reason) {\n                _this._destroyMenu();\n                // If a click closed the menu, we should close the entire chain of nested menus.\n                if ((reason === 'click' || reason === 'tab') && _this._parentMenu) {\n                    _this._parentMenu.closed.emit(reason);\n                }\n            });\n            this._handleHover();\n        };\n    /**\n     * @return {?}\n     */\n    MatMenuTrigger.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            if (this._overlayRef) {\n                this._overlayRef.dispose();\n                this._overlayRef = null;\n            }\n            this._cleanUpSubscriptions();\n        };\n    Object.defineProperty(MatMenuTrigger.prototype, \"menuOpen\", {\n        /** Whether the menu is open. */\n        get: /**\n         * Whether the menu is open.\n         * @return {?}\n         */ function () {\n            return this._menuOpen;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatMenuTrigger.prototype, \"dir\", {\n        /** The text direction of the containing app. */\n        get: /**\n         * The text direction of the containing app.\n         * @return {?}\n         */ function () {\n            return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Whether the menu triggers a sub-menu or a top-level one. */\n    /**\n     * Whether the menu triggers a sub-menu or a top-level one.\n     * @return {?}\n     */\n    MatMenuTrigger.prototype.triggersSubmenu = /**\n     * Whether the menu triggers a sub-menu or a top-level one.\n     * @return {?}\n     */\n        function () {\n            return !!(this._menuItemInstance && this._parentMenu);\n        };\n    /** Toggles the menu between the open and closed states. */\n    /**\n     * Toggles the menu between the open and closed states.\n     * @return {?}\n     */\n    MatMenuTrigger.prototype.toggleMenu = /**\n     * Toggles the menu between the open and closed states.\n     * @return {?}\n     */\n        function () {\n            return this._menuOpen ? this.closeMenu() : this.openMenu();\n        };\n    /** Opens the menu. */\n    /**\n     * Opens the menu.\n     * @return {?}\n     */\n    MatMenuTrigger.prototype.openMenu = /**\n     * Opens the menu.\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            if (this._menuOpen) {\n                return;\n            }\n            var /** @type {?} */ overlayRef = this._createOverlay();\n            overlayRef.setDirection(this.dir);\n            overlayRef.attach(this._portal);\n            if (this.menu.lazyContent) {\n                this.menu.lazyContent.attach(this.menuData);\n            }\n            this._closeSubscription = this._menuClosingActions().subscribe(function () { return _this.closeMenu(); });\n            this._initMenu();\n            if (this.menu instanceof MatMenu) {\n                this.menu._startAnimation();\n            }\n        };\n    /** Closes the menu. */\n    /**\n     * Closes the menu.\n     * @return {?}\n     */\n    MatMenuTrigger.prototype.closeMenu = /**\n     * Closes the menu.\n     * @return {?}\n     */\n        function () {\n            this.menu.close.emit();\n        };\n    /**\n     * Focuses the menu trigger.\n     * @param origin Source of the menu trigger's focus.\n     */\n    /**\n     * Focuses the menu trigger.\n     * @param {?=} origin Source of the menu trigger's focus.\n     * @return {?}\n     */\n    MatMenuTrigger.prototype.focus = /**\n     * Focuses the menu trigger.\n     * @param {?=} origin Source of the menu trigger's focus.\n     * @return {?}\n     */\n        function (origin) {\n            if (origin === void 0) {\n                origin = 'program';\n            }\n            if (this._focusMonitor) {\n                this._focusMonitor.focusVia(this._element.nativeElement, origin);\n            }\n            else {\n                this._element.nativeElement.focus();\n            }\n        };\n    /**\n     * Closes the menu and does the necessary cleanup.\n     * @return {?}\n     */\n    MatMenuTrigger.prototype._destroyMenu = /**\n     * Closes the menu and does the necessary cleanup.\n     * @return {?}\n     */\n        function () {\n            if (!this._overlayRef || !this.menuOpen) {\n                return;\n            }\n            var /** @type {?} */ menu = this.menu;\n            this._resetMenu();\n            this._closeSubscription.unsubscribe();\n            this._overlayRef.detach();\n            if (menu instanceof MatMenu) {\n                menu._resetAnimation();\n                if (menu.lazyContent) {\n                    // Wait for the exit animation to finish before detaching the content.\n                    menu._animationDone\n                        .pipe(take(1))\n                        .subscribe(function () { return ((menu.lazyContent)).detach(); });\n                }\n            }\n            else if (menu.lazyContent) {\n                menu.lazyContent.detach();\n            }\n        };\n    /**\n     * This method sets the menu state to open and focuses the first item if\n     * the menu was opened via the keyboard.\n     * @return {?}\n     */\n    MatMenuTrigger.prototype._initMenu = /**\n     * This method sets the menu state to open and focuses the first item if\n     * the menu was opened via the keyboard.\n     * @return {?}\n     */\n        function () {\n            this.menu.parentMenu = this.triggersSubmenu() ? this._parentMenu : undefined;\n            this.menu.direction = this.dir;\n            this._setMenuElevation();\n            this._setIsMenuOpen(true);\n            this.menu.focusFirstItem(this._openedByMouse ? 'mouse' : 'program');\n        };\n    /**\n     * Updates the menu elevation based on the amount of parent menus that it has.\n     * @return {?}\n     */\n    MatMenuTrigger.prototype._setMenuElevation = /**\n     * Updates the menu elevation based on the amount of parent menus that it has.\n     * @return {?}\n     */\n        function () {\n            if (this.menu.setElevation) {\n                var /** @type {?} */ depth = 0;\n                var /** @type {?} */ parentMenu = this.menu.parentMenu;\n                while (parentMenu) {\n                    depth++;\n                    parentMenu = parentMenu.parentMenu;\n                }\n                this.menu.setElevation(depth);\n            }\n        };\n    /**\n     * This method resets the menu when it's closed, most importantly restoring\n     * focus to the menu trigger if the menu was opened via the keyboard.\n     * @return {?}\n     */\n    MatMenuTrigger.prototype._resetMenu = /**\n     * This method resets the menu when it's closed, most importantly restoring\n     * focus to the menu trigger if the menu was opened via the keyboard.\n     * @return {?}\n     */\n        function () {\n            this._setIsMenuOpen(false);\n            // We should reset focus if the user is navigating using a keyboard or\n            // if we have a top-level trigger which might cause focus to be lost\n            // when clicking on the backdrop.\n            if (!this._openedByMouse) {\n                // Note that the focus style will show up both for `program` and\n                // `keyboard` so we don't have to specify which one it is.\n                this.focus();\n            }\n            else if (!this.triggersSubmenu()) {\n                this.focus('mouse');\n            }\n            this._openedByMouse = false;\n        };\n    /**\n     * @param {?} isOpen\n     * @return {?}\n     */\n    MatMenuTrigger.prototype._setIsMenuOpen = /**\n     * @param {?} isOpen\n     * @return {?}\n     */\n        function (isOpen) {\n            this._menuOpen = isOpen;\n            this._menuOpen ? this.menuOpened.emit() : this.menuClosed.emit();\n            if (this.triggersSubmenu()) {\n                this._menuItemInstance._highlighted = isOpen;\n            }\n        };\n    /**\n     * This method checks that a valid instance of MatMenu has been passed into\n     * matMenuTriggerFor. If not, an exception is thrown.\n     * @return {?}\n     */\n    MatMenuTrigger.prototype._checkMenu = /**\n     * This method checks that a valid instance of MatMenu has been passed into\n     * matMenuTriggerFor. If not, an exception is thrown.\n     * @return {?}\n     */\n        function () {\n            if (!this.menu) {\n                throwMatMenuMissingError();\n            }\n        };\n    /**\n     * This method creates the overlay from the provided menu's template and saves its\n     * OverlayRef so that it can be attached to the DOM when openMenu is called.\n     * @return {?}\n     */\n    MatMenuTrigger.prototype._createOverlay = /**\n     * This method creates the overlay from the provided menu's template and saves its\n     * OverlayRef so that it can be attached to the DOM when openMenu is called.\n     * @return {?}\n     */\n        function () {\n            if (!this._overlayRef) {\n                this._portal = new TemplatePortal(this.menu.templateRef, this._viewContainerRef);\n                var /** @type {?} */ config = this._getOverlayConfig();\n                this._subscribeToPositions(/** @type {?} */ (config.positionStrategy));\n                this._overlayRef = this._overlay.create(config);\n            }\n            return this._overlayRef;\n        };\n    /**\n     * This method builds the configuration object needed to create the overlay, the OverlayState.\n     * @return {?} OverlayConfig\n     */\n    MatMenuTrigger.prototype._getOverlayConfig = /**\n     * This method builds the configuration object needed to create the overlay, the OverlayState.\n     * @return {?} OverlayConfig\n     */\n        function () {\n            return new OverlayConfig({\n                positionStrategy: this._getPosition(),\n                hasBackdrop: this.menu.hasBackdrop == null ? !this.triggersSubmenu() : this.menu.hasBackdrop,\n                backdropClass: this.menu.backdropClass || 'cdk-overlay-transparent-backdrop',\n                scrollStrategy: this._scrollStrategy()\n            });\n        };\n    /**\n     * Listens to changes in the position of the overlay and sets the correct classes\n     * on the menu based on the new position. This ensures the animation origin is always\n     * correct, even if a fallback position is used for the overlay.\n     * @param {?} position\n     * @return {?}\n     */\n    MatMenuTrigger.prototype._subscribeToPositions = /**\n     * Listens to changes in the position of the overlay and sets the correct classes\n     * on the menu based on the new position. This ensures the animation origin is always\n     * correct, even if a fallback position is used for the overlay.\n     * @param {?} position\n     * @return {?}\n     */\n        function (position) {\n            var _this = this;\n            if (this.menu.setPositionClasses) {\n                position.positionChanges.subscribe(function (change) {\n                    var /** @type {?} */ posX = change.connectionPair.overlayX === 'start' ? 'after' : 'before';\n                    var /** @type {?} */ posY = change.connectionPair.overlayY === 'top' ? 'below' : 'above'; /** @type {?} */\n                    ((_this.menu.setPositionClasses))(posX, posY);\n                });\n            }\n        };\n    /**\n     * This method builds the position strategy for the overlay, so the menu is properly connected\n     * to the trigger.\n     * @return {?} ConnectedPositionStrategy\n     */\n    MatMenuTrigger.prototype._getPosition = /**\n     * This method builds the position strategy for the overlay, so the menu is properly connected\n     * to the trigger.\n     * @return {?} ConnectedPositionStrategy\n     */\n        function () {\n            var _a = this.menu.xPosition === 'before' ? ['end', 'start'] : ['start', 'end'], originX = _a[0], originFallbackX = _a[1];\n            var _b = this.menu.yPosition === 'above' ? ['bottom', 'top'] : ['top', 'bottom'], overlayY = _b[0], overlayFallbackY = _b[1];\n            var _c = [overlayY, overlayFallbackY], originY = _c[0], originFallbackY = _c[1];\n            var _d = [originX, originFallbackX], overlayX = _d[0], overlayFallbackX = _d[1];\n            var /** @type {?} */ offsetY = 0;\n            if (this.triggersSubmenu()) {\n                // When the menu is a sub-menu, it should always align itself\n                // to the edges of the trigger, instead of overlapping it.\n                overlayFallbackX = originX = this.menu.xPosition === 'before' ? 'start' : 'end';\n                originFallbackX = overlayX = originX === 'end' ? 'start' : 'end';\n                offsetY = overlayY === 'bottom' ? MENU_PANEL_TOP_PADDING : -MENU_PANEL_TOP_PADDING;\n            }\n            else if (!this.menu.overlapTrigger) {\n                originY = overlayY === 'top' ? 'bottom' : 'top';\n                originFallbackY = overlayFallbackY === 'top' ? 'bottom' : 'top';\n            }\n            return this._overlay.position()\n                .flexibleConnectedTo(this._element)\n                .withTransformOriginOn('.mat-menu-panel')\n                .withPositions([\n                { originX: originX, originY: originY, overlayX: overlayX, overlayY: overlayY, offsetY: offsetY },\n                { originX: originFallbackX, originY: originY, overlayX: overlayFallbackX, overlayY: overlayY, offsetY: offsetY },\n                {\n                    originX: originX,\n                    originY: originFallbackY,\n                    overlayX: overlayX,\n                    overlayY: overlayFallbackY,\n                    offsetY: -offsetY\n                },\n                {\n                    originX: originFallbackX,\n                    originY: originFallbackY,\n                    overlayX: overlayFallbackX,\n                    overlayY: overlayFallbackY,\n                    offsetY: -offsetY\n                }\n            ]);\n        };\n    /**\n     * Cleans up the active subscriptions.\n     * @return {?}\n     */\n    MatMenuTrigger.prototype._cleanUpSubscriptions = /**\n     * Cleans up the active subscriptions.\n     * @return {?}\n     */\n        function () {\n            this._closeSubscription.unsubscribe();\n            this._hoverSubscription.unsubscribe();\n        };\n    /**\n     * Returns a stream that emits whenever an action that should close the menu occurs.\n     * @return {?}\n     */\n    MatMenuTrigger.prototype._menuClosingActions = /**\n     * Returns a stream that emits whenever an action that should close the menu occurs.\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            var /** @type {?} */ backdrop = ((this._overlayRef)).backdropClick();\n            var /** @type {?} */ detachments = ((this._overlayRef)).detachments();\n            var /** @type {?} */ parentClose = this._parentMenu ? this._parentMenu.close : of();\n            var /** @type {?} */ hover = this._parentMenu ? this._parentMenu._hovered().pipe(filter(function (active) { return active !== _this._menuItemInstance; }), filter(function () { return _this._menuOpen; })) : of();\n            return merge(backdrop, parentClose, hover, detachments);\n        };\n    /** Handles mouse presses on the trigger. */\n    /**\n     * Handles mouse presses on the trigger.\n     * @param {?} event\n     * @return {?}\n     */\n    MatMenuTrigger.prototype._handleMousedown = /**\n     * Handles mouse presses on the trigger.\n     * @param {?} event\n     * @return {?}\n     */\n        function (event) {\n            if (!isFakeMousedownFromScreenReader(event)) {\n                this._openedByMouse = true;\n                // Since clicking on the trigger won't close the menu if it opens a sub-menu,\n                // we should prevent focus from moving onto it via click to avoid the\n                // highlight from lingering on the menu item.\n                if (this.triggersSubmenu()) {\n                    event.preventDefault();\n                }\n            }\n        };\n    /** Handles key presses on the trigger. */\n    /**\n     * Handles key presses on the trigger.\n     * @param {?} event\n     * @return {?}\n     */\n    MatMenuTrigger.prototype._handleKeydown = /**\n     * Handles key presses on the trigger.\n     * @param {?} event\n     * @return {?}\n     */\n        function (event) {\n            var /** @type {?} */ keyCode = event.keyCode;\n            if (this.triggersSubmenu() && ((keyCode === RIGHT_ARROW && this.dir === 'ltr') ||\n                (keyCode === LEFT_ARROW && this.dir === 'rtl'))) {\n                this.openMenu();\n            }\n        };\n    /** Handles click events on the trigger. */\n    /**\n     * Handles click events on the trigger.\n     * @param {?} event\n     * @return {?}\n     */\n    MatMenuTrigger.prototype._handleClick = /**\n     * Handles click events on the trigger.\n     * @param {?} event\n     * @return {?}\n     */\n        function (event) {\n            if (this.triggersSubmenu()) {\n                // Stop event propagation to avoid closing the parent menu.\n                event.stopPropagation();\n                this.openMenu();\n            }\n            else {\n                this.toggleMenu();\n            }\n        };\n    /**\n     * Handles the cases where the user hovers over the trigger.\n     * @return {?}\n     */\n    MatMenuTrigger.prototype._handleHover = /**\n     * Handles the cases where the user hovers over the trigger.\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            // Subscribe to changes in the hovered item in order to toggle the panel.\n            if (!this.triggersSubmenu()) {\n                return;\n            }\n            this._hoverSubscription = this._parentMenu._hovered()\n                .pipe(filter(function (active) { return active === _this._menuItemInstance && !active.disabled; }), delay(0, asapScheduler))\n                .subscribe(function () {\n                _this._openedByMouse = true;\n                // If the same menu is used between multiple triggers, it might still be animating\n                // while the new trigger tries to re-open it. Wait for the animation to finish\n                // before doing so. Also interrupt if the user moves to another item.\n                if (_this.menu instanceof MatMenu && _this.menu._isAnimating) {\n                    _this.menu._animationDone\n                        .pipe(take(1), takeUntil(_this._parentMenu._hovered()))\n                        .subscribe(function () { return _this.openMenu(); });\n                }\n                else {\n                    _this.openMenu();\n                }\n            });\n        };\n    return MatMenuTrigger;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar MatMenuModule = /*@__PURE__*/ (function () {\n    function MatMenuModule() {\n    }\n    return MatMenuModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nexport { MAT_MENU_SCROLL_STRATEGY, MatMenuModule, MatMenu, MAT_MENU_DEFAULT_OPTIONS, MatMenuItem, MatMenuTrigger, matMenuAnimations, fadeInItems, transformMenu, MatMenuContent, MAT_MENU_DEFAULT_OPTIONS_FACTORY as a24, MatMenuItemBase as b24, _MatMenuItemMixinBase as c24, MAT_MENU_PANEL as f24, MAT_MENU_SCROLL_STRATEGY_FACTORY as d24, MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER as e24 };\n//# sourceMappingURL=menu.es5.js.map\n",null]}