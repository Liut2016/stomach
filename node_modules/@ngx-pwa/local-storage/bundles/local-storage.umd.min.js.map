{"version":3,"file":"local-storage.umd.min.js","sources":["../../out-tsc/lib/src/service/databases/local-database.ts","../../out-tsc/lib/src/tokens.ts","../../out-tsc/lib/src/service/databases/indexeddb-database.ts","../../out-tsc/lib/src/service/databases/localstorage-database.ts","../../out-tsc/lib/src/service/databases/mock-local-database.ts","../../out-tsc/lib/src/service/validation/json-validator.ts","../../out-tsc/lib/src/service/lib.service.ts"],"sourcesContent":["import { Injectable, PLATFORM_ID, Optional } from '@angular/core';\nimport { isPlatformBrowser } from '@angular/common';\nimport { Observable } from 'rxjs';\n\nimport { IndexedDBDatabase } from './indexeddb-database';\nimport { LocalStorageDatabase } from './localstorage-database';\nimport { MockLocalDatabase } from './mock-local-database';\nimport { LOCAL_STORAGE_PREFIX } from '../../tokens';\n\nexport function localDatabaseFactory(platformId: Object, prefix: string | null) {\n\n  if (isPlatformBrowser(platformId) && ('indexedDB' in window) && (indexedDB !== undefined) && (indexedDB !== null)) {\n\n    /* Try with IndexedDB in modern browsers */\n    return new IndexedDBDatabase(prefix);\n\n  } else if (isPlatformBrowser(platformId) && ('localStorage' in window) && (localStorage !== undefined) && (localStorage !== null)) {\n\n    /* Try with localStorage in old browsers (IE9) */\n    return new LocalStorageDatabase(prefix);\n\n  } else {\n\n    /* Fake database for server-side rendering (Universal) */\n    return new MockLocalDatabase();\n\n  }\n\n};\n\n@Injectable({\n  providedIn: 'root',\n  useFactory: localDatabaseFactory,\n  deps: [\n    PLATFORM_ID,\n    [new Optional(), LOCAL_STORAGE_PREFIX]\n  ]\n})\nexport abstract class LocalDatabase {\n\n  abstract getItem<T = any>(key: string): Observable<T | null>;\n  abstract setItem(key: string, data: any): Observable<boolean>;\n  abstract removeItem(key: string): Observable<boolean>;\n  abstract clear(): Observable<boolean>;\n\n}\n","import { InjectionToken, Provider } from '@angular/core';\n\nexport const LOCAL_STORAGE_PREFIX = new InjectionToken<string>('localStoragePrefix', { providedIn: 'root', factory: () => '' });\n\nexport interface LocalStorageProvidersConfig {\n\n  /** Optional prefix to avoid collision in multiple apps on same subdomain */\n  prefix?: string;\n}\n\nexport function localStorageProviders(config: LocalStorageProvidersConfig): Provider[] {\n  return [\n    config.prefix ? { provide: LOCAL_STORAGE_PREFIX, useValue: config.prefix } : []\n  ];\n}\n","import { Injectable, Optional, Inject } from '@angular/core';\nimport { Observable, ReplaySubject, fromEvent as fromEvent, of as of, throwError, race } from 'rxjs';\nimport { map, mergeMap, first } from 'rxjs/operators';\n\nimport { LocalDatabase } from './local-database';\nimport { LOCAL_STORAGE_PREFIX } from '../../tokens';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class IndexedDBDatabase implements LocalDatabase {\n\n  /**\n   * IndexedDB database name for local storage\n   */\n  protected dbName = 'ngStorage';\n  /**\n   * IndexedDB object store name for local storage\n   */\n  protected readonly objectStoreName = 'localStorage';\n  /**\n   * IndexedDB key path name for local storage (where an item's key will be stored)\n   */\n  protected readonly keyPath = 'key';\n  /**\n   * IndexedDB data path name for local storage (where items' value will be stored)\n   */\n  protected readonly dataPath = 'value';\n  /**\n   * IndexedDB database connection, wrapped in a RxJS ReplaySubject to be able to access the connection\n   * even after the connection success event happened\n   */\n  protected database: ReplaySubject<IDBDatabase>;\n\n  /**\n   * Connects to IndexedDB\n   */\n  constructor(@Optional() @Inject(LOCAL_STORAGE_PREFIX) protected prefix: string | null = null) {\n\n    if (prefix) {\n\n      this.dbName = `${prefix}_${this.dbName}`;\n\n    }\n\n    /* Creating the RxJS ReplaySubject */\n    this.database = new ReplaySubject<IDBDatabase>();\n\n    /* Connecting to IndexedDB */\n    this.connect();\n\n  }\n\n  /**\n   * Gets an item value in local storage\n   * @param key The item's key\n   * @returns The item's value if the key exists, null otherwise, wrapped in an RxJS Observable\n   */\n  getItem<T = any>(key: string) {\n\n    /* Opening a trasaction and requesting the item in local storage */\n    return this.transaction().pipe(\n      map((transaction) => transaction.get(key)),\n      mergeMap((request) => {\n\n        /* Listening to the success event, and passing the item value if found, null otherwise */\n        const success = (fromEvent(request, 'success') as Observable<Event>).pipe(\n          map((event) => (event.target as IDBRequest).result),\n          map((result) => result && (this.dataPath in result) ? (result[this.dataPath] as T) : null)\n        );\n\n        /* Merging success and errors events and autoclosing the observable */\n        return (race(success, this.toErrorObservable(request, `getter`)) as Observable<T | null>)\n          .pipe(first());\n\n      }),\n      first()\n    );\n\n  }\n\n  /**\n   * Sets an item in local storage\n   * @param key The item's key\n   * @param data The item's value, must NOT be null or undefined\n   * @returns An RxJS Observable to wait the end of the operation\n   */\n  setItem(key: string, data: any) {\n\n    /* Storing null is not correctly supported by IndexedDB and unnecessary here */\n    if (data == null) {\n\n      return of(true);\n\n    }\n\n    /* Opening a transaction and checking if the item already exists in local storage */\n    return this.getItem(key).pipe(\n      map((existingData) => (existingData == null) ? 'add' : 'put'),\n      mergeMap((method) => {\n\n        /* Opening a transaction */\n        return this.transaction('readwrite').pipe(mergeMap((transaction) => {\n\n          let request: IDBRequest;\n\n          /* Adding or updating local storage, based on previous checking */\n          switch (method) {\n            case 'add':\n              request = transaction.add({ [this.dataPath]: data }, key);\n              break;\n            case 'put':\n            default:\n              request = transaction.put({ [this.dataPath]: data }, key);\n              break;\n          }\n\n          /* Merging success (passing true) and error events and autoclosing the observable */\n          return (race(this.toSuccessObservable(request), this.toErrorObservable(request, `setter`)) as Observable<boolean>)\n            .pipe(first());\n\n        }));\n\n      }),\n      first()\n    );\n\n  }\n\n  /**\n   * Deletes an item in local storage\n   * @param key The item's key\n   * @returns An RxJS Observable to wait the end of the operation\n   */\n  removeItem(key: string) {\n\n    /* Opening a transaction and checking if the item exists in local storage */\n    return this.getItem(key).pipe(\n      mergeMap((data) => {\n\n        /* If the item exists in local storage */\n        if (data != null) {\n\n          /* Opening a transaction */\n          return this.transaction('readwrite').pipe(mergeMap((transaction) => {\n\n            /* Deleting the item in local storage */\n            const request = transaction.delete(key);\n\n            /* Merging success (passing true) and error events and autoclosing the observable */\n            return (race(this.toSuccessObservable(request), this.toErrorObservable(request, `remover`)) as Observable<boolean>)\n              .pipe(first());\n\n          }));\n\n        }\n\n        /* Passing true if the item does not exist in local storage */\n        return of(true);\n\n      }),\n      first()\n    );\n\n  }\n\n  /**\n   * Deletes all items from local storage\n   * @returns An RxJS Observable to wait the end of the operation\n   */\n  clear() {\n\n    /* Opening a transaction */\n    return this.transaction('readwrite').pipe(\n      mergeMap((transaction) => {\n\n        /* Deleting all items from local storage */\n        const request = transaction.clear();\n\n        /* Merging success (passing true) and error events and autoclosing the observable */\n        return (race(this.toSuccessObservable(request), this.toErrorObservable(request, `clearer`)) as Observable<boolean>)\n          .pipe(first());\n\n      }),\n      first()\n    );\n\n  }\n\n  /**\n   * Connects to IndexedDB and creates the object store on first time\n   */\n  protected connect() {\n\n    /* Connecting to IndexedDB */\n    const request = indexedDB.open(this.dbName);\n\n    /* Listening the event fired on first connection, creating the object store for local storage */\n    (fromEvent(request, 'upgradeneeded') as Observable<Event>)\n      .pipe(first())\n      .subscribe((event) => {\n\n        /* Getting the database connection */\n        const database = (event.target as IDBRequest).result as IDBDatabase;\n\n        /* Checking if the object store already exists, to avoid error */\n        if (!database.objectStoreNames.contains(this.objectStoreName)) {\n\n          /* Creating the object store for local storage */\n          database.createObjectStore(this.objectStoreName);\n\n        }\n\n      });\n\n    /* Listening the success event and converting to an RxJS Observable */\n    const success = fromEvent(request, 'success') as Observable<Event>;\n\n    /* Merging success and errors events */\n    (race(success, this.toErrorObservable(request, `connection`)) as Observable<Event>)\n      .pipe(first())\n      .subscribe((event) => {\n\n        /* Storing the database connection for further access */\n        this.database.next((event.target as IDBRequest).result as IDBDatabase);\n\n      }, (error) => {\n\n        this.database.error(error as Error);\n\n      });\n\n  }\n\n  /**\n   * Opens an IndexedDB transaction and gets the local storage object store\n   * @param mode Default to 'readonly' for read operations, or 'readwrite' for write operations\n   * @returns An IndexedDB transaction object store, wrapped in an RxJS Observable\n   */\n  protected transaction(mode: 'readonly' | 'readwrite' = 'readonly') {\n\n    /* From the IndexedDB connection, opening a transaction and getting the local storage objet store */\n    return this.database\n      .pipe(map((database) => database.transaction([this.objectStoreName], mode).objectStore(this.objectStoreName)));\n\n  }\n\n  /**\n   * Transforms a IndexedDB success event in an RxJS Observable\n   * @param request The request to listen\n   * @returns A RxJS Observable with true value\n   */\n  protected toSuccessObservable(request: IDBRequest) {\n\n    /* Transforming a IndexedDB success event in an RxJS Observable with true value */\n    return (fromEvent(request, 'success') as Observable<Event>)\n      .pipe(map(() => true));\n\n  }\n\n  /**\n   * Transforms a IndexedDB error event in an RxJS ErrorObservable\n   * @param request The request to listen\n   * @param error Optionnal details about the error's origin\n   * @returns A RxJS ErrorObservable\n   */\n  protected toErrorObservable(request: IDBRequest, error = ``) {\n\n    /* Transforming a IndexedDB error event in an RxJS ErrorObservable */\n    return (fromEvent(request, 'error') as Observable<Event>)\n      .pipe(mergeMap((event) => throwError(new Error(`IndexedDB ${error} issue : ${request.error.message}.`))));\n\n  }\n\n}\n","import { Injectable, Optional, Inject } from '@angular/core';\nimport { Observable, of, throwError } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nimport { LocalDatabase } from './local-database';\nimport { LOCAL_STORAGE_PREFIX } from '../../tokens';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class LocalStorageDatabase implements LocalDatabase {\n\n  /* Initializing native localStorage right now to be able to check its support on class instanciation */\n  protected prefix = '';\n\n  constructor(@Optional() @Inject(LOCAL_STORAGE_PREFIX) protected userPrefix: string | null = null) {\n\n    if (userPrefix) {\n      this.prefix = `${userPrefix}_`;\n    }\n\n  }\n\n  /**\n   * Gets an item value in local storage\n   * @param key The item's key\n   * @returns The item's value if the key exists, null otherwise, wrapped in an RxJS Observable\n   */\n  getItem<T = any>(key: string): Observable<T | null> {\n\n    const unparsedData = localStorage.getItem(`${this.prefix}${key}`);\n    let parsedData: T | null = null;\n\n    if (unparsedData != null) {\n\n      try {\n        parsedData = JSON.parse(unparsedData);\n      } catch (error) {\n        return throwError(new Error(`Invalid data in localStorage.`));\n      }\n\n    }\n\n    return of(parsedData);\n\n  }\n\n  /**\n   * Sets an item in local storage\n   * @param key The item's key\n   * @param data The item's value, must NOT be null or undefined\n   * @returns An RxJS Observable to wait the end of the operation\n   */\n  setItem(key: string, data: any) {\n\n    localStorage.setItem(`${this.prefix}${key}`, JSON.stringify(data));\n\n    return of(true);\n\n  }\n\n  /**\n   * Deletes an item in local storage\n   * @param key The item's key\n   * @returns An RxJS Observable to wait the end of the operation\n   */\n  removeItem(key: string) {\n\n    localStorage.removeItem(`${this.prefix}${key}`);\n\n    return of(true);\n\n  }\n\n  /**\n   * Deletes all items from local storage\n   * @returns An RxJS Observable to wait the end of the operation\n   */\n  clear() {\n\n    localStorage.clear();\n\n    return of(true);\n\n  }\n\n}\n","import { Injectable } from '@angular/core';\nimport { Observable, of } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nimport { LocalDatabase } from './local-database';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class MockLocalDatabase implements LocalDatabase {\n\n  protected localStorage = new Map<string, any>();\n\n  /**\n   * Gets an item value in local storage\n   * @param key The item's key\n   * @returns The item's value if the key exists, null otherwise, wrapped in an RxJS Observable\n   */\n   getItem<T = any>(key: string) {\n\n    const rawData: T | null = this.localStorage.get(key);\n\n    return of((rawData !== undefined) ? rawData : null);\n\n  }\n\n  /**\n   * Sets an item in local storage\n   * @param key The item's key\n   * @param data The item's value, must NOT be null or undefined\n   * @returns An RxJS Observable to wait the end of the operation\n   */\n   setItem(key: string, data: any) {\n\n    this.localStorage.set(key, data);\n\n    return of(true);\n\n  }\n\n  /**\n   * Deletes an item in local storage\n   * @param key The item's key\n   * @returns An RxJS Observable to wait the end of the operation\n   */\n   removeItem(key: string) {\n\n    this.localStorage.delete(key);\n\n    return of(true);\n\n  }\n\n  /**\n   * Deletes all items from local storage\n   * @returns An RxJS Observable to wait the end of the operation\n   */\n   clear() {\n\n    this.localStorage.clear();\n\n    return of(true);\n\n  }\n\n}\n","import { Injectable } from '@angular/core';\nimport { JSONSchema } from './json-schema';\n\n/**\n * @todo Add other JSON Schema validation features\n */\n@Injectable({\n  providedIn: 'root'\n})\nexport class JSONValidator {\n\n  /**\n   * Validate a JSON data against a JSON Schema\n   * @param data JSON data to validate\n   * @param schema Subset of JSON Schema.\n   * Types are enforced to validate everything:\n   * each value MUST have 'type' or 'properties' or 'items' or 'const' or 'enum'.\n   * Therefore, unlike the spec, booleans are not allowed as schemas.\n   * Not all validation features are supported: just follow the interface.\n   * @returns If data is valid : true, if it is invalid : false, and throws if the schema is invalid\n   */\n  validate(data: any, schema: JSONSchema): boolean {\n\n    /** @todo When TS 2.8, explore if this is possible with conditional types */\n    if (((!(schema.hasOwnProperty('const') && schema.const !== undefined)\n    && !(schema.hasOwnProperty('enum') && schema.enum != null) && !(schema.hasOwnProperty('type') && schema.type != null))\n    || schema.type === 'array' || schema.type === 'object')\n    && !(schema.hasOwnProperty('properties') && schema.properties != null)  && !(schema.hasOwnProperty('items') && schema.items != null)) {\n\n      throw new Error(`Each value must have a 'type' or 'properties' or 'items' or 'const' or 'enum', to enforce strict types.`);\n\n    }\n\n    if (schema.hasOwnProperty('const') && schema.const !== undefined && (data !== schema.const)) {\n      return false;\n    }\n\n    if (!this.validateEnum(data, schema)) {\n      return false;\n    }\n\n    if (!this.validateType(data, schema)) {\n      return false;\n    }\n\n    if (!this.validateItems(data, schema)) {\n      return false;\n    }\n\n    if (!this.validateProperties(data, schema)) {\n      return false;\n    }\n\n    if (!this.validateRequired(data, schema)) {\n      return false;\n    }\n\n    return true;\n\n  }\n\n  protected isObjectNotNull(value: any): boolean {\n\n    return (value !== null) && (typeof value === 'object');\n\n  }\n\n  protected validateProperties(data: {}, schema: JSONSchema): boolean {\n\n    if (!schema.hasOwnProperty('properties') || (schema.properties == null)) {\n      return true;\n    }\n\n    if (!this.isObjectNotNull(data)) {\n\n      return false;\n\n    }\n\n    /**\n     * Check if the object doesn't have more properties than expected\n     * Equivalent of additionalProperties: false\n     */\n    if (Object.keys(schema.properties).length !== Object.keys(data).length) {\n\n      return false;\n\n    }\n\n    /* Recursively validate all properties */\n    for (let property in schema.properties) {\n\n      if (schema.properties.hasOwnProperty(property) && data.hasOwnProperty(property)) {\n\n        if (!this.validate(data[property], schema.properties[property])) {\n\n          return false;\n\n        }\n\n      }\n\n    }\n\n    return true;\n\n  }\n\n  protected validateRequired(data: {}, schema: JSONSchema): boolean {\n\n    if (!schema.hasOwnProperty('required') || (schema.required == null)) {\n      return true;\n    }\n\n    if (!this.isObjectNotNull(data)) {\n\n      return false;\n\n    }\n\n    for (let requiredProp of schema.required) {\n\n      /* Checks if the property is present in the schema 'properties' */\n      if (!schema.properties || !schema.properties.hasOwnProperty(requiredProp)) {\n\n        throw new Error(`'required' properties must be described in 'properties' too.`);\n\n      }\n\n      /* Checks if the property is present in the data */\n      if (!data.hasOwnProperty(requiredProp)) {\n\n        return false;\n\n      }\n\n    }\n\n    return true;\n\n  }\n\n  protected validateEnum(data: any, schema: JSONSchema): boolean {\n\n    if (!schema.hasOwnProperty('enum') || (schema.enum == null)) {\n      return true;\n    }\n\n    /** @todo Move to ES2016 .includes() ? */\n    return (schema.enum.indexOf(data) !== -1);\n\n  }\n\n  protected validateType(data: any, schema: JSONSchema): boolean {\n\n    if (!schema.hasOwnProperty('type') || (schema.type == null)) {\n      return true;\n    }\n\n    switch (schema.type) {\n\n      case 'null':\n        return data === null;\n      case 'string':\n        return this.validateString(data, schema);\n      case 'number':\n      case 'integer':\n        return this.validateNumber(data, schema);\n      case 'boolean':\n        return typeof data === 'boolean';\n      case 'object':\n        return typeof data === 'object';\n      case 'array':\n        return Array.isArray(data);\n\n    }\n\n  }\n\n  protected validateItems(data: any[], schema: JSONSchema): boolean {\n\n    if (!schema.hasOwnProperty('items') || (schema.items == null)) {\n      return true;\n    }\n\n    if (!Array.isArray(data)) {\n\n      return false;\n\n    }\n\n    if (schema.hasOwnProperty('maxItems') && (schema.maxItems != null)) {\n\n      if (!Number.isInteger(schema.maxItems) || schema.maxItems < 0) {\n\n        throw new Error(`'maxItems' must be a non-negative integer.`);\n\n      }\n\n      if (data.length > schema.maxItems) {\n        return false;\n      }\n\n    }\n\n    if (schema.hasOwnProperty('minItems') && (schema.minItems != null)) {\n\n      if (!Number.isInteger(schema.minItems) || schema.minItems < 0) {\n\n        throw new Error(`'minItems' must be a non-negative integer.`);\n\n      }\n\n      if (data.length < schema.minItems) {\n        return false;\n      }\n\n    }\n\n    if (schema.hasOwnProperty('uniqueItems') && (schema.uniqueItems != null)) {\n\n      if (schema.uniqueItems) {\n\n        const dataSet = new Set(data);\n\n        if (data.length !== dataSet.size) {\n          return false;\n        }\n\n      }\n\n    }\n\n    if (Array.isArray(schema.items)) {\n\n      return this.validateItemsList(data, schema);\n\n    }\n\n    for (let value of data) {\n\n      if (!this.validate(value, schema.items)) {\n        return false;\n      }\n\n    }\n\n    return true;\n\n  }\n\n  protected validateItemsList(data: any, schema: JSONSchema): boolean {\n\n    const items = schema.items as JSONSchema[];\n\n    if (data.length !== items.length) {\n\n      return false;\n\n    }\n\n    for (let i = 0; i < items.length; i += 1) {\n\n      if (!this.validate(data[i], items[i])) {\n        return false;\n      }\n\n    }\n\n    return true;\n\n  }\n\n  protected validateString(data: any, schema: JSONSchema): boolean {\n\n    if (typeof data !== 'string') {\n      return false;\n    }\n\n    if (schema.hasOwnProperty('maxLength') && (schema.maxLength != null)) {\n\n      if (!Number.isInteger(schema.maxLength) || schema.maxLength < 0) {\n\n        throw new Error(`'maxLength' must be a non-negative integer.`);\n\n      }\n\n      if (data.length > schema.maxLength) {\n        return false;\n      }\n\n    }\n\n    if (schema.hasOwnProperty('minLength') && (schema.minLength != null)) {\n\n      if (!Number.isInteger(schema.minLength) || schema.minLength < 0) {\n\n        throw new Error(`'minLength' must be a non-negative integer.`);\n\n      }\n\n      if (data.length < schema.minLength) {\n        return false;\n      }\n\n    }\n\n    if (schema.hasOwnProperty('pattern') && (schema.pattern != null)) {\n\n      const regularExpression = new RegExp(schema.pattern);\n\n      if (!regularExpression.test(data)) {\n        return false;\n      }\n\n    }\n\n    return true;\n\n  }\n\n  protected validateNumber(data: any, schema: JSONSchema): boolean {\n\n    if (typeof data !== 'number') {\n      return false;\n    }\n\n    if ((schema.type === 'integer') && !Number.isInteger(data)) {\n      return false;\n    }\n\n    if (schema.hasOwnProperty('multipleOf') && (schema.multipleOf != null)) {\n\n      if (schema.multipleOf <= 0) {\n\n        throw new Error(`'multipleOf' must be a number strictly greater than 0.`);\n\n      }\n\n      if (!Number.isInteger(data / schema.multipleOf)) {\n        return false;\n      }\n\n    }\n\n    if (schema.hasOwnProperty('maximum') && (schema.maximum != null)) {\n\n      if (data > schema.maximum) {\n        return false;\n      }\n\n    }\n\n    if (schema.hasOwnProperty('exclusiveMaximum') && (schema.exclusiveMaximum != null)) {\n\n      if (data >= schema.exclusiveMaximum) {\n        return false;\n      }\n\n    }\n\n    if (schema.hasOwnProperty('minimum') && (schema.minimum != null)) {\n\n      if (data < schema.minimum) {\n        return false;\n      }\n\n    }\n\n    if (schema.hasOwnProperty('exclusiveMinimum') && (schema.exclusiveMinimum != null)) {\n\n      if (data <= schema.exclusiveMinimum) {\n        return false;\n      }\n\n    }\n\n    return true;\n\n  }\n\n}\n","import { Inject, Injectable } from '@angular/core';\nimport { Observable, throwError, of } from 'rxjs';\nimport { mergeMap } from 'rxjs/operators';\n\nimport { LocalDatabase } from './databases/local-database';\nimport { JSONSchema } from './validation/json-schema';\nimport { JSONValidator } from './validation/json-validator';\n\nexport interface LSGetItemOptions {\n  schema?: JSONSchema | null;\n}\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class LocalStorage {\n\n  protected readonly getItemOptionsDefault: LSGetItemOptions = {\n    schema: null\n  };\n\n  constructor(protected database: LocalDatabase, protected jsonValidator: JSONValidator) {}\n\n  /**\n   * Gets an item value in local storage\n   * @param key The item's key\n   * @returns The item's value if the key exists, null otherwise, wrapped in an RxJS Observable\n   */\n  getItem<T = any>(key: string, options: LSGetItemOptions = this.getItemOptionsDefault): Observable<T | null> {\n\n    return this.database.getItem<T>(key).pipe(\n\n      /* Validate data upon a json schema if requested */\n      mergeMap((data) => {\n\n        if (options.schema && data !== null) {\n\n          let validation = true;\n\n          try {\n            validation = this.jsonValidator.validate(data, options.schema);\n          } catch (error) {\n            return throwError(error);\n          }\n\n          if (!validation) {\n            return throwError(new Error(`JSON invalid`));\n          }\n\n        }\n\n        return of(data);\n\n      }));\n\n  }\n\n  /**\n   * Sets an item in local storage\n   * @param key The item's key\n   * @param data The item's value, must NOT be null or undefined\n   * @returns An RxJS Observable to wait the end of the operation\n   */\n   setItem(key: string, data: any): Observable<boolean> {\n\n    return this.database.setItem(key, data);\n\n  }\n\n  /**\n   * Deletes an item in local storage\n   * @param key The item's key\n   * @returns An RxJS Observable to wait the end of the operation\n   */\n   removeItem(key: string): Observable<boolean> {\n\n    return this.database.removeItem(key);\n\n  }\n\n  /**\n   * Deletes all items from local storage\n   * @returns An RxJS Observable to wait the end of the operation\n   */\n   clear(): Observable<boolean> {\n\n    return this.database.clear();\n\n  }\n\n  /**\n   * Sets an item in local storage, and auto-subscribes\n   * @param key The item's key\n   * @param data The item's value, must NOT be null or undefined\n   */\n  setItemSubscribe(key: string, data: any): void {\n\n    this.setItem(key, data).subscribe(() => {}, () => {});\n\n  }\n\n  /**\n   * Deletes an item in local storage, and auto-subscribes\n   * @param key The item's key\n   */\n   removeItemSubscribe(key: string): void {\n\n    this.removeItem(key).subscribe(() => {}, () => {});\n\n  }\n\n  /** Deletes all items from local storage, and auto-subscribes */\n  clearSubscribe(): void {\n\n    this.clear().subscribe(() => {}, () => {});\n\n  }\n\n}\n"],"names":["platformId","prefix","isPlatformBrowser","window","undefined","indexedDB","IndexedDBDatabase","localStorage","LocalStorageDatabase","MockLocalDatabase","LOCAL_STORAGE_PREFIX","InjectionToken","providedIn","factory","this","dbName","database","ReplaySubject","connect","key","transaction","pipe","map","get","mergeMap","request","success","fromEvent","event","result","_this","dataPath","race","toErrorObservable","first","data","of","getItem","existingData","method","add","_a","put","_b","toSuccessObservable","delete","clear","open","subscribe","objectStoreNames","contains","objectStoreName","createObjectStore","next","error","mode","objectStore","throwError","Error","message","Injectable","Optional","Inject","userPrefix","unparsedData","parsedData","JSON","parse","setItem","stringify","removeItem","Map","rawData","set","useFactory","localDatabaseFactory","deps","PLATFORM_ID","JSONValidator","schema","hasOwnProperty","const","enum","type","properties","items","validateEnum","validateType","validateItems","validateProperties","validateRequired","value","isObjectNotNull","Object","keys","length","property","validate","required","_i","requiredProp","indexOf","validateString","validateNumber","Array","isArray","maxItems","Number","isInteger","minItems","uniqueItems","dataSet","Set","size","validateItemsList","data_1","i","maxLength","minLength","pattern","RegExp","test","multipleOf","maximum","exclusiveMaximum","minimum","exclusiveMinimum","jsonValidator","LocalStorage","options","getItemOptionsDefault","validation","LocalDatabase","config","provide","useValue"],"mappings":"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"}