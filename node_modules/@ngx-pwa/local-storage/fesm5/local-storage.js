import { Inject, Injectable, InjectionToken, Optional, PLATFORM_ID, defineInjectable, inject } from '@angular/core';
import * as i0 from '@angular/core';
import { isPlatformBrowser } from '@angular/common';
import { ReplaySubject, fromEvent, of, race, throwError } from 'rxjs';
import { first, map, mergeMap } from 'rxjs/operators';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var LOCAL_STORAGE_PREFIX = new InjectionToken('localStoragePrefix', { providedIn: 'root', factory: function () { return ''; } });
/**
 * @record
 */

/**
 * @param {?} config
 * @return {?}
 */
function localStorageProviders(config) {
    return [
        config.prefix ? { provide: LOCAL_STORAGE_PREFIX, useValue: config.prefix } : []
    ];
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var IndexedDBDatabase = /** @class */ (function () {
    /**
     * Connects to IndexedDB
     */
    function IndexedDBDatabase(prefix) {
        if (prefix === void 0) { prefix = null; }
        this.prefix = prefix;
        /**
         * IndexedDB database name for local storage
         */
        this.dbName = 'ngStorage';
        /**
         * IndexedDB object store name for local storage
         */
        this.objectStoreName = 'localStorage';
        /**
         * IndexedDB key path name for local storage (where an item's key will be stored)
         */
        this.keyPath = 'key';
        /**
         * IndexedDB data path name for local storage (where items' value will be stored)
         */
        this.dataPath = 'value';
        if (prefix) {
            this.dbName = prefix + "_" + this.dbName;
        }
        /* Creating the RxJS ReplaySubject */
        this.database = new ReplaySubject();
        /* Connecting to IndexedDB */
        this.connect();
    }
    /**
     * Gets an item value in local storage
     * @param key The item's key
     * @returns The item's value if the key exists, null otherwise, wrapped in an RxJS Observable
     */
    /**
     * Gets an item value in local storage
     * @template T
     * @param {?} key The item's key
     * @return {?} The item's value if the key exists, null otherwise, wrapped in an RxJS Observable
     */
    IndexedDBDatabase.prototype.getItem = /**
     * Gets an item value in local storage
     * @template T
     * @param {?} key The item's key
     * @return {?} The item's value if the key exists, null otherwise, wrapped in an RxJS Observable
     */
    function (key) {
        var _this = this;
        /* Opening a trasaction and requesting the item in local storage */
        return this.transaction().pipe(map(function (transaction) { return transaction.get(key); }), mergeMap(function (request) {
            /* Listening to the success event, and passing the item value if found, null otherwise */
            var /** @type {?} */ success = (/** @type {?} */ (fromEvent(request, 'success'))).pipe(map(function (event) { return (/** @type {?} */ (event.target)).result; }), map(function (result) { return result && (_this.dataPath in result) ? (/** @type {?} */ (result[_this.dataPath])) : null; }));
            /* Merging success and errors events and autoclosing the observable */
            return (/** @type {?} */ (race(success, _this.toErrorObservable(request, "getter"))))
                .pipe(first());
        }), first());
    };
    /**
     * Sets an item in local storage
     * @param key The item's key
     * @param data The item's value, must NOT be null or undefined
     * @returns An RxJS Observable to wait the end of the operation
     */
    /**
     * Sets an item in local storage
     * @param {?} key The item's key
     * @param {?} data The item's value, must NOT be null or undefined
     * @return {?} An RxJS Observable to wait the end of the operation
     */
    IndexedDBDatabase.prototype.setItem = /**
     * Sets an item in local storage
     * @param {?} key The item's key
     * @param {?} data The item's value, must NOT be null or undefined
     * @return {?} An RxJS Observable to wait the end of the operation
     */
    function (key, data) {
        var _this = this;
        /* Storing null is not correctly supported by IndexedDB and unnecessary here */
        if (data == null) {
            return of(true);
        }
        /* Opening a transaction and checking if the item already exists in local storage */
        return this.getItem(key).pipe(map(function (existingData) { return (existingData == null) ? 'add' : 'put'; }), mergeMap(function (method) {
            /* Opening a transaction */
            return _this.transaction('readwrite').pipe(mergeMap(function (transaction) {
                var /** @type {?} */ request;
                /* Adding or updating local storage, based on previous checking */
                switch (method) {
                    case 'add':
                        request = transaction.add((_a = {}, _a[_this.dataPath] = data, _a), key);
                        break;
                    case 'put':
                    default:
                        request = transaction.put((_b = {}, _b[_this.dataPath] = data, _b), key);
                        break;
                }
                /* Merging success (passing true) and error events and autoclosing the observable */
                return (/** @type {?} */ (race(_this.toSuccessObservable(request), _this.toErrorObservable(request, "setter"))))
                    .pipe(first());
                var _a, _b;
            }));
        }), first());
    };
    /**
     * Deletes an item in local storage
     * @param key The item's key
     * @returns An RxJS Observable to wait the end of the operation
     */
    /**
     * Deletes an item in local storage
     * @param {?} key The item's key
     * @return {?} An RxJS Observable to wait the end of the operation
     */
    IndexedDBDatabase.prototype.removeItem = /**
     * Deletes an item in local storage
     * @param {?} key The item's key
     * @return {?} An RxJS Observable to wait the end of the operation
     */
    function (key) {
        var _this = this;
        /* Opening a transaction and checking if the item exists in local storage */
        return this.getItem(key).pipe(mergeMap(function (data) {
            /* If the item exists in local storage */
            if (data != null) {
                /* Opening a transaction */
                return _this.transaction('readwrite').pipe(mergeMap(function (transaction) {
                    /* Deleting the item in local storage */
                    var /** @type {?} */ request = transaction.delete(key);
                    /* Merging success (passing true) and error events and autoclosing the observable */
                    return (/** @type {?} */ (race(_this.toSuccessObservable(request), _this.toErrorObservable(request, "remover"))))
                        .pipe(first());
                }));
            }
            /* Passing true if the item does not exist in local storage */
            return of(true);
        }), first());
    };
    /**
     * Deletes all items from local storage
     * @returns An RxJS Observable to wait the end of the operation
     */
    /**
     * Deletes all items from local storage
     * @return {?} An RxJS Observable to wait the end of the operation
     */
    IndexedDBDatabase.prototype.clear = /**
     * Deletes all items from local storage
     * @return {?} An RxJS Observable to wait the end of the operation
     */
    function () {
        var _this = this;
        /* Opening a transaction */
        return this.transaction('readwrite').pipe(mergeMap(function (transaction) {
            /* Deleting all items from local storage */
            var /** @type {?} */ request = transaction.clear();
            /* Merging success (passing true) and error events and autoclosing the observable */
            return (/** @type {?} */ (race(_this.toSuccessObservable(request), _this.toErrorObservable(request, "clearer"))))
                .pipe(first());
        }), first());
    };
    /**
     * Connects to IndexedDB and creates the object store on first time
     */
    /**
     * Connects to IndexedDB and creates the object store on first time
     * @return {?}
     */
    IndexedDBDatabase.prototype.connect = /**
     * Connects to IndexedDB and creates the object store on first time
     * @return {?}
     */
    function () {
        var _this = this;
        /* Connecting to IndexedDB */
        var /** @type {?} */ request = indexedDB.open(this.dbName);
        /* Listening the event fired on first connection, creating the object store for local storage */
        (/** @type {?} */ (fromEvent(request, 'upgradeneeded')))
            .pipe(first())
            .subscribe(function (event) {
            /* Getting the database connection */
            var /** @type {?} */ database = /** @type {?} */ ((/** @type {?} */ (event.target)).result);
            /* Checking if the object store already exists, to avoid error */
            if (!database.objectStoreNames.contains(_this.objectStoreName)) {
                /* Creating the object store for local storage */
                database.createObjectStore(_this.objectStoreName);
            }
        });
        /* Listening the success event and converting to an RxJS Observable */
        var /** @type {?} */ success = /** @type {?} */ (fromEvent(request, 'success'));
        /* Merging success and errors events */
        (/** @type {?} */ (race(success, this.toErrorObservable(request, "connection"))))
            .pipe(first())
            .subscribe(function (event) {
            /* Storing the database connection for further access */
            /* Storing the database connection for further access */
            _this.database.next(/** @type {?} */ ((/** @type {?} */ (event.target)).result));
        }, function (error) {
            _this.database.error(/** @type {?} */ (error));
        });
    };
    /**
     * Opens an IndexedDB transaction and gets the local storage object store
     * @param mode Default to 'readonly' for read operations, or 'readwrite' for write operations
     * @returns An IndexedDB transaction object store, wrapped in an RxJS Observable
     */
    /**
     * Opens an IndexedDB transaction and gets the local storage object store
     * @param {?=} mode Default to 'readonly' for read operations, or 'readwrite' for write operations
     * @return {?} An IndexedDB transaction object store, wrapped in an RxJS Observable
     */
    IndexedDBDatabase.prototype.transaction = /**
     * Opens an IndexedDB transaction and gets the local storage object store
     * @param {?=} mode Default to 'readonly' for read operations, or 'readwrite' for write operations
     * @return {?} An IndexedDB transaction object store, wrapped in an RxJS Observable
     */
    function (mode) {
        var _this = this;
        if (mode === void 0) { mode = 'readonly'; }
        /* From the IndexedDB connection, opening a transaction and getting the local storage objet store */
        return this.database
            .pipe(map(function (database) { return database.transaction([_this.objectStoreName], mode).objectStore(_this.objectStoreName); }));
    };
    /**
     * Transforms a IndexedDB success event in an RxJS Observable
     * @param request The request to listen
     * @returns A RxJS Observable with true value
     */
    /**
     * Transforms a IndexedDB success event in an RxJS Observable
     * @param {?} request The request to listen
     * @return {?} A RxJS Observable with true value
     */
    IndexedDBDatabase.prototype.toSuccessObservable = /**
     * Transforms a IndexedDB success event in an RxJS Observable
     * @param {?} request The request to listen
     * @return {?} A RxJS Observable with true value
     */
    function (request) {
        /* Transforming a IndexedDB success event in an RxJS Observable with true value */
        return (/** @type {?} */ (fromEvent(request, 'success')))
            .pipe(map(function () { return true; }));
    };
    /**
     * Transforms a IndexedDB error event in an RxJS ErrorObservable
     * @param request The request to listen
     * @param error Optionnal details about the error's origin
     * @returns A RxJS ErrorObservable
     */
    /**
     * Transforms a IndexedDB error event in an RxJS ErrorObservable
     * @param {?} request The request to listen
     * @param {?=} error Optionnal details about the error's origin
     * @return {?} A RxJS ErrorObservable
     */
    IndexedDBDatabase.prototype.toErrorObservable = /**
     * Transforms a IndexedDB error event in an RxJS ErrorObservable
     * @param {?} request The request to listen
     * @param {?=} error Optionnal details about the error's origin
     * @return {?} A RxJS ErrorObservable
     */
    function (request, error) {
        if (error === void 0) { error = ""; }
        /* Transforming a IndexedDB error event in an RxJS ErrorObservable */
        return (/** @type {?} */ (fromEvent(request, 'error')))
            .pipe(mergeMap(function (event) { return throwError(new Error("IndexedDB " + error + " issue : " + request.error.message + ".")); }));
    };
    IndexedDBDatabase.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] },
    ];
    /** @nocollapse */
    IndexedDBDatabase.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [LOCAL_STORAGE_PREFIX,] },] },
    ]; };
    /** @nocollapse */ IndexedDBDatabase.ngInjectableDef = defineInjectable({ factory: function IndexedDBDatabase_Factory() { return new IndexedDBDatabase(inject(LOCAL_STORAGE_PREFIX, 8)); }, token: IndexedDBDatabase, providedIn: "root" });
    return IndexedDBDatabase;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var LocalStorageDatabase = /** @class */ (function () {
    function LocalStorageDatabase(userPrefix) {
        if (userPrefix === void 0) { userPrefix = null; }
        this.userPrefix = userPrefix;
        /* Initializing native localStorage right now to be able to check its support on class instanciation */
        this.prefix = '';
        if (userPrefix) {
            this.prefix = userPrefix + "_";
        }
    }
    /**
     * Gets an item value in local storage
     * @param key The item's key
     * @returns The item's value if the key exists, null otherwise, wrapped in an RxJS Observable
     */
    /**
     * Gets an item value in local storage
     * @template T
     * @param {?} key The item's key
     * @return {?} The item's value if the key exists, null otherwise, wrapped in an RxJS Observable
     */
    LocalStorageDatabase.prototype.getItem = /**
     * Gets an item value in local storage
     * @template T
     * @param {?} key The item's key
     * @return {?} The item's value if the key exists, null otherwise, wrapped in an RxJS Observable
     */
    function (key) {
        var /** @type {?} */ unparsedData = localStorage.getItem("" + this.prefix + key);
        var /** @type {?} */ parsedData = null;
        if (unparsedData != null) {
            try {
                parsedData = JSON.parse(unparsedData);
            }
            catch (/** @type {?} */ error) {
                return throwError(new Error("Invalid data in localStorage."));
            }
        }
        return of(parsedData);
    };
    /**
     * Sets an item in local storage
     * @param key The item's key
     * @param data The item's value, must NOT be null or undefined
     * @returns An RxJS Observable to wait the end of the operation
     */
    /**
     * Sets an item in local storage
     * @param {?} key The item's key
     * @param {?} data The item's value, must NOT be null or undefined
     * @return {?} An RxJS Observable to wait the end of the operation
     */
    LocalStorageDatabase.prototype.setItem = /**
     * Sets an item in local storage
     * @param {?} key The item's key
     * @param {?} data The item's value, must NOT be null or undefined
     * @return {?} An RxJS Observable to wait the end of the operation
     */
    function (key, data) {
        localStorage.setItem("" + this.prefix + key, JSON.stringify(data));
        return of(true);
    };
    /**
     * Deletes an item in local storage
     * @param key The item's key
     * @returns An RxJS Observable to wait the end of the operation
     */
    /**
     * Deletes an item in local storage
     * @param {?} key The item's key
     * @return {?} An RxJS Observable to wait the end of the operation
     */
    LocalStorageDatabase.prototype.removeItem = /**
     * Deletes an item in local storage
     * @param {?} key The item's key
     * @return {?} An RxJS Observable to wait the end of the operation
     */
    function (key) {
        localStorage.removeItem("" + this.prefix + key);
        return of(true);
    };
    /**
     * Deletes all items from local storage
     * @returns An RxJS Observable to wait the end of the operation
     */
    /**
     * Deletes all items from local storage
     * @return {?} An RxJS Observable to wait the end of the operation
     */
    LocalStorageDatabase.prototype.clear = /**
     * Deletes all items from local storage
     * @return {?} An RxJS Observable to wait the end of the operation
     */
    function () {
        localStorage.clear();
        return of(true);
    };
    LocalStorageDatabase.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] },
    ];
    /** @nocollapse */
    LocalStorageDatabase.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [LOCAL_STORAGE_PREFIX,] },] },
    ]; };
    /** @nocollapse */ LocalStorageDatabase.ngInjectableDef = defineInjectable({ factory: function LocalStorageDatabase_Factory() { return new LocalStorageDatabase(inject(LOCAL_STORAGE_PREFIX, 8)); }, token: LocalStorageDatabase, providedIn: "root" });
    return LocalStorageDatabase;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var MockLocalDatabase = /** @class */ (function () {
    function MockLocalDatabase() {
        this.localStorage = new Map();
    }
    /**
     * Gets an item value in local storage
     * @param key The item's key
     * @returns The item's value if the key exists, null otherwise, wrapped in an RxJS Observable
     */
    /**
     * Gets an item value in local storage
     * @template T
     * @param {?} key The item's key
     * @return {?} The item's value if the key exists, null otherwise, wrapped in an RxJS Observable
     */
    MockLocalDatabase.prototype.getItem = /**
     * Gets an item value in local storage
     * @template T
     * @param {?} key The item's key
     * @return {?} The item's value if the key exists, null otherwise, wrapped in an RxJS Observable
     */
    function (key) {
        var /** @type {?} */ rawData = this.localStorage.get(key);
        return of((rawData !== undefined) ? rawData : null);
    };
    /**
     * Sets an item in local storage
     * @param key The item's key
     * @param data The item's value, must NOT be null or undefined
     * @returns An RxJS Observable to wait the end of the operation
     */
    /**
     * Sets an item in local storage
     * @param {?} key The item's key
     * @param {?} data The item's value, must NOT be null or undefined
     * @return {?} An RxJS Observable to wait the end of the operation
     */
    MockLocalDatabase.prototype.setItem = /**
     * Sets an item in local storage
     * @param {?} key The item's key
     * @param {?} data The item's value, must NOT be null or undefined
     * @return {?} An RxJS Observable to wait the end of the operation
     */
    function (key, data) {
        this.localStorage.set(key, data);
        return of(true);
    };
    /**
     * Deletes an item in local storage
     * @param key The item's key
     * @returns An RxJS Observable to wait the end of the operation
     */
    /**
     * Deletes an item in local storage
     * @param {?} key The item's key
     * @return {?} An RxJS Observable to wait the end of the operation
     */
    MockLocalDatabase.prototype.removeItem = /**
     * Deletes an item in local storage
     * @param {?} key The item's key
     * @return {?} An RxJS Observable to wait the end of the operation
     */
    function (key) {
        this.localStorage.delete(key);
        return of(true);
    };
    /**
     * Deletes all items from local storage
     * @returns An RxJS Observable to wait the end of the operation
     */
    /**
     * Deletes all items from local storage
     * @return {?} An RxJS Observable to wait the end of the operation
     */
    MockLocalDatabase.prototype.clear = /**
     * Deletes all items from local storage
     * @return {?} An RxJS Observable to wait the end of the operation
     */
    function () {
        this.localStorage.clear();
        return of(true);
    };
    MockLocalDatabase.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] },
    ];
    /** @nocollapse */ MockLocalDatabase.ngInjectableDef = defineInjectable({ factory: function MockLocalDatabase_Factory() { return new MockLocalDatabase(); }, token: MockLocalDatabase, providedIn: "root" });
    return MockLocalDatabase;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @param {?} platformId
 * @param {?} prefix
 * @return {?}
 */
function localDatabaseFactory(platformId, prefix) {
    if (isPlatformBrowser(platformId) && ('indexedDB' in window) && (indexedDB !== undefined) && (indexedDB !== null)) {
        /* Try with IndexedDB in modern browsers */
        return new IndexedDBDatabase(prefix);
    }
    else if (isPlatformBrowser(platformId) && ('localStorage' in window) && (localStorage !== undefined) && (localStorage !== null)) {
        /* Try with localStorage in old browsers (IE9) */
        return new LocalStorageDatabase(prefix);
    }
    else {
        /* Fake database for server-side rendering (Universal) */
        return new MockLocalDatabase();
    }
}

/**
 * @abstract
 */
var LocalDatabase = /** @class */ (function () {
    function LocalDatabase() {
    }
    LocalDatabase.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root',
                    useFactory: localDatabaseFactory,
                    deps: [
                        PLATFORM_ID,
                        [new Optional(), LOCAL_STORAGE_PREFIX]
                    ]
                },] },
    ];
    /** @nocollapse */ LocalDatabase.ngInjectableDef = defineInjectable({ factory: function LocalDatabase_Factory() { return localDatabaseFactory(inject(PLATFORM_ID), inject(LOCAL_STORAGE_PREFIX, 8)); }, token: LocalDatabase, providedIn: "root" });
    return LocalDatabase;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * \@todo Add other JSON Schema validation features
 */
var JSONValidator = /** @class */ (function () {
    function JSONValidator() {
    }
    /**
     * Validate a JSON data against a JSON Schema
     * @param data JSON data to validate
     * @param schema Subset of JSON Schema.
     * Types are enforced to validate everything:
     * each value MUST have 'type' or 'properties' or 'items' or 'const' or 'enum'.
     * Therefore, unlike the spec, booleans are not allowed as schemas.
     * Not all validation features are supported: just follow the interface.
     * @returns If data is valid : true, if it is invalid : false, and throws if the schema is invalid
     */
    /**
     * Validate a JSON data against a JSON Schema
     * @param {?} data JSON data to validate
     * @param {?} schema Subset of JSON Schema.
     * Types are enforced to validate everything:
     * each value MUST have 'type' or 'properties' or 'items' or 'const' or 'enum'.
     * Therefore, unlike the spec, booleans are not allowed as schemas.
     * Not all validation features are supported: just follow the interface.
     * @return {?} If data is valid : true, if it is invalid : false, and throws if the schema is invalid
     */
    JSONValidator.prototype.validate = /**
     * Validate a JSON data against a JSON Schema
     * @param {?} data JSON data to validate
     * @param {?} schema Subset of JSON Schema.
     * Types are enforced to validate everything:
     * each value MUST have 'type' or 'properties' or 'items' or 'const' or 'enum'.
     * Therefore, unlike the spec, booleans are not allowed as schemas.
     * Not all validation features are supported: just follow the interface.
     * @return {?} If data is valid : true, if it is invalid : false, and throws if the schema is invalid
     */
    function (data, schema) {
        /** @todo When TS 2.8, explore if this is possible with conditional types */
        if (((!(schema.hasOwnProperty('const') && schema.const !== undefined)
            && !(schema.hasOwnProperty('enum') && schema.enum != null) && !(schema.hasOwnProperty('type') && schema.type != null))
            || schema.type === 'array' || schema.type === 'object')
            && !(schema.hasOwnProperty('properties') && schema.properties != null) && !(schema.hasOwnProperty('items') && schema.items != null)) {
            throw new Error("Each value must have a 'type' or 'properties' or 'items' or 'const' or 'enum', to enforce strict types.");
        }
        if (schema.hasOwnProperty('const') && schema.const !== undefined && (data !== schema.const)) {
            return false;
        }
        if (!this.validateEnum(data, schema)) {
            return false;
        }
        if (!this.validateType(data, schema)) {
            return false;
        }
        if (!this.validateItems(data, schema)) {
            return false;
        }
        if (!this.validateProperties(data, schema)) {
            return false;
        }
        if (!this.validateRequired(data, schema)) {
            return false;
        }
        return true;
    };
    /**
     * @param {?} value
     * @return {?}
     */
    JSONValidator.prototype.isObjectNotNull = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        return (value !== null) && (typeof value === 'object');
    };
    /**
     * @param {?} data
     * @param {?} schema
     * @return {?}
     */
    JSONValidator.prototype.validateProperties = /**
     * @param {?} data
     * @param {?} schema
     * @return {?}
     */
    function (data, schema) {
        if (!schema.hasOwnProperty('properties') || (schema.properties == null)) {
            return true;
        }
        if (!this.isObjectNotNull(data)) {
            return false;
        }
        /**
             * Check if the object doesn't have more properties than expected
             * Equivalent of additionalProperties: false
             */
        if (Object.keys(schema.properties).length !== Object.keys(data).length) {
            return false;
        }
        /* Recursively validate all properties */
        for (var /** @type {?} */ property in schema.properties) {
            if (schema.properties.hasOwnProperty(property) && data.hasOwnProperty(property)) {
                if (!this.validate(data[property], schema.properties[property])) {
                    return false;
                }
            }
        }
        return true;
    };
    /**
     * @param {?} data
     * @param {?} schema
     * @return {?}
     */
    JSONValidator.prototype.validateRequired = /**
     * @param {?} data
     * @param {?} schema
     * @return {?}
     */
    function (data, schema) {
        if (!schema.hasOwnProperty('required') || (schema.required == null)) {
            return true;
        }
        if (!this.isObjectNotNull(data)) {
            return false;
        }
        for (var _i = 0, _a = schema.required; _i < _a.length; _i++) {
            var requiredProp = _a[_i];
            /* Checks if the property is present in the schema 'properties' */
            if (!schema.properties || !schema.properties.hasOwnProperty(requiredProp)) {
                throw new Error("'required' properties must be described in 'properties' too.");
            }
            /* Checks if the property is present in the data */
            if (!data.hasOwnProperty(requiredProp)) {
                return false;
            }
        }
        return true;
    };
    /**
     * @param {?} data
     * @param {?} schema
     * @return {?}
     */
    JSONValidator.prototype.validateEnum = /**
     * @param {?} data
     * @param {?} schema
     * @return {?}
     */
    function (data, schema) {
        if (!schema.hasOwnProperty('enum') || (schema.enum == null)) {
            return true;
        }
        /** @todo Move to ES2016 .includes() ? */
        return (schema.enum.indexOf(data) !== -1);
    };
    /**
     * @param {?} data
     * @param {?} schema
     * @return {?}
     */
    JSONValidator.prototype.validateType = /**
     * @param {?} data
     * @param {?} schema
     * @return {?}
     */
    function (data, schema) {
        if (!schema.hasOwnProperty('type') || (schema.type == null)) {
            return true;
        }
        switch (schema.type) {
            case 'null':
                return data === null;
            case 'string':
                return this.validateString(data, schema);
            case 'number':
            case 'integer':
                return this.validateNumber(data, schema);
            case 'boolean':
                return typeof data === 'boolean';
            case 'object':
                return typeof data === 'object';
            case 'array':
                return Array.isArray(data);
        }
    };
    /**
     * @param {?} data
     * @param {?} schema
     * @return {?}
     */
    JSONValidator.prototype.validateItems = /**
     * @param {?} data
     * @param {?} schema
     * @return {?}
     */
    function (data, schema) {
        if (!schema.hasOwnProperty('items') || (schema.items == null)) {
            return true;
        }
        if (!Array.isArray(data)) {
            return false;
        }
        if (schema.hasOwnProperty('maxItems') && (schema.maxItems != null)) {
            if (!Number.isInteger(schema.maxItems) || schema.maxItems < 0) {
                throw new Error("'maxItems' must be a non-negative integer.");
            }
            if (data.length > schema.maxItems) {
                return false;
            }
        }
        if (schema.hasOwnProperty('minItems') && (schema.minItems != null)) {
            if (!Number.isInteger(schema.minItems) || schema.minItems < 0) {
                throw new Error("'minItems' must be a non-negative integer.");
            }
            if (data.length < schema.minItems) {
                return false;
            }
        }
        if (schema.hasOwnProperty('uniqueItems') && (schema.uniqueItems != null)) {
            if (schema.uniqueItems) {
                var /** @type {?} */ dataSet = new Set(data);
                if (data.length !== dataSet.size) {
                    return false;
                }
            }
        }
        if (Array.isArray(schema.items)) {
            return this.validateItemsList(data, schema);
        }
        for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {
            var value = data_1[_i];
            if (!this.validate(value, schema.items)) {
                return false;
            }
        }
        return true;
    };
    /**
     * @param {?} data
     * @param {?} schema
     * @return {?}
     */
    JSONValidator.prototype.validateItemsList = /**
     * @param {?} data
     * @param {?} schema
     * @return {?}
     */
    function (data, schema) {
        var /** @type {?} */ items = /** @type {?} */ (schema.items);
        if (data.length !== items.length) {
            return false;
        }
        for (var /** @type {?} */ i = 0; i < items.length; i += 1) {
            if (!this.validate(data[i], items[i])) {
                return false;
            }
        }
        return true;
    };
    /**
     * @param {?} data
     * @param {?} schema
     * @return {?}
     */
    JSONValidator.prototype.validateString = /**
     * @param {?} data
     * @param {?} schema
     * @return {?}
     */
    function (data, schema) {
        if (typeof data !== 'string') {
            return false;
        }
        if (schema.hasOwnProperty('maxLength') && (schema.maxLength != null)) {
            if (!Number.isInteger(schema.maxLength) || schema.maxLength < 0) {
                throw new Error("'maxLength' must be a non-negative integer.");
            }
            if (data.length > schema.maxLength) {
                return false;
            }
        }
        if (schema.hasOwnProperty('minLength') && (schema.minLength != null)) {
            if (!Number.isInteger(schema.minLength) || schema.minLength < 0) {
                throw new Error("'minLength' must be a non-negative integer.");
            }
            if (data.length < schema.minLength) {
                return false;
            }
        }
        if (schema.hasOwnProperty('pattern') && (schema.pattern != null)) {
            var /** @type {?} */ regularExpression = new RegExp(schema.pattern);
            if (!regularExpression.test(data)) {
                return false;
            }
        }
        return true;
    };
    /**
     * @param {?} data
     * @param {?} schema
     * @return {?}
     */
    JSONValidator.prototype.validateNumber = /**
     * @param {?} data
     * @param {?} schema
     * @return {?}
     */
    function (data, schema) {
        if (typeof data !== 'number') {
            return false;
        }
        if ((schema.type === 'integer') && !Number.isInteger(data)) {
            return false;
        }
        if (schema.hasOwnProperty('multipleOf') && (schema.multipleOf != null)) {
            if (schema.multipleOf <= 0) {
                throw new Error("'multipleOf' must be a number strictly greater than 0.");
            }
            if (!Number.isInteger(data / schema.multipleOf)) {
                return false;
            }
        }
        if (schema.hasOwnProperty('maximum') && (schema.maximum != null)) {
            if (data > schema.maximum) {
                return false;
            }
        }
        if (schema.hasOwnProperty('exclusiveMaximum') && (schema.exclusiveMaximum != null)) {
            if (data >= schema.exclusiveMaximum) {
                return false;
            }
        }
        if (schema.hasOwnProperty('minimum') && (schema.minimum != null)) {
            if (data < schema.minimum) {
                return false;
            }
        }
        if (schema.hasOwnProperty('exclusiveMinimum') && (schema.exclusiveMinimum != null)) {
            if (data <= schema.exclusiveMinimum) {
                return false;
            }
        }
        return true;
    };
    JSONValidator.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] },
    ];
    /** @nocollapse */ JSONValidator.ngInjectableDef = defineInjectable({ factory: function JSONValidator_Factory() { return new JSONValidator(); }, token: JSONValidator, providedIn: "root" });
    return JSONValidator;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @record
 */

var LocalStorage = /** @class */ (function () {
    function LocalStorage(database, jsonValidator) {
        this.database = database;
        this.jsonValidator = jsonValidator;
        this.getItemOptionsDefault = {
            schema: null
        };
    }
    /**
     * Gets an item value in local storage
     * @param key The item's key
     * @returns The item's value if the key exists, null otherwise, wrapped in an RxJS Observable
     */
    /**
     * Gets an item value in local storage
     * @template T
     * @param {?} key The item's key
     * @param {?=} options
     * @return {?} The item's value if the key exists, null otherwise, wrapped in an RxJS Observable
     */
    LocalStorage.prototype.getItem = /**
     * Gets an item value in local storage
     * @template T
     * @param {?} key The item's key
     * @param {?=} options
     * @return {?} The item's value if the key exists, null otherwise, wrapped in an RxJS Observable
     */
    function (key, options) {
        var _this = this;
        if (options === void 0) { options = this.getItemOptionsDefault; }
        return this.database.getItem(key).pipe(/* Validate data upon a json schema if requested */
        mergeMap(function (data) {
            if (options.schema && data !== null) {
                var /** @type {?} */ validation = true;
                try {
                    validation = _this.jsonValidator.validate(data, options.schema);
                }
                catch (/** @type {?} */ error) {
                    return throwError(error);
                }
                if (!validation) {
                    return throwError(new Error("JSON invalid"));
                }
            }
            return of(data);
        }));
    };
    /**
     * Sets an item in local storage
     * @param key The item's key
     * @param data The item's value, must NOT be null or undefined
     * @returns An RxJS Observable to wait the end of the operation
     */
    /**
     * Sets an item in local storage
     * @param {?} key The item's key
     * @param {?} data The item's value, must NOT be null or undefined
     * @return {?} An RxJS Observable to wait the end of the operation
     */
    LocalStorage.prototype.setItem = /**
     * Sets an item in local storage
     * @param {?} key The item's key
     * @param {?} data The item's value, must NOT be null or undefined
     * @return {?} An RxJS Observable to wait the end of the operation
     */
    function (key, data) {
        return this.database.setItem(key, data);
    };
    /**
     * Deletes an item in local storage
     * @param key The item's key
     * @returns An RxJS Observable to wait the end of the operation
     */
    /**
     * Deletes an item in local storage
     * @param {?} key The item's key
     * @return {?} An RxJS Observable to wait the end of the operation
     */
    LocalStorage.prototype.removeItem = /**
     * Deletes an item in local storage
     * @param {?} key The item's key
     * @return {?} An RxJS Observable to wait the end of the operation
     */
    function (key) {
        return this.database.removeItem(key);
    };
    /**
     * Deletes all items from local storage
     * @returns An RxJS Observable to wait the end of the operation
     */
    /**
     * Deletes all items from local storage
     * @return {?} An RxJS Observable to wait the end of the operation
     */
    LocalStorage.prototype.clear = /**
     * Deletes all items from local storage
     * @return {?} An RxJS Observable to wait the end of the operation
     */
    function () {
        return this.database.clear();
    };
    /**
     * Sets an item in local storage, and auto-subscribes
     * @param key The item's key
     * @param data The item's value, must NOT be null or undefined
     */
    /**
     * Sets an item in local storage, and auto-subscribes
     * @param {?} key The item's key
     * @param {?} data The item's value, must NOT be null or undefined
     * @return {?}
     */
    LocalStorage.prototype.setItemSubscribe = /**
     * Sets an item in local storage, and auto-subscribes
     * @param {?} key The item's key
     * @param {?} data The item's value, must NOT be null or undefined
     * @return {?}
     */
    function (key, data) {
        this.setItem(key, data).subscribe(function () { }, function () { });
    };
    /**
     * Deletes an item in local storage, and auto-subscribes
     * @param key The item's key
     */
    /**
     * Deletes an item in local storage, and auto-subscribes
     * @param {?} key The item's key
     * @return {?}
     */
    LocalStorage.prototype.removeItemSubscribe = /**
     * Deletes an item in local storage, and auto-subscribes
     * @param {?} key The item's key
     * @return {?}
     */
    function (key) {
        this.removeItem(key).subscribe(function () { }, function () { });
    };
    /** Deletes all items from local storage, and auto-subscribes */
    /**
     * Deletes all items from local storage, and auto-subscribes
     * @return {?}
     */
    LocalStorage.prototype.clearSubscribe = /**
     * Deletes all items from local storage, and auto-subscribes
     * @return {?}
     */
    function () {
        this.clear().subscribe(function () { }, function () { });
    };
    LocalStorage.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] },
    ];
    /** @nocollapse */
    LocalStorage.ctorParameters = function () { return [
        { type: LocalDatabase, },
        { type: JSONValidator, },
    ]; };
    /** @nocollapse */ LocalStorage.ngInjectableDef = defineInjectable({ factory: function LocalStorage_Factory() { return new LocalStorage(inject(LocalDatabase), inject(JSONValidator)); }, token: LocalStorage, providedIn: "root" });
    return LocalStorage;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Generated bundle index. Do not edit.
 */

export { LocalDatabase, IndexedDBDatabase, LocalStorageDatabase, MockLocalDatabase, JSONValidator, LocalStorage, localStorageProviders, LOCAL_STORAGE_PREFIX, localDatabaseFactory as ɵa };
//# sourceMappingURL=local-storage.js.map
